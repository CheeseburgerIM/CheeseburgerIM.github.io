<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown Symbols</title>
      <link href="2021/01/07/MarkdownSymbols/"/>
      <url>2021/01/07/MarkdownSymbols/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><div class="table-container"><table><thead><tr><th>Symbol</th><th>Code</th></tr></thead><tbody><tr><td>Ω ω</td><td>\Omega or \omega</td></tr><tr><td>ρ</td><td>\rho</td></tr><tr><td>Φ φ</td><td>\Phi or \phi</td></tr></tbody></table></div><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2>]]></content>
      
      
      <categories>
          
          <category> Introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> New </tag>
            
            <tag> Introduction </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NEMU-PA3</title>
      <link href="2021/01/06/NEMU-PA3/"/>
      <url>2021/01/06/NEMU-PA3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="Phase1"><a href="#Phase1" class="headerlink" title="Phase1"></a>Phase1</h2><p><strong>From 2021/1/6 to 2120/1/</strong></p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
            <tag> Code </tag>
            
            <tag> Programme </tag>
            
            <tag> NEMU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Physics</title>
      <link href="2021/01/05/PhysicsChapter1/"/>
      <url>2021/01/05/PhysicsChapter1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="Chapter1：振动"><a href="#Chapter1：振动" class="headerlink" title="Chapter1：振动"></a>Chapter1：振动</h2><h3 id="一、简谐振动"><a href="#一、简谐振动" class="headerlink" title="一、简谐振动"></a>一、简谐振动</h3><h4 id="简谐振动方程"><a href="#简谐振动方程" class="headerlink" title="简谐振动方程"></a>简谐振动方程</h4><script type="math/tex; mode=display">x=Acos(ωt+Φ)</script><ul><li><p>在水平方向上的弹簧振子简谐运动中，有</p><script type="math/tex; mode=display">ω=\sqrt{\frac{k}{m}}</script></li><li><p>x对t求导得到v函数</p></li></ul><script type="math/tex; mode=display">v=\frac{dx}{dt}=-Aωsin(ωt+Φ)=Aωcos(ωt+Φ+\frac{\pi}{2})</script><ul><li>v对t求导得到a的函数</li></ul><script type="math/tex; mode=display">a=\frac{dv}{dt}=\frac{(dx)^2}{dt^2}=-Aω^2cos(ωt+Φ)=-ω^2x</script><ul><li><p>观察上式可得出结论：</p><p>最大位移为Xm，最大速度为Vm，最大加速度为am</p><p>则有|Xm|=A，|Vm|=Aω，|am|=Aω²</p></li></ul><h4 id="描述简谐振动特征的物理量"><a href="#描述简谐振动特征的物理量" class="headerlink" title="描述简谐振动特征的物理量"></a>描述简谐振动特征的物理量</h4><ul><li><p>振幅A：振幅是振动物体离开平衡位置的最大位移，反映振动强弱程度的物理量；</p></li><li><p>角频率ω：</p><script type="math/tex; mode=display">ω=2\pi f=\frac{2\pi}{T}</script></li><li><p>相位ωt+Φ：称为振动系统在时刻t的相位，其中Φ是振动系统在t=0时刻的相位，称为初相位。</p><p>相位每变化2π，振动的物体就完成一次全振动；</p></li><li><p>t=0时，有</p><script type="math/tex; mode=display">x_0=x|t=0=AcosΦ,v_0=v|t=0=-ωAsinΦ</script><p>由上式可得出</p><script type="math/tex; mode=display">A=\sqrt{(x_0)^2+(\frac{v_0}{ω})^2},tanΦ=-\frac{v_0}{ωx_0}</script></li></ul><h4 id="简谐振动的图示法——旋转矢量法"><a href="#简谐振动的图示法——旋转矢量法" class="headerlink" title="简谐振动的图示法——旋转矢量法"></a>简谐振动的图示法——旋转矢量法</h4><h4 id="简谐振动的能量"><a href="#简谐振动的能量" class="headerlink" title="简谐振动的能量"></a>简谐振动的能量</h4><ul><li><p>弹性势能Ep</p><script type="math/tex; mode=display">E_p=\frac{1}{2}kx^2=\frac{1}{2}kA^2cos^2(ωt+Φ)</script></li><li><p>动能Ek</p><script type="math/tex; mode=display">E_k=\frac{1}{2}mv^2=\frac{1}{2}mω^2A^2sin^2(ωt+Φ)=\frac{1}{2}kA^2sin^2(ωt+Φ)</script></li><li><p>因此，弹簧谐振子的总机械能为E</p><script type="math/tex; mode=display">E=E_k+E_p=\frac{1}{2}kA^2=\frac{1}{2}mω^2A^2</script></li><li><p>由此可知，弹簧谐振子的总机械能是一个不随时间变化的常量，即系统的机械能守恒。这也是简谐振动的一个显著的特征；</p></li><li><p>振幅不仅给出了简谐振动的运动范围，而且还反应了振动系统总能量的大小，或者说反应了振动的强度；</p></li><li><p>此外，弹簧谐振子的势能平均值和动能平均值(可以分别称为平均势能和平均动能)相等并且等于总机械能的一半。这一结论同样适用于其他简谐振动。</p></li></ul><h3 id="二、简谐振动的合成"><a href="#二、简谐振动的合成" class="headerlink" title="二、简谐振动的合成"></a>二、简谐振动的合成</h3><h4 id="两个同方向同频率简谐振动的合成"><a href="#两个同方向同频率简谐振动的合成" class="headerlink" title="两个同方向同频率简谐振动的合成"></a>两个同方向同频率简谐振动的合成</h4><ul><li><p>设某物体同时参与两个同方向，同频率的简谐振动，其表达式分别为</p><script type="math/tex; mode=display">x_1=A_1cos(ωt+Φ_1),x_2=A_2cos(ωt+Φ_2)</script></li><li><p>根据叠加原理，该物体在任意时刻的合振动的位移为</p><script type="math/tex; mode=display">x=x_1+x_2=A_1cos(ωt+Φ_1)+A_2cos(ωt+Φ_2)</script></li><li><p>合振动的表达式为</p><script type="math/tex; mode=display">x=Acos(ωt+Φ)</script></li><li><p>其中可以利用余弦定理得到合振幅</p><script type="math/tex; mode=display">A=\sqrt{A_1^2+A_2^2+2A_1A_2cos(Φ_2-Φ_1)}</script><p>初相位Φ满足</p><script type="math/tex; mode=display">tanΦ=\frac{A_1sinΦ_1+A_2sinΦ2}{A_1cosΦ_1+A_2cosΦ_2}</script><p>合振幅不仅与两个分振幅有关，还与两个分振动的相位差有关；</p><p>合振幅的值将介于最大值A1+A2和最小值|A1-A2|之间。</p></li></ul><h2 id="Chapter2：波动"><a href="#Chapter2：波动" class="headerlink" title="Chapter2：波动"></a>Chapter2：波动</h2><h3 id="一、波动方程、平面简谐波"><a href="#一、波动方程、平面简谐波" class="headerlink" title="一、波动方程、平面简谐波"></a>一、波动方程、平面简谐波</h3><ul><li><p>一维简谐波的波函数</p><script type="math/tex; mode=display">y(x,t)=Acos(ωt+kx+Φ),k=\frac{2\pi}{λ}</script><p>利用式中各物理量之间的关系，波函数还可以改写成</p><script type="math/tex; mode=display">y(x,t)=Acos[2\pi(\frac{t}{T}-\frac{x}{λ}+\phi)]</script></li><li><p>速度与加速的的函数同样是用求导的方法得到</p><script type="math/tex; mode=display">v(x,t)=\frac{∂y}{∂t}=-\omega Asin[\omega (t-\frac{x}{u})+\phi]</script><script type="math/tex; mode=display">a=\frac{∂v}{∂t}=\frac{∂^y}{∂t^2}=-\omega^2Acos[\omega (t-\frac{x}{u})+\phi]</script></li></ul><h3 id="二、波的能量、能流密度"><a href="#二、波的能量、能流密度" class="headerlink" title="二、波的能量、能流密度"></a>二、波的能量、能流密度</h3><h4 id="波的能量密度"><a href="#波的能量密度" class="headerlink" title="波的能量密度"></a>波的能量密度</h4><ul><li>波的平均能量密度与介质的密度ρ，角频率ω的平方以及振幅A的平方成正比。这一结论虽然是由平面简谐波导出的，但是对于各种机械波都是适用的。<script type="math/tex; mode=display">\overline\omega=\frac{1}{2}\rho\omega^2A^2</script></li></ul><h4 id="波的能流密度"><a href="#波的能流密度" class="headerlink" title="波的能流密度"></a>波的能流密度</h4><h3 id="三、波的干涉"><a href="#三、波的干涉" class="headerlink" title="三、波的干涉"></a>三、波的干涉</h3><h2 id="Chapter3：波动光学"><a href="#Chapter3：波动光学" class="headerlink" title="Chapter3：波动光学"></a>Chapter3：波动光学</h2><h3 id="一、光的干涉"><a href="#一、光的干涉" class="headerlink" title="一、光的干涉"></a>一、光的干涉</h3><h3 id="二、光的衍射"><a href="#二、光的衍射" class="headerlink" title="二、光的衍射"></a>二、光的衍射</h3><h3 id="三、光的偏振"><a href="#三、光的偏振" class="headerlink" title="三、光的偏振"></a>三、光的偏振</h3><h2 id="Chapter4：狭义相对论"><a href="#Chapter4：狭义相对论" class="headerlink" title="Chapter4：狭义相对论"></a>Chapter4：狭义相对论</h2><h3 id="一、洛伦兹变换与侠义相对论的时空观"><a href="#一、洛伦兹变换与侠义相对论的时空观" class="headerlink" title="一、洛伦兹变换与侠义相对论的时空观"></a>一、洛伦兹变换与侠义相对论的时空观</h3><h3 id="二、相对论力学"><a href="#二、相对论力学" class="headerlink" title="二、相对论力学"></a>二、相对论力学</h3><h2 id="Chapter5：物质的波粒二象性"><a href="#Chapter5：物质的波粒二象性" class="headerlink" title="Chapter5：物质的波粒二象性"></a>Chapter5：物质的波粒二象性</h2><h3 id="一、黑体辐射与能量子"><a href="#一、黑体辐射与能量子" class="headerlink" title="一、黑体辐射与能量子"></a>一、黑体辐射与能量子</h3><h3 id="二、光电效应与光子"><a href="#二、光电效应与光子" class="headerlink" title="二、光电效应与光子"></a>二、光电效应与光子</h3><h3 id="三、康普顿散射"><a href="#三、康普顿散射" class="headerlink" title="三、康普顿散射"></a>三、康普顿散射</h3><h3 id="四、物质波与德布罗意关系"><a href="#四、物质波与德布罗意关系" class="headerlink" title="四、物质波与德布罗意关系"></a>四、物质波与德布罗意关系</h3><h3 id="五、氢原子和玻尔的量子论"><a href="#五、氢原子和玻尔的量子论" class="headerlink" title="五、氢原子和玻尔的量子论"></a>五、氢原子和玻尔的量子论</h3><h2 id="Chapter6：量子力学基础"><a href="#Chapter6：量子力学基础" class="headerlink" title="Chapter6：量子力学基础"></a>Chapter6：量子力学基础</h2><h3 id="一、物质波波函数的特性"><a href="#一、物质波波函数的特性" class="headerlink" title="一、物质波波函数的特性"></a>一、物质波波函数的特性</h3><h3 id="二、薛定谔方程"><a href="#二、薛定谔方程" class="headerlink" title="二、薛定谔方程"></a>二、薛定谔方程</h3><h3 id="三、一维定态系统"><a href="#三、一维定态系统" class="headerlink" title="三、一维定态系统"></a>三、一维定态系统</h3><h3 id="四、氢原子"><a href="#四、氢原子" class="headerlink" title="四、氢原子"></a>四、氢原子</h3><h3 id="五、电子的自旋-原子的壳层结构"><a href="#五、电子的自旋-原子的壳层结构" class="headerlink" title="五、电子的自旋  原子的壳层结构"></a>五、电子的自旋  原子的壳层结构</h3>]]></content>
      
      
      <categories>
          
          <category> Physics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件管理</title>
      <link href="2020/12/31/OSChapter3/"/>
      <url>2020/12/31/OSChapter3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h2 id="Points"><a href="#Points" class="headerlink" title="Points"></a>Points</h2><ul><li><p>RAID</p><p>独立磁盘冗余阵列；</p><p>把硬盘组合在一起，组成一个磁盘阵列；实现对数据的可靠性，读写快速性，冗余性廉价性的存储；</p><p>功能：</p><p>提高I/O能力——磁盘并行读写；</p><p>提高耐用性——磁盘冗余来实现；</p><p><strong>磁盘镜像，奇偶校验可提高RAID可靠性</strong>；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="2020/12/29/OSChapter2/"/>
      <url>2020/12/29/OSChapter2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h2><h3 id="1-内存的基础知识"><a href="#1-内存的基础知识" class="headerlink" title="1.内存的基础知识"></a>1.内存的基础知识</h3><h4 id="逻辑地址与物理地址"><a href="#逻辑地址与物理地址" class="headerlink" title="逻辑地址与物理地址"></a>逻辑地址与物理地址</h4><p>Eg：编译时只需确定变量x存放的相对地址是100(也就是说相对于进程在内存中的起始地址的地址)。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可；</p><p><strong>相对地址又称逻辑地址，绝对地址又称物理地址。</strong></p><h4 id="装入内存的三种方式"><a href="#装入内存的三种方式" class="headerlink" title="装入内存的三种方式"></a>装入内存的三种方式</h4><ol><li><p>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</p><p>绝对装入由于逻辑与实际内存地址相同，故不需要对程序的数据的地址进行修改。</p><p><strong>绝对装入只适用于弹道程序环境</strong>，绝对地址可由程序员在编译或者汇编时赋予。</p></li><li><p>可重定位装入：<strong>在多道程序环境下</strong>，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的，此时采用可重定位装入方式，根据内存的目前情况，将装入模块装入到内存的适当位置。装入时对目标程序中指令和数据的修改称为重定位，地址变换通常是在装入时一次完成的，所以又称<strong>静态重定位</strong>。</p></li><li><p>动态运行时装入：也称为<strong>动态重定位</strong>。程序在内存中如果发生移动，就素要采用动态的装入方式。编译，链接后的装入模块的地址都是从0开始的。装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换成绝对地址，而是<strong>把这种地址转换推迟到程序真正要执行时才进行</strong>。因此，装入内存后的所有地址均为相对地址。这种方式需要<strong>一个重定位寄存器的支持</strong>。动态重定位的特点是<strong>可以将程序分配到不连续的存储区中，在程序运行之前可以只装入它的部分代码即可投入运行</strong>，然后在程序运行期间，根据需要动态申请分配的内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。<strong>用于现代操作系统</strong>。</p></li></ol><h3 id="2-内存管理的概念"><a href="#2-内存管理的概念" class="headerlink" title="2.内存管理的概念"></a>2.内存管理的概念</h3><p>操作系统作为系统资源的管理者，当然也需要对内存进行管理</p><ol><li>操作系统负责内存空间的分配与回收；</li><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充；</li><li>操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址与物理地址的转换</strong>；</li><li>操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰。</li></ol><h4 id="内存空间的扩展"><a href="#内存空间的扩展" class="headerlink" title="内存空间的扩展"></a>内存空间的扩展</h4><p>内存空间的扩充：利用虚拟存储技术或者自动覆盖技术，从逻辑上扩充内存。</p><p>Eg：游戏GTA5的大小约100G，按理来说运行这个游戏需要把100G的数据全部放入内存。然而，我的电脑实际内存只有8G(虚拟技术-操作系统的虚拟性)。</p><h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p>保证各道作业在各自的存储空间内运行，互不干扰，有以下两种方式：</p><ol><li>CPU中设置一对上，下限寄存器，存放用户作业在主存中的上限和下限，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断是否越界；</li><li>通过采用重定位寄存器(或基址寄存器)和界地址寄存器(又称限长寄存器)来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值，每个逻辑地址值必须小于界地址寄存器，内存管理结构动态得将逻辑地址与界地址寄存器进行比较，如果未发生地址越界。则加上重定位寄存器的值后映射成物理地址，再送交内存单元。</li></ol><h4 id="内存的覆盖与交换"><a href="#内存的覆盖与交换" class="headerlink" title="内存的覆盖与交换"></a>内存的覆盖与交换</h4><h5 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h5><ul><li>由于程序运行时并非任何时候都要访问程序及数据的各个部分(尤其是大程序)，因此可以把用户空间分成一个固定区和若干个覆盖区。将经尝活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段；</li><li>特点：打破了必将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而需要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻保存。</li></ul><h5 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h5><ul><li>交换技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间的动态调度)；</li><li>换入：把准备好竞争CPU运行的程序从辅存移到内存；</li><li>换出：把处于等待状态(或CPU调度原则下被剥夺运行权力)的程序从内存移到辅存，把内存空间腾出来；</li><li>暂时换出外存等待的进程状态为<strong>挂起状态(suspend)</strong>，挂起态又可以进一步细分为<strong>就绪挂起，阻塞挂起</strong>两种状态；</li></ul><h3 id="3-连续分配管理方式"><a href="#3-连续分配管理方式" class="headerlink" title="3.连续分配管理方式"></a>3.连续分配管理方式</h3><p><strong>内部碎片：分配给某进程的内存区域中，没有用上的部分；</strong></p><p><strong>外部碎片：内存中的某些空闲分区由于太小而难以利用。</strong></p><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><ul><li><strong>内存在此方式下分为系统区和用户区；</strong></li><li>系统区仅提供给操作系统使用，通常在低地址部分；</li><li>用户区是为用户提供的，除系统区外的内存空间，我们平常运行的软件都在用户区里分配空间；</li><li>优点：无外部碎片，可以采用覆盖技术，不需要额外技术支持；</li><li>缺点：只能用于单用户，单任务操作系统中，有内部碎片，存储器利用率极低。</li></ul><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><ul><li>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后背作业队列中，选择适当大小的作业装入该分区，如此循环；</li><li>优点：实现简单，无外部碎片；</li><li>缺点：程序可能太大而放不进任何一个分区中，这是用户不得不使用覆盖技术来使用内存空间。</li></ul><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><ul><li>又称<strong>可变分区分配</strong>，是一种动态划分内存的分区方法；</li><li>这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态建立分区，并使分区的大小正好适合进程的需要；</li><li>因此系统分区的大小和数目是可变的；</li><li>缺点：外部碎片很多(通过紧凑消除，就是操作系统不时地对进程进行移动和整理。但是这是要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于Windows系统中的磁盘整理程序，只不过后者是对外存空间的紧凑)。</li></ul><h3 id="4-动态分区分配算法"><a href="#4-动态分区分配算法" class="headerlink" title="4.动态分区分配算法"></a>4.动态分区分配算法</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><ul><li>算法思想：每次都从低地址开始查找，找到一个能满足大小的空闲分区；</li><li>实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li></ul><h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><ul><li>算法思想：由于动态分区是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片地空闲区，即优先使用更小的空闲区；</li><li>实现：空闲区按容量递增地次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li></ul><h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><ul><li>又称最大适应算法</li><li>算法思想：为了解决最佳适应算法问题——留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用；</li><li>实现：空闲区按容量递减地次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li></ul><h4 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h4><ul><li>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束地位置开始检索，就能解决上述问题；</li><li>实现：空闲分区以地址递增地顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束地位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li></ul><h3 id="5-存储管理"><a href="#5-存储管理" class="headerlink" title="5.存储管理"></a>5.存储管理</h3><h4 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h4><ul><li><p>如果允许将一个<a href="https://baike.baidu.com/item/进程/382503">进程</a>直接分散地装入到许多不相邻的分区中，则无须再进行“紧凑”。基于这一思想而产生了<a href="https://baike.baidu.com/item/离散/858263">离散</a>分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式。在分页存储管理方式中，如果不具备<a href="https://baike.baidu.com/item/页面/5544813">页面</a><a href="https://baike.baidu.com/item/对换/2817180">对换</a>功能，则称为基本分页存储管理方式，或称为纯分页存储管理方式，它不具有支持实现<a href="https://baike.baidu.com/item/虚拟存储器/944209">虚拟存储器</a>的功能，它要求把每个作业全部装入内存后方能运行。</p></li><li><p><strong>逻辑地址结构：页号+页内偏移量；</strong></p></li><li><p>一个进程对应一张页表；</p><p>进程的每一页对应一个页表项；</p><p>每个页表项由页号和块号组成；</p><p>页表记录进程页面和实际存放的内块之间的对应关系；</p><p>每个页表项的长度是相同的，页号是隐含的。</p></li></ul><h4 id="分段式存储管理"><a href="#分段式存储管理" class="headerlink" title="分段式存储管理"></a>分段式存储管理</h4><ul><li><p>引入分段存储管理方式，主要是为了满足用户和程序员地一系列需要</p><p>方便编程，信息共享，信息保护，动态增长，动态链接</p></li><li><p>原理：在分段存储管理方式中，作业的<a href="https://baike.baidu.com/item/地址空间">地址空间</a>被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、<a href="https://baike.baidu.com/item/子程序">子程序</a>段X、<a href="https://baike.baidu.com/item/数据段">数据段</a>D及栈段S等，如图4-17所示。每个段都有自己的名字。为了实现简单起见，通常可用一个段号来代替段名，每个段都从0开始<a href="https://baike.baidu.com/item/编址">编址</a>，并采用一段连续的<a href="https://baike.baidu.com/item/地址空间">地址空间</a>。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的<a href="https://baike.baidu.com/item/地址空间">地址空间</a>由于是分成多个段，因而是二维的，亦即，其<a href="https://baike.baidu.com/item/逻辑地址">逻辑地址</a>由段号(段名)和段内地址所组成。</p></li><li><p><strong>逻辑地址结构：段号+段内地址；</strong></p></li></ul><h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><ul><li>段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。</li><li>在段页式系统中，一作业地址结构由段号、段内页号及页内地址三部分所组成。</li><li>段页式存储的实现结合了页式和段式管理的基本思想，即<strong>用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间</strong>。</li><li><strong>逻辑地址结构：段号+页号+页内偏移量。</strong></li></ul><h4 id="分段，分页管理对比"><a href="#分段，分页管理对比" class="headerlink" title="分段，分页管理对比"></a>分段，分页管理对比</h4><ul><li>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理.上的需要，完全是系统行为，对用户是不可见的。段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。-一个段通常包含着一-组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li><li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li><li>在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。</li><li>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li><li>分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的。</li></ul><h3 id="6-多级页表"><a href="#6-多级页表" class="headerlink" title="6.多级页表"></a>6.多级页表</h3><p>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面也可以正常运行了，因此没有必要让整个页表都常驻内存。</p><p>单级页表问题</p><ul><li>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框；</li><li>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需访问某几个特定的页面；</li><li><strong>减少页表所占的内存空间。</strong></li></ul><h3 id="7-快表"><a href="#7-快表" class="headerlink" title="7.快表"></a>7.快表</h3><ul><li>又称<strong>联想寄存器(TLB)</strong>，是一种访问速度比内存快很多的高速缓冲寄存器，用来存放当前访问的若干页表项，<strong>以加速地址变换的过程</strong>；</li><li>与此对应，内存中的页表称为慢表。</li></ul><h3 id="8-倒排页表"><a href="#8-倒排页表" class="headerlink" title="8.倒排页表"></a>8.倒排页表</h3><ul><li>优点：减少占用的内存空间；</li><li>缺点：更长的查询时间；进程间共享内存实现更困难。</li><li>存储的时有关每个物理页框的信息，所以倒排页表项与物理内存页框有一一对应关系，它所包含的页表项数量较少。</li><li><strong>Eample：物理地址空间4GB，页面长4KB，页表项大小为4B。故倒排页表共有4GB/4KB=1M个页表项，倒排页表大小为1M×4B=4MB</strong>。</li><li><strong>系统维护一张倒排页表；</strong></li><li><strong>使用Hash散列，可以解决倒排页表不便于逻辑地址向物理地址转换的问题</strong>。</li></ul><h2 id="二、虚拟内存"><a href="#二、虚拟内存" class="headerlink" title="二、虚拟内存"></a>二、虚拟内存</h2><h3 id="1-虚拟内存的基本概念"><a href="#1-虚拟内存的基本概念" class="headerlink" title="1.虚拟内存的基本概念"></a>1.虚拟内存的基本概念</h3><p><strong>虚拟内存只能基于非连续分配技术；</strong></p><h4 id="传统存储管理方式的特征，缺点"><a href="#传统存储管理方式的特征，缺点" class="headerlink" title="传统存储管理方式的特征，缺点"></a>传统存储管理方式的特征，缺点</h4><ul><li><p>一次性(可用虚拟存储技术解决问题)：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：</p><p>1.作业很大时，不能全部装入内存，导致大作业无法运行；</p><p>2.当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</p></li><li><p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的，暂时用不到的数据，浪费了宝贵的内存资源。</p></li></ul><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><ul><li>时间局部性：如果执行力程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</li><li>空间局部性：一旦程序访问量某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中是连续存放的，并且程序的指令页式顺序的在内存中存放的)</li></ul><h4 id="虚拟地址的定义和特征"><a href="#虚拟地址的定义和特征" class="headerlink" title="虚拟地址的定义和特征"></a>虚拟地址的定义和特征</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>在操作系统的管理下，用户看到似乎有一个比实际内存大得多的内存，就是虚拟内存。</p><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是运行被分成多次调入内存；</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行的过程中，将作业换出，换入；</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>请求分页存储管理；</li><li>请求分段式存储管理；</li><li>请求段页式存储管理。</li></ul><p>请求分页系统建立在基本分页系统的基础上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种虚拟存储器方法。</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存(操作系统要提供请求调页或请求调段功能)，然后继续执行程序。</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存(操作系统要提供页面置换或段置换的功能)。</p><h3 id="2-请求分页管理方式"><a href="#2-请求分页管理方式" class="headerlink" title="2.请求分页管理方式"></a>2.请求分页管理方式</h3><h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h4><p>定义：缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p><h3 id="3-页面置换算法"><a href="#3-页面置换算法" class="headerlink" title="3.页面置换算法"></a>3.页面置换算法</h3><h4 id="最佳置换法-OPT"><a href="#最佳置换法-OPT" class="headerlink" title="最佳置换法(OPT)"></a>最佳置换法(OPT)</h4><h4 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a>先进先出置换算法(FIFO)</h4><h4 id="最近最久未使用置换算法-LRU"><a href="#最近最久未使用置换算法-LRU" class="headerlink" title="最近最久未使用置换算法(LRU)"></a>最近最久未使用置换算法(LRU)</h4><h4 id="时钟置换算法-CLOCK-NRU-最近未使用"><a href="#时钟置换算法-CLOCK-NRU-最近未使用" class="headerlink" title="时钟置换算法(CLOCK)(NRU:最近未使用)"></a>时钟置换算法(CLOCK)(NRU:最近未使用)</h4><h4 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h4><h4 id="老化算法"><a href="#老化算法" class="headerlink" title="老化算法"></a>老化算法</h4><ul><li>修改：第一是计数器在R位被加进来之前右移一位；</li><li>第二是将R位加到计数器的最左端；</li><li><strong>LRU的近似实现</strong>。</li></ul><h4 id="工作集置换算法"><a href="#工作集置换算法" class="headerlink" title="工作集置换算法"></a>工作集置换算法</h4><ul><li><p>一个进程当前正在使用的页面集合称为它的工作集；</p></li><li><p>如果整个工作集都被装入到了内存中，那么进程在运行到下一运行阶段之前，不会产生很多缺页中断；</p></li><li><p>如果内存太小而无法容纳下整个工作集，那么进程的运行过程会产生大量的缺页中断，导致运行速度变得很缓慢；</p></li><li><p>原理：</p><p>进程设置一个虚拟时钟，执行一个时钟周期就加 1，不执行就不增加。 </p><p>每个页面被访问时，记录最后访问的虚拟时间，R 位置 1。R 位定期 清除。</p><p>如果 R=1,则保留，将当前时间记录下来。</p><p>如果 R=0 对 比当前虚拟时间与页面最后访问时间差 age 与阈值 τ，如 age&gt;τ 则淘汰。如果 age &lt;= τ，则记录其访问时间，必要时淘汰其中最旧的。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="table-container"><table><thead><tr><th>算法</th><th>算法规则</th><th>优缺点</th></tr></thead><tbody><tr><td>OPT</td><td>优先淘汰最长时间内不会被访问的页面</td><td>缺页率最小，性能最好；但无法实现</td></tr><tr><td>FIFO</td><td>优先淘汰最先进入内存的页面</td><td>实现简单；但性能很差，可能出现Belady现象</td></tr><tr><td>LRU</td><td>优先淘汰最近最久没访问过的页面</td><td>性能很好；但需要硬件支持，算法开销大</td></tr><tr><td>CLOCK</td><td>循环扫描各页面，第一轮淘汰访问位=0的，并将扫描过的访问位改为1；若第一轮没选中，则进行第二轮扫描</td><td>实现简单，算法开销小；但未考虑页面是否被修改过</td></tr><tr><td>Improved CLOCK</td><td>若用(访问位，修改位)的形式表述，则第一轮淘汰(0,0)；第二轮淘汰(0,1)，并将扫描过的页面的访问位都置为0；第三轮淘汰(0,0)；第四轮淘汰(0,1)</td><td>算法开销较小，性能也不错</td></tr><tr><td>老化算法</td><td></td></tr></tbody></table></div><h3 id="4-页面分配"><a href="#4-页面分配" class="headerlink" title="4.页面分配"></a>4.页面分配</h3><h4 id="页面分配，置换策略"><a href="#页面分配，置换策略" class="headerlink" title="页面分配，置换策略"></a>页面分配，置换策略</h4><h2 id="Points"><a href="#Points" class="headerlink" title="Points"></a>Points</h2><ul><li><p><strong>增大块表(TLB)，让页表常驻内存</strong>能够加快虚实地址转换；</p></li><li><p>TLB：转译后备缓冲区</p></li><li><p>段页式存储的实现结合了页式和段式管理的基本思想，即<strong>用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间</strong>；</p></li><li><p>交换区：存在于数据服务器上的一个共享文件夹。它的作用是为前台与后台数据交换提供一个场所；</p><p>当系统内存不足，特殊应用程序(如oracle，lotus notes等)有需求时，将挂载交换区空间；</p></li><li><p>主存==内存；</p></li><li><p><strong>Belady现象：采用FIFO算法</strong>时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象；</p></li><li><p>系统抖动：</p><p>- 解释为在请求分页存储管理中，从主存(DRAM)中刚刚患处某一页面后，根据请求马上又换入该页，这种反复换出换入的现象；<br>- 主存与辅存间频繁的页面置换现象；<br>- 产生该现象的主要原因是置换算法选择不当；</p></li><li><p><strong>虚拟存储器只能基于非连续分配技术</strong>；</p></li><li><p><strong>物理地址至少是：页表大小×物理存储区块数</strong></p><p>Example：设有8页的逻辑空间，每页有1024B，它们被映射到32块的物理存储区中。</p><p>逻辑地址有效位：1024×8=2^3×2^10=2^13，即13位；</p><p>物理地址至少位数：1024×32=2^10×2^5=2^15，即15位；</p></li><li><p><strong>无论用什么算法，缺页次数不会少于页面引用串中不同的页号的个数</strong>；</p></li><li><p>有些程序并不适合于按需调页，例如：二分法搜索；</p></li><li><p>可以被多个进程在任意时刻共享的代码必须是<strong>不能自身修改的代码</strong>；</p></li><li><p>若用户进程访问内存时产生缺页，则操作系统可能执行的操作是置换页或分配内存；</p></li><li><p>变址寄存器：至寄存器ESI,EDI,SI和DI的寄存器，它们主要用于存放存储单元在段内的偏移量；</p></li><li><p>变址寻址：把变址寄存器中的内容(通常是位移量)与指令地址码部分给出的地址(通常是首地址)之和作业操作数的地址来获得所需要的操作数；</p></li><li><p>Example：假设变址寄存器 R 的内容为 1000H，指令中的形式地址为 2000 H；地址 1000H 中的内容为2000H，地址2000H中的内容为3000H，地址3000 H中的内容为4000H， 则变址寻址方式下访问到的操作数是： 4000H</p><p>解析：变址寻址方式下有效地址EA=R+A=1000H+2000H=3000H，操作数S=地址3000H中的内容，即4000H；</p></li><li><p>在请求分页系统中，页表中的辅存始地址是供<strong>页面调入</strong>参考的；</p></li><li><p><strong>页表项中最多可以保存的标志位位数=页表项最大位数-页框号位数</strong>；</p><p>Example：页表项大小为4B，页面大小为1KB，逻辑地址空间为32位，物理地址空间为4GB。</p><p>解：页表项共有4×8=32位；物理地址空间共32位；页内偏移量10位；页框号22位；</p><p>∴标志位位数=32-22=10位；</p></li><li><p><strong>逻辑地址访问时间</strong>：设对主存的一次存取需要100ns，对TLB表查找的时间为10ns，缺页中断处理时间为10^8ns</p><p>逻辑地址对应的页号在内存中且在TLB表中：100+10=110ns；</p><p>逻辑地址对应的页号在内存中但不在TLB表中：10+100+100=210ns；</p><p>逻辑地址页号不在内存中：10^8+220ns。</p></li><li><p><strong>页表项中有效位为0时，即不在内存中，缺页</strong>；</p></li><li><p>分段式内存管理解决了分页式内存管理中划分页时仅根据大小划分，这样可能将无关的内容分到一页中，此页不便设置权限与保护，也不利于共享。也有可能把密切相关的内容分到不同页中，当页面置换算法不当时，内存紧张时容易形成抖动现象。分段式内存管理带来的问题是段往往过大，多次分配释放后可能形成大量外部碎片，内存利用率不高；</p></li><li><p><strong>Intel IA32 的保护模式下内存管理方法不是段页式内存管理方法</strong>。因为段页式内存管理是分段时段内再分页，整个是一件事。而保护模式是通过分段将逻辑地址转换成线性地址，第二步通过分页将线性地址转成物理地址，这是两件事。</p></li><li><p>LRU 需求记录所有页面长期运行中被使用的时间和次数，需要大量的快速存 储空间，而且比较复杂，不容易实现。替代方案可以采用老化（aging）算法， 每个页面有一个长度有限的记数器，记录每个 tick 内 页面使用情况，记录信 息的权重逐次递减。这种算法与 LRU 相比，不能记录每个 tick 中内存使用情 况，而且记录的位数有限，但是实现方案较易实现。</p></li><li><p>分页式：逻辑地址空间划分只简单依靠页面大小，缺乏内在逻辑性，导致一方 面相关内容被分散 到多页上，页面置换不当时容易造成内存抖动，另一方面 不同性质的内容被分到同一页中，使得页面 权限保护设置困难。 分段式：段 体积大，在内存中无法不连续存储，易形成内存外碎片，降低内存利用率。 段页式：先分段再分页，以段为单位调入调出，以页为单位在内存中不连续存 储，既保证了相关内容 同时进出内存，便于设置权限保护，又可以充分利用 内存空间。 段页式结构复杂，实现起来效率低，所以没有被广泛采用。</p></li><li><p>最差适应分配最大空间的分区给进程使用，以期剩余外碎片空间较大，再 次利用的可能性较大。固定分区无外碎片，故不应采用这种算法。 交换技术交换的单位是进程，请求式分段技术交换的单位是段。 请求式分段是操作系统进行段调入调出，此过程对程序员透明，而覆盖技术需 要程序员自己完成调入调出。</p></li><li><p>页面置换应该在内存空余空间小于一个固定的下限阈值时开始，并在达到 另一个上限阈值时停止。 OPT 最理想但不可能实现。 LRU 要求比较最近最少 使用的页面，条件多，要存储的数据量大，比较的时间长，很难实现。 Belady 异常指的时当增加页框时缺页中断发生的数量反而升高的现象。 FIFO 存在 Belady 异常。</p></li><li><p>分段比分页更有逻辑性，将同类的或相关的内容放在一个段内，这样不会 由于页面置换算法选择不当而形成“抖动”现象。同类内容划分在一个 段内，可以实现段的保护，如代码段设置为只读，数据段设置为读写。公共代码段可以通过映射共享到多个进程。段页式既按照相关性划分 段，继承了分段的优势，又有分页管理可以不连续存储，能够充分利 用空间的好处。</p></li><li><p>缓存主要用于解决 CPU 和内存之间存在的速度差。一般来说，CPU 中寄 存器的速度要远快于内存，将 CPU 要用到的数据预先从内存中读到缓存，这 样 CPU 使用时就可以快速得到数据，写回内存的过程也类似。TLB 就是使用 缓存的一个典型例子。</p></li><li><p>在 64 位系统中，由于虚拟地址太大，普通页表会非常大，无法存储。另一方 面，实际内存 相对较小，所以建立一张从物理地址索引得到相对地址的倒排 页表。 最大的问题的难于从相对地址查找到绝对地址。可以采用 hash 表ᨀ高 查找效率，并使用 TLB 加速查找。</p></li><li><p>老化算法与 LRU 相比，主要有两点区别：（1）老化算法记录使用情况的 寄存器只有有限位， 比如 8 位，无法记录所有使用情况。（2）同一时间间隔 内只使用 0/1 区分页面使用情况，无法详 细区别间隔内的具体时间</p></li><li><p>内存分区管理中的交换技术与请求式分段技术的相同点与不同点：相同点都是为了在内存不足的情况下装入更多的进程，都是会产生外碎片。 不同点为交换 技术交换的对象是整个进程而请求式分段交换的进程中的一个段。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GTAV</title>
      <link href="2020/12/27/GTAV/"/>
      <url>2020/12/27/GTAV/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game </tag>
            
            <tag> GTAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程管理</title>
      <link href="2020/12/22/OSChapter1/"/>
      <url>2020/12/22/OSChapter1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量(Semaphore)"></a>信号量(Semaphore)</h3><ul><li><p>一个整型变量；</p></li><li><p>按取值范围分类：</p><p>1.Semaphore∈R </p><script type="math/tex; mode=display">Semaphore=\begin{cases}positive  可用资源数量\\Zero 无可用资源，无等待进程\\Negative 等待进程的数量\\\end{cases}</script><p>2.非负数</p><p>3.0/1(mutex，互斥锁)-二进制信号量</p></li><li><p>PV操作 ：一种实现进程互斥与同步的有效方法，P表示通过，V表示释放；</p><p>P：s—，if(s&lt;0) add to the semaphore’s queue and sleep；</p><p>V：s++，if(s&lt;=0) wake up the waiting process in the semaphore’s queue；</p></li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p><img src="https://pic.downk.cc/item/5fe1cbe53ffa7d37b36c2671.jpg" alt=""></p><p><strong>只有running和ready之间可以相互转换</strong></p><p>Example：</p><ol><li>Ready：<ul><li>进程正等待进入内存；</li><li>进程正等待分给它一个时间片；</li></ul></li><li>Running：<ul><li>进程正等待中央处理机；</li></ul></li><li>Blocked：<ul><li>进程正等待合作进程的一个消息；</li></ul></li></ol><h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><ul><li>同步</li><li>进程之间这种相互合作，协同工作的关系称为进程的同步；</li><li>直接制约</li><li>多个相关进程在执行次序上的协调；</li><li></li><li>互斥</li><li>临界资源：也称独占资源，是指在一段时间内只允许一个进程访问的资源。例如打印机，磁带机，也可以是进程共享的数据，变量等；</li><li>间接制约；</li><li>当多个进程因为争夺临界资源二互斥执行称为进程的互斥。</li></ul><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul><li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；</li><li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li><li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间，包括代码段，数据集，堆等，及一些进程及的资源，某进程内的线程在其他进程不可见；</li><li>不管系统中是否有线程，进程都是拥有资源的独立单位；</li><li>在不支持线程的操作系统中，进程既是资源分配的基本单位，也是调度的基本单位；</li><li>在拥有线程的操作系统中，线程是调度的基本单位，而进程是资源分配的基本单位；</li><li>对于切换时是否需要内核的支持，系统级线程需要，用户级线程不需要；</li><li>同一进程中的线程共享同一物理内存空间。</li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li><p>用户态线程与内核态线程</p><p>所谓用户态线程就是把内核态的线程在用户态实现了一遍而已，目的是更轻量化（更少的内存占用、更少的隔离、更快的调度）和更高的可控性（可以自己控制调度器）。用户态所有东西内核态都「看得见」，只是对于内核而言「用户态线程」只是一堆内存数据而已。</p></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><p>当系统中供多个进程共享的资源如打印机，公共队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。</p><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ol><li><strong>互斥条件</strong>：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只有一个进程占用。如果此时还有其他进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放；</li><li><strong>请求和保持条件</strong>：指进程已经保持至少一个资源，但是又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放；</li><li><strong>不剥夺条件</strong>：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完成时自己释放；</li><li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0,P1,P2,…,Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源,……,Pn正在等待已被P0占用的资源。</li></ol><h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><ul><li><p>采用按序分配资源策略可以防止死锁，这是因为它能破坏产生死锁的四个必要条件中的环路等待条件；</p></li><li><p>在操作系统中，常用以下方法应对死锁：</p><p><strong>鸵鸟算法</strong>：因为处理死锁成本太高，而死锁出现的频率较低，故可以忽略死锁的发生；</p><p><strong>Spooling技术</strong>：假脱机技术。为临界资源增加一个等待队列，使其好像可以被共享使用，如打印机。</p></li><li><p>当死锁发生时，杀死运行时间较短的进程，损失较小，容易恢复。</p></li></ul><h3 id="用户态和内核态的转换"><a href="#用户态和内核态的转换" class="headerlink" title="用户态和内核态的转换"></a>用户态和内核态的转换</h3><p><strong>方式</strong></p><ul><li><strong>系统调用</strong>：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作；</li><li><strong>异常</strong>：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常；</li><li><strong>外围设备的中断</strong>：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这是CPU会暂停执行吓一跳即将要执行的指令而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的转换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li></ul><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>银行家算法是一个避免死锁的著名算法，它以银行贷款系统的分配策略为基础，判断并保证系统的安全运行。</p><p>银行家算法可避免死锁，但没有破坏死锁发生的四个必要条件中的任何一个。</p><h4 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h4><p>如果存在一个由系统中所有进程构成的安全序列P1,P2,…,Pn，则系统处于安全状态。安全状态一定是没有死锁发生。</p><h4 id="不安全状态"><a href="#不安全状态" class="headerlink" title="不安全状态"></a>不安全状态</h4><p>不存在一个安全序列。不安全状态不一定导致死锁。</p><h3 id="时间片轮换调度算法"><a href="#时间片轮换调度算法" class="headerlink" title="时间片轮换调度算法"></a>时间片轮换调度算法</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>每次调度时，总是选择就绪队列的队首进程，让其在CPU上运行一个系统预先设置好的时间片。一个时间片内没有完成运行的进程，返回到队列末尾重新排队，等待下一次调度。</p><h3 id="进程饥饿"><a href="#进程饥饿" class="headerlink" title="进程饥饿"></a>进程饥饿</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>指当等待时间给进程推进和响应带来明显影响称为进程饥饿。当饥饿到一定程度的进程在等待到即使完成也无实际意义的时候称为饥饿死亡。</p><h4 id="预防-1"><a href="#预防-1" class="headerlink" title="预防"></a>预防</h4><p>公平的调度算法可以避免饥饿现象，例如时间片轮换算法，所有进程的地位相同；</p><p>例如静态优先级调度，非抢占式作业优先调度，抢占式短作业优先调度算法等可能导致饥饿现象。</p><ul><li><p>非抢占式优先权调度算法</p><p>系统一旦把处理机分配给优先权最高的进程后，便一直执行下去至完成；</p></li><li><p>抢占式优先调度算法</p><p>只要系统中出现一个新的就绪进程，就进行优先权比较。若出现优先权更高的进程，则立即停止当前进程的执行，并将处理机分配给新到的优先权最高的进程。</p></li></ul><h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><h4 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h4><p>在多道程序系统中，调度实质是一种资源分配，处理机调度算法是指根据处理机分配策略随规定的处理机分配算法。一个作业从获得处理机执行到作业运行完毕，可能会经历多级处理机调度。</p><h5 id="1-高级调度"><a href="#1-高级调度" class="headerlink" title="1.高级调度"></a>1.高级调度</h5><p>高级调度又称为长程调度或者作业调度，它的调度对象是作业。主要功能是根据某种算法，决定将外村上处于后备队列中哪几个作业调入内存，为它们创建进程，分配必要的资源，并将它们放入就绪队列。高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度。作业调度的频率很低，周期很长，大约几分钟一次。</p><h5 id="2-中级调度"><a href="#2-中级调度" class="headerlink" title="2.中级调度"></a>2.中级调度</h5><p>中级调度又称为内存调度，引入中级调度的主要目的是，提高内存利用率和系统吞吐量。中级调度的作用就是将暂时不能运行的进程，调至外存等待(挂起转台)，和将外村上已满足条件的就绪进程调入内存中。内存调度的频率和周期处于作业调度和进程调度之间。</p><h5 id="3-低级调度"><a href="#3-低级调度" class="headerlink" title="3.低级调度"></a>3.低级调度</h5><p>低级调度又称进程调度或者短程调度，它的调度对象是进程。其主要功能是，根据某种算法，决定就绪队列中的哪个进程获得处理机。并由分派程序将处理机分派给选择的进程。进程调度是一种最基本的调度，在多道批处理，实时和分时三种类型的OS中，都必须配置这级调度。进程调度的频率很高，周期很短，在分时系统中大概仅10-100ms。</p><ul><li>先来先服务(FCFS)</li><li>短作业优先(SJF)</li><li>时间片轮转调度算法(RR)</li><li>高响应比优先调度(HRRN)：响应比=周转时间/执行时间=1+等待时间/执行事件</li></ul><h4 id="read：参数只包含输入流"><a href="#read：参数只包含输入流" class="headerlink" title="read：参数只包含输入流"></a>read：参数只包含输入流</h4><h4 id="open：参数应包含文件的名称"><a href="#open：参数应包含文件的名称" class="headerlink" title="open：参数应包含文件的名称"></a>open：参数应包含文件的名称</h4><h3 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a>fork()函数</h3><ul><li><p>复刻(英语：fork，又译作派生，分支)是UNIX或类UNIX中的分叉函数，fork函数将运行着的程序分成两个(几乎)完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。这两个进程中的线程继续执行，就像是两个用户同时启动了该应用程序的两个副本。</p></li><li><p>fork系统调用用于创建一个新进程，称为子进程，它与进程(称为系统调用fork的进程)同时运行，此进程称为父进程。创建新的子进程后，两个进程执行fork()系统调用之后的下一条指令。子进程使用相同的pc(程序计数器)，相同的CPU寄存器，在父进程中使用的相同打开文件。</p></li><li><p>它不需要参数并返回一个整数值</p></li><li><script type="math/tex; mode=display">return=\begin{cases}positive &{返回父进程或调用者。该值包含新创建的子进程的进程ID}\\zero &{返回到新创建的子进程}\\nagetive &{创建子进程失败}\end{cases}</script></li></ul><p>exec系列函数</p><ul><li>用exec函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID。</li><li>系统调用exec系列函数后，fork函数创建的子进程才拥有自己独立的新代码段。</li><li>该系统调用替换进程的正文段，如果成功，没有返回值，如果失败，返回值为-1。</li></ul><h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>等待时间+程序执行事件，执行完成时间点-进入系统时间</p><h4 id="平均周转时间"><a href="#平均周转时间" class="headerlink" title="平均周转时间"></a>平均周转时间</h4><p>=总周转时间/进程个数</p><h4 id="平均带权周转时间-以执行时间为权值"><a href="#平均带权周转时间-以执行时间为权值" class="headerlink" title="平均带权周转时间(以执行时间为权值)"></a>平均带权周转时间(以执行时间为权值)</h4><p>=(Σ周转时间/执行时间)/进程个数</p><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><h4 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h4><ol><li>写者，读者互斥访问文件资源；</li><li>多个读者可以同时访问文件资源</li><li>只允许一个写者访问文件资源。</li></ol><h4 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h4><ol><li>写者线程的优先级高于读者线程；</li><li>当有写者到来时应该堵塞读者线程的队列；</li><li>当有一个写者正在写或在阻塞队列时应当阻塞读者进程的操作，直到所有写者进程完成写操作时开放读者进程；</li><li>当没有写者进程时读者进程能够同时读取文件。</li></ol><h4 id="公平竞争"><a href="#公平竞争" class="headerlink" title="公平竞争"></a>公平竞争</h4><ol><li>优先级相同；</li><li>写者，读者互斥访问；</li><li>只能有一个写者访问临界区；</li><li>可以有多个读者同时访问临界资源。</li></ol><h3 id="Points"><a href="#Points" class="headerlink" title="Points"></a>Points</h3><ul><li><p>可以被多个进程在任意时刻共享的代码必须是<strong>不能自身修改的代码</strong>。</p><p>若代码可以被多个进程在任意时刻共享，则要求一个进程在调用此段代码时都以同样的方式运行；而且进程在运行过程中被中断后再继续执行，其执行结果也不受影响。这必然要求代码不能自身更改，否则无法满足共享的要求。这样的代码就是可重入代码，也叫纯代码，即允许多个进程同时访问的代码。</p></li><li><p>共有n台互斥使用的同类设备，m个并发进程，分别需要x1,x2,…,xm个设备，为确保系统不发生死锁，n最小为x1+x2+…+xm-m+1；</p><p>分析：当每个进程都差最后一个设备时，即x1-1,x2-1,…,xm-1，这是申请不到最后一个设备，因此造成死锁，所以再添加一个设备即可；</p></li><li><p>中断指令：CPU正常运行期间，停止当前操作，执行其他特殊操作的行为就叫做中断，负责跳转的指令就是中断指令。<strong>中断指令不能在用户态执行，只能在内核态执行</strong>。</p></li><li><p>系统中进程执行时，I/O时间比决定了进程优先级，<strong>I/O时间比越大，进程优先级越高</strong>。</p></li><li><p>中断处理过程与子程序调用压栈时的区别：</p><p>都不需要保存通用数据寄存器和通用地址寄存器；</p><p>子程序调用时，由于系统硬件限制，只保存程序计数器的内容；</p><p><strong>中断处理一定会保存而子程序调用不需要保存的内容时程序状态字寄存器</strong>。</p></li><li><p><strong>CPU与I/O可同时进行</strong></p><p>Example：一个多道批处理系统中仅有P1和P2两个作业，P2比P1晚5 ms到达。它们的计算和 I/O操作顺序如下： P1：计算 60 ms，I/O 80 ms，计算 20 ms P2：计算 120 ms，I/O 40 ms，计算 40 ms</p><p><img src="https://pic.downk.cc/item/5fe975053ffa7d37b393014f.jpg" alt=""></p><p>若不考虑调度和切换时间，则完成两个作业需要的时间最少是260ms。</p></li><li><p>I/O操作：指对设备与CPU连接的接口电路的操作。</p></li><li><p>临界区：指的是一个访问公共资源(例如：共用设备或是共用寄存器)的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待，有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用，例如：信号量semaphore。只能被单一线程访问的设备，例如：打印机。</p><p><strong>临界区是一段程序；</strong></p><p><strong>在进程处于临界区时可以进行处理机调度；</strong></p><p><strong>在系统调用完成并返回用户态时能进行处理机调度。</strong></p></li><li><p>Example：假设系统中有4个进程和一个可分配资源，当前分配和最大需求如下表所示，已知资源总量为100。系统采用银行家算法避免死锁。</p><p>| 进程 | MAX  | ALLOCATION | NEED |<br>| —— | —— | ————— | —— |<br>| 1    | 50   | 20         | 30   |<br>| 2    | 50   | 15         | 35   |<br>| 3    | 50   | 30         | 20   |<br>| 4    | 50   | 10         | 40   |</p><p>在当前时刻若进程2请求资源数量为10，是否能实施分配？若能，给出安全序列。</p><p><strong><em>解：</em></strong>资源数量：100，减去已分配的资源75，还剩25；这是进程2请求资源10＜25，但是当分配后资源数量剩余15，不存在一个安全序列。</p><p>∴不能分配，因为分配后不存在安全序列。</p></li><li><p>当检测到死锁发生时，如果必须杀死一个进程以解除死锁，<strong>一般选择运行时间较短的进程</strong>，因为这样重新运行的代价较小，另外，程序需要可以<strong>多次运行不影响执行结果</strong>，还要<strong>考虑杀死优先级较低的进程</strong>等。</p></li><li><p>分时操作系统中的进程调度算法对普通进程常常采用的是优先级轮转法，<strong>采用动态调整进程优先级的方法</strong>，动态降低长时间占用CPU进程的优先级，低优先级进程的优先级则相对提高，最终得到运行。通过此方法，保证不会有进程因为优先级太低而饥饿。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabOfOS1</title>
      <link href="2020/12/22/LabOfOS1/"/>
      <url>2020/12/22/LabOfOS1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
            <tag> Code </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercise</title>
      <link href="2020/12/21/LabOfAlgorithm1/"/>
      <url>2020/12/21/LabOfAlgorithm1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="回溯法解决子集和数问题"><a href="#回溯法解决子集和数问题" class="headerlink" title="回溯法解决子集和数问题"></a>回溯法解决子集和数问题</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>回溯法可以理解成用深度优先算法遍历状态空间树，所以可以使用深度优先递归算法得到解；</p></li><li><p>定义MAXN为30，即暂时考虑最多有29个元素的集合；</p></li><li><p>在DFS函数中传入需要的参数：</p><p>TotalWeight：当前子集中所选的元素之和；</p><p>RestWeight：除选出的元素外剩余元素之和；</p><p>x[ ]：问题的一个解，由0和1组成，0代表xi不取，1代表取，1≤i≤n；</p><p>i：当前元素位置；</p><p>n，m，w[ ]：元素个数，和数，和所给集合；</p></li><li><p>在DFS函数中：</p><p>当TotalWeight与m相等时，输出一个解；</p><p>加上当前元素时还小于m，考虑下一位置元素，继续递归；</p><p>若加上剩余元素时大于m，则不选择当前位置元素，继续递归；</p></li><li><p>递归结束时，即可得到所有解。</p></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solution_DFS</span><span class="params">(<span class="keyword">int</span> TotalWeight, <span class="keyword">int</span> RestWeight, <span class="keyword">int</span> x[], <span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> w[])</span></span>;</span><br><span class="line"><span class="comment">//回溯法解决子集和数问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> RestWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            w[i] = temp;</span><br><span class="line">            RestWeight += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        Solution_DFS(<span class="number">0</span>, RestWeight, x, <span class="number">1</span>, n, m, w);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solution_DFS</span><span class="params">(<span class="keyword">int</span> TotalWeight, <span class="keyword">int</span> RestWeight, <span class="keyword">int</span> x[], <span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> w[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TotalWeight == m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; x[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TotalWeight + w[i] &lt;= m)</span><br><span class="line">        &#123;</span><br><span class="line">            x[i] = <span class="number">1</span>;</span><br><span class="line">            Solution_DFS(TotalWeight + w[i], RestWeight - w[i], x, i + <span class="number">1</span>, n, m, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (TotalWeight + RestWeight &gt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            x[i] = <span class="number">0</span>;</span><br><span class="line">            Solution_DFS(TotalWeight, RestWeight - w[i], x, i + <span class="number">1</span>, n, m, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>链接：<a href="https://people.sc.fsu.edu/~jburkardt/datasets/subset_sum/subset_sum.html">link</a></p><div class="table-container"><table><thead><tr><th>num\</th><th>N</th><th style="text-align:center">M</th></tr></thead><tbody><tr><td>1</td><td>8</td><td style="text-align:center">53</td></tr><tr><td>2</td><td>10</td><td style="text-align:center">5482</td></tr><tr><td>3</td><td>21</td><td style="text-align:center">2463098</td></tr><tr><td>4</td><td>10</td><td style="text-align:center">50</td></tr><tr><td>5</td><td>9</td><td style="text-align:center">100</td></tr><tr><td>6</td><td>6</td><td style="text-align:center">22</td></tr><tr><td>7</td><td>10</td><td style="text-align:center">50</td></tr></tbody></table></div><h2 id="动态规划解决矩阵乘法链问题"><a href="#动态规划解决矩阵乘法链问题" class="headerlink" title="动态规划解决矩阵乘法链问题"></a>动态规划解决矩阵乘法链问题</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>使用动态规划方法解决矩阵乘法链问题，需在不同大小的子问题的优化值之间建立递归关系，得到最优解；</li><li>同时满足优化原理，即优化解包含的子问题的解也是优化解。使用枚举法建立不同长度子问题的优化值之间的递归关系；</li><li>求此问题的优化解，即求c(1,n)，c(1,n)=min{c(1,k)+c(k+1,n)+r1×r(k+1)×rn}，利用此式得到问题的解，再根据每次得到的k值回溯找到优化的乘法顺序；</li><li>在代码中，可以使用二维数组存放每次递归关系式中大括号中的每个值，最后找到最小值，即可得到问题的优化解。</li></ul><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//动态规划解决矩阵乘法链问题</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INT_MAX=<span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> Length,<span class="keyword">int</span> m[][MAXN],<span class="keyword">int</span> s[][MAXN])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">POMCWP</span><span class="params">(<span class="keyword">int</span> s[][MAXN],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;<span class="comment">//Acronyms Print Optimal Matrix Chain With Parentheses</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">int</span> r[MAXN]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">int</span> temp;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">   r[i]=temp;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> m[MAXN][MAXN],s[MAXN][MAXN];</span><br><span class="line">   Solution(r,n+<span class="number">1</span>,m,s);</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Minimum: &quot;</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;m[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Order: &quot;</span>;</span><br><span class="line">   POMCWP(s,<span class="number">1</span>,n);</span><br><span class="line">   &#125;</span><br><span class="line">   system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> Length,<span class="keyword">int</span> m[][MAXN],<span class="keyword">int</span> s[][MAXN])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> q,n=Length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) m[i][i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=n;l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-l+<span class="number">1</span>;i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j=i+l<span class="number">-1</span>;</span><br><span class="line">m[i][j]=INT_MAX;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line">q=m[i][k]+m[k+<span class="number">1</span>][j]+r[i<span class="number">-1</span>]*r[k]*r[j];</span><br><span class="line"><span class="keyword">if</span>(q&lt;m[i][j])</span><br><span class="line">&#123;</span><br><span class="line">m[i][j]=q;</span><br><span class="line">s[i][j]=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">POMCWP</span><span class="params">(<span class="keyword">int</span> s[][MAXN],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i == j) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;M&quot;</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">POMCWP(s,i,s[i][j]);</span><br><span class="line">POMCWP(s,s[i][j]+<span class="number">1</span>,j);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><p>Q：p[MAXN]={30,35,15,5,10,20,25}；</p><p>A：程序输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Minimum: <span class="number">15125</span></span><br><span class="line">Order: ((M1(M2M3))((M4M5)M6))</span><br></pre></td></tr></table></figure><p>Q：p[MAXN]={10,20,50,1,100};</p><p>A：程序输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Minimum: <span class="number">2200</span></span><br><span class="line">Order: ((M1(M2M3))M4)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Lab </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Branch and Bound</title>
      <link href="2020/12/17/AlgorithmChapter8/"/>
      <url>2020/12/17/AlgorithmChapter8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="分枝-限界法"><a href="#分枝-限界法" class="headerlink" title="分枝-限界法"></a>分枝-限界法</h2><h3 id="分枝-Branching"><a href="#分枝-Branching" class="headerlink" title="分枝(Branching)"></a>分枝(Branching)</h3><ul><li><p>分枝：一个节点成为E-节点后，它要展开它的所有子节点；并将这些子节点放在一个称为活节点表的数据结构中；在活节点表中的节点可以展开所有状态空间树的节点，即广度优先遍历状态空间树；</p></li><li><p>按一定的规则从活节点表中取出一个节点作为E-节点进行展开；</p></li><li><p>活节点表可以是FIFO,LIFO和优先级队列；</p></li><li><p>当使用优先级队列时必须对活节点表中的节点赋以一个权值；</p></li><li><h3 id="下文将结合求解优化为题介绍一种使用优先级队列的分枝-限界法。"><a href="#下文将结合求解优化为题介绍一种使用优先级队列的分枝-限界法。" class="headerlink" title="下文将结合求解优化为题介绍一种使用优先级队列的分枝-限界法。"></a>下文将结合求解优化为题介绍一种使用优先级队列的分枝-限界法。</h3></li></ul><h3 id="最小成本优化问题"><a href="#最小成本优化问题" class="headerlink" title="最小成本优化问题"></a>最小成本优化问题</h3><ul><li>设x=(x1,x2,…,xn)为可行解的元组；</li><li>对每一个可行解有一个成本值，cost(x)；</li><li>求使cost(x)达到最小的可行解x；</li><li>使用搜索算法求解最小成本优化问题。</li></ul><h3 id="任意节点的成本函数c-x"><a href="#任意节点的成本函数c-x" class="headerlink" title="任意节点的成本函数c(x)"></a>任意节点的成本函数c(x)</h3><ul><li>定义状态空间树上任一节点x的成本函数c(x)如下；</li><li>如x为可行叶节点，则c(x)=cost(x)；</li><li>否则，定义c(x)=从x展开状态空间树能得到的最小成本值(状态空间树上以x为根的子树中可行解成本的最小值)；</li><li>如其子树中无可行解，则c(x)=∞。</li></ul><h3 id="LC-检索"><a href="#LC-检索" class="headerlink" title="LC-检索"></a>LC-检索</h3><ul><li>如果活节点表中每个节点以c(x)为权值，每次从活节点表中取出最小权值节点作为E-节点，则算法能很快找到优化解；</li><li>但在展开x前不可能知道c(x)的值。但是有可能从历史信息获得c(x)的某一下界c^(x)；</li><li>以c(x)的下界估值c^(x)作为活节点表中节点的权值，每次取出有最小c^(x)的节点进行展开；</li><li>要求设计的c^(x)满足：c^(x)=cost(x)，当x为可行叶节点时。</li></ul><h3 id="限界"><a href="#限界" class="headerlink" title="限界"></a>限界</h3><ul><li>令U为当前获得的最优成本值；</li><li>设x=(x1,x2,…,xn)，如果c^(x)&gt;=U，则停止展开子节点x，即，不将其放入活节点表；</li><li>U初始值为∞，其后每一次的到一个新的可行解，用其成本值对U加以修改：U⬅min{U,cost(x)}。</li></ul><h3 id="Example：带截止期的作业调度问题"><a href="#Example：带截止期的作业调度问题" class="headerlink" title="Example：带截止期的作业调度问题"></a>Example：带截止期的作业调度问题</h3><ul><li>n个作业，1台处理机，每个作业i对应一个三元组(pi,di,ti)；</li><li>pi：罚款额；</li><li>di：截止期；</li><li>ti：需要的处理机时间；</li><li>求可行的作业子集J，使得罚款额最小，其中j为不在J中的作业；</li><li>定长元组表示可行作业子集：(x1,x2,…,xn)；</li><li>设X=(x1,x2,…,xk)为状态空间树的节点；</li><li>下界c^(x)可估计为展开到x时已得到的罚款额：Σ(1-xj)pj，求和范围为1&lt;=j&lt;=k。</li></ul><p>例题</p><p><img src="https://pic.downk.cc/item/5fdb0fa73ffa7d37b36c26f3.jpg" alt="带截止期的作业调度问题实例"></p><p>LC-分枝-限界产生的部分状态空间树</p><p><img src="https://pic.downk.cc/item/5fdb36763ffa7d37b3904154.jpg" alt=""></p><p>调度问题的另一种状态空间树</p><p><img src="https://pic.downk.cc/item/5fdb36e83ffa7d37b390e2e6.jpg" alt=""></p><ul><li>可行条件(截止期)作为一种限界方法；</li><li>c^(x)&gt;=U为另一限界方法；</li><li>下图中每个节点标注了2个数，上边的数为c^(x)，下边的数为该节点对应的可行解的罚款额，作为u(x)；</li><li>方框节点是非可行节点；</li><li>打叉的节点是被限界掉的节点。</li></ul><p><img src="https://pic.downk.cc/item/5fdb39183ffa7d37b39285fe.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Traceback</title>
      <link href="2020/12/15/AlgorithmChapter7/"/>
      <url>2020/12/15/AlgorithmChapter7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="Example：8-皇后问题"><a href="#Example：8-皇后问题" class="headerlink" title="Example：8-皇后问题"></a>Example：8-皇后问题</h3><p><img src="https://pic.downk.cc/item/5fd890593ffa7d37b3f7e777.jpg" alt="图16.1"></p><ul><li><p>8皇后问题的解可以表示为一个8-元组(x1,x2,…,x8)，其中xi是放在第i行的皇后所在的列号，则8皇后问题可形式化为pow(8,8)个8-元组中找满足以下约束条件的元组：</p><p>对于任意的i≠j，有xi≠xj；|xi-xj|≠|i-j|；</p></li><li><p>这pow(8,8)个8-元组构成的集合成为8皇后问题的解空间-搜索范围；</p></li><li><p>如果将约束条件之一，任意两个皇后不在同一列，加入到元组的定义中，这是每个8-元组为(1,2,3,4,5,6,7,8)的一个排列，解空间的大小由pow(8,8)个元组减少到8！个元组；</p></li><li><p>解空间不是唯一的，取决于算法的设计；</p></li><li><p>设计解空间时还要考虑生成解空间的算法复杂度；在8皇后问题中，如果加入第二个条件，解空间很难形成。</p></li></ul><h3 id="搜索问题的形式化-解空间"><a href="#搜索问题的形式化-解空间" class="headerlink" title="搜索问题的形式化-解空间"></a>搜索问题的形式化-解空间</h3><ul><li><p>假定问题的解能用n-元组(x1,x2,…,xn)表示，其中xi取自某个有穷集Si；</p></li><li><p>这些n-元组构成的集合成为问题的解空间；假设|Si|=mi，则解空间的大小为m=m1<em>m2</em>…*mn；</p></li><li><p>我们考虑两类问题：</p><p>存在性问题：求满足某些条件的一个或全部元组，如果存在返回Yes，否则返回No。这些条件称为约束条件；</p><p>优化问题：给定一组约束条件，在满足约束条件的元组中求使某目标函数达到最大(小)值的元组。满足约束条件的元组成为问题的可行解。</p></li><li><p>解决这类问题的最一般方法使使用搜索技术，即系统化地搜索解空间地技术。</p></li></ul><h3 id="Example：子集和数问题"><a href="#Example：子集和数问题" class="headerlink" title="Example：子集和数问题"></a>Example：子集和数问题</h3><ul><li><p>已知n+1个整数：wi，1&lt;=i&lt;=n，和M。要求找出{wi|1&lt;=i&lt;=n}的所有子集，使得子集内元素之和等于M；</p></li><li><p>例如：n=4，(w1,w2,w3,w4)=(11,13,24,7)，M=31。则满足要求的子集是(11,13,7)和(24,7)；</p></li><li><p>我们可以用wi的下标i构成的元组表示一个解，则这两个解可表示为(1,2,4)和(3,4)；</p></li><li><p>元组(1,2,4)和(2,1,4)代表同一子集，此为限制元组分量按升序排列，即不考虑元组(2,1,4)；</p></li><li><p>还可用其他方式表示一个解，如下：</p><p><img src="https://pic.downk.cc/item/5fd8ab823ffa7d37b314da45.jpg" alt=""></p></li></ul><h3 id="解空间的状态空间树"><a href="#解空间的状态空间树" class="headerlink" title="解空间的状态空间树"></a>解空间的状态空间树</h3><ul><li>任何搜索算法都可以用建立在解空间上的状态空间树加以描述；</li><li>状态空间树是我们尝试选择元组的各个分量时产生的树结构；</li><li>搜索算法并非事先将状态空间树存在计算机内再进行遍历，而是通过展开状态空间树来找所求的解；</li><li>展开过程中通过使用启发式的限界方法(剪去状态空间树上的某些分支)使搜算算法只展开状态空间树的一部分，从而降低搜索算法的时间和空间复杂度。</li></ul><h3 id="Example：n-皇后问题"><a href="#Example：n-皇后问题" class="headerlink" title="Example：n-皇后问题"></a>Example：n-皇后问题</h3><ul><li>n-皇后问题是8-皇后问题的推广。n个皇后将被放置在n×n的棋盘上且使得没有两个皇后可以互相攻击，其解空间由n-元组(1,2,…,n)的n！个排列组成；</li><li>其状态空间树如下图所示(n=4)。树的边由xi的可能的取值标记。由i级到i+1级节点的边给出xi的值，这种树成为排列树；</li><li>从根节点到叶节点的一条路径对应解空间的一个元组。</li></ul><p><img src="https://pic.downk.cc/item/5fdacc9e3ffa7d37b32382da.jpg" alt="4-皇后问题的状态空间树"></p><p><img src="https://pic.downk.cc/item/5fdb00253ffa7d37b35a0816.jpg" alt="子集和数问题的状态空间树"></p><p><img src="https://pic.downk.cc/item/5fdb005e3ffa7d37b35a4553.jpg" alt="子集和数问题的状态空间树"></p><h3 id="有关状态空间树的术语"><a href="#有关状态空间树的术语" class="headerlink" title="有关状态空间树的术语"></a>有关状态空间树的术语</h3><ul><li>状态空间树的每个节点代表问题求解过程中达到的一个状态，根节点到它的路径代表对一些分量已作出的选择。状态空间树的所有节点构成的集合成为求解该问题的状态空间；</li><li>根节点到状态空间树的一个节点X的路径可以表示为(x1,x2,…,xk)，其中xi，1&lt;=i&lt;=k，为搜索过程中已经选择的分量。今后我们也用这个元组标识该节点：X=(x1,x2,…,xk)；</li><li>(x1,x2,…,xk)也对应一个子问题，即在后n-k个元组分量所对应的子空间上找满足要求的解。该子空间是状态空间树中以X为根的子树。所以也称节点X为问题节点；</li><li>如果从根节点到节点S的那条路径确定了解空间的一个元组，则称S为状态空间树的一个解节点；</li><li>如果一个解节点S(代表的元组)满足所有约束条件，则称其为答案节点。</li></ul><h3 id="状态空间树的展开方法"><a href="#状态空间树的展开方法" class="headerlink" title="状态空间树的展开方法"></a>状态空间树的展开方法</h3><ul><li>每个搜索算法都是一种系统地展开状态空间树地算法；</li><li>活节点：已展开了部分节点，但所有子节点尚未全部展开的节点；</li><li>死节点：被限界或已展开了所有子节点地节点；</li><li>E-节点：当前正在展开子节点的活节点。</li><li>深度优先展开方法：一个E-节点展开自己的一个子节点后，就让该子节点成为E-节点的展开方法(相当于对状态空间树做深度优先搜索)。</li><li>回溯法：加限界的深度优先展开状态空间树的方法；</li><li>分枝-限界法：一个节点一旦成为E-节点，它将展开其全部子节点，之后自己变成死节点；</li><li>在分枝-限界法中要维持一个活节点表的结构，存放已展开但还未成为E-节点的那些节点。</li></ul><h3 id="限界"><a href="#限界" class="headerlink" title="限界"></a>限界</h3><p><img src="https://pic.downk.cc/item/5fdb04783ffa7d37b35f0369.jpg" alt="限界"></p><h3 id="用回溯法解4-皇后问题"><a href="#用回溯法解4-皇后问题" class="headerlink" title="用回溯法解4-皇后问题"></a>用回溯法解4-皇后问题</h3><p><img src="https://pic.downk.cc/item/5fdb04a83ffa7d37b35f346c.jpg" alt="用回溯法解4-皇后问题"></p><h3 id="回溯的一般方法"><a href="#回溯的一般方法" class="headerlink" title="回溯的一般方法"></a>回溯的一般方法</h3><ul><li>每个解用数组X(1,n)来表示；</li><li>假定X1，X2,…,X(k-1)的值已确定，T(X1,X2,…,X(k-1))代表xk的所有可能的取值；</li><li>限界函数B(X1,X2,…,XK)判断那些Xk的取值不能导致问题的解，从而停止展开该子节点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="2020/12/15/AlgorithmChapter6/"/>
      <url>2020/12/15/AlgorithmChapter6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>0/1背包问题</li><li>矩阵乘法链</li><li>最短路径</li><li>最长公共子序列</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>从算法设计的角度看，动态规划是一种在各个不同大小(size)的子问题的优化值之间建立递归关系并求解的过程；</li><li>能用动态规划求解的问题必须满足优化原理：优化解包含的子问题的解也是优化的；</li><li>利用优化原理，使用枚举法建立不同长度子问题的优化值之间的递归关系——动态规划方程；</li><li>动态规划得到的是精确解；</li><li>子问题的数目决定算法的复杂性；</li><li>实现时要尽可能消去递归。</li></ul><h3 id="Example：多段图-最短路径"><a href="#Example：多段图-最短路径" class="headerlink" title="Example：多段图-最短路径"></a>Example：多段图-最短路径</h3><p><img src="https://pic.downk.cc/item/5fdc3a713ffa7d37b33fb1e7.jpg" alt="多段图"></p><ul><li>多段图问题满足优化原理：最短路(1-&gt;3-&gt;5-&gt;7)上的子路径(3-&gt;5-&gt;7)是3到目的节点7在子图上的最短路；</li><li>无论最短路的下一跳是{2，3，4}中的那个节点，其后的路径也应是最短路；</li><li>节点1到目的的节点的最短路长度c(1)可从2，3，4到目的节点的最短路c(i)+节点1到这些节点的边成本cost(1,i)经枚举得到：c(1)=min{c(i)+cost(1,i)}，i∈{2，3，4}。</li><li>但2，3，4到目的节点的最短长度c(2),c(3),c(4)还不知道；</li><li>我们需计算c(2),c(3),c(4)；仍使用优化原理；</li><li>一般情形：设c(i)为i到目的节点的最短路长度，A(i)为与i相邻的节点集合，有：c(i)=min{c(j)+cost(i,j)}，j∈A(i)；</li><li>但c(i)由i到目的节点的子图在决定，和节点1怎样走到i没关系。</li></ul><p>多段图的动态规划算法</p><ul><li>从c(7)开始向前计算；</li><li>初始c(7)=0；</li><li>依次计算c(6),c(5),…,c(1)；</li><li>c(6)=1，c(5)=2；</li><li>c(4)=8+c(6)；</li><li>c(3)=min{1+c(5),5+c(6)}；</li><li>c(2)=min{7+c(5),6+c(6)}；</li><li>c(1)=min{1+c(2),4+c(3),6+c(4)}；</li><li>递归还可以从前向后。</li></ul><p>Example：0/1背包问题</p><ul><li>0/1背包问题的解指物品1,2,…,n的一种放法(x1,x2,…,xn的0/1赋值)，使得效益值最大；</li><li>假定背包容量不足以装入所有物品：面临选择；</li><li>因为目标函数是非负数之和；</li><li>优化原理：无论优化解是否放物品1，相对剩余背包容量，优化解对物品2,3,…,n的放法也是优化解。</li></ul><p><img src="https://pic.downk.cc/item/5fdc471b3ffa7d37b34bcc23.jpg" alt="背包问题满足的优化原理"></p><h3 id="优化值间的递归式"><a href="#优化值间的递归式" class="headerlink" title="优化值间的递归式"></a>优化值间的递归式</h3><ul><li>虽然我们不知道优化解是否放物品1，但我们可以利用优化原理，从枚举”放”和”不放”两种情形建立优化值之间的递归式：</li><li>设f(i,y)为以背包容量y，放物品i,i+1,…,n，得到优化效益值，一下递归关系成立：</li><li>f(1,c)=max{f(2,c),f(2,c-w1)+p1}(不放1和放1)；</li><li>先求子问题的优化值(递归)，再从2种可能性中选出最优的；</li><li>需求解：任意给定容量y，任意i,i+1,…,n种物品的子问题。</li></ul><h3 id="动态规划法步骤"><a href="#动态规划法步骤" class="headerlink" title="动态规划法步骤"></a>动态规划法步骤</h3><ul><li>在应用动态规划法时，须先验证欲求解的问题是否满足优化原理；</li><li>应用优化原理建立子问题优化解的值(优化值)之间的递归式；</li><li>解优化值满足的递归式；</li><li>回溯从优化值构造优化解；</li></ul><h3 id="算法复杂性"><a href="#算法复杂性" class="headerlink" title="算法复杂性"></a>算法复杂性</h3><ul><li>直接用递归实现动态规划递归方程往往会引发大量重复计算，算法的计算量变得非常可观；最好使用迭代法实现动态规划算法；</li><li>迭代实现需要存贮所有子问题的优化解的值f(i,y)，以便避免重复计算，所以算法往往需要较大的存储空间；</li><li>算法的复杂性来自子问题的数目，通常子问题的数目很大。</li></ul><h3 id="0-1背包问题DP算法的实现"><a href="#0-1背包问题DP算法的实现" class="headerlink" title="0/1背包问题DP算法的实现"></a>0/1背包问题DP算法的实现</h3><h4 id="1-递归实现"><a href="#1-递归实现" class="headerlink" title="1.递归实现"></a>1.递归实现</h4><script type="math/tex; mode=display">f(n,y)=\begin{cases}Pn & y≥wn\\0 & 0≤y<wn\end{cases}</script><script type="math/tex; mode=display">f(i,y)=\begin{cases}max(f(i+1,y),f(i+1,y-wi)+pi) & y≥wi\\f(i+1,y) & 0≤y<wi\end{cases}</script><p>​                                 <strong>说明：f(i,y)中，y≥wi的情况中，前者为不放i，后者为放i</strong></p><p>Example：</p><p><img src="https://pic.downk.cc/item/5fdc7b213ffa7d37b3838480.jpg" alt=""></p><p><img src="https://pic.downk.cc/item/5fdc7adf3ffa7d37b3832a3f.jpg" alt="递归调用树"></p><h4 id="2-权为整数的迭代实现"><a href="#2-权为整数的迭代实现" class="headerlink" title="2.权为整数的迭代实现"></a>2.权为整数的迭代实现</h4><ul><li>当物品重量为整数时，可设计一相当简单的算法来求解f(1,c)；</li><li>该实现用二维数组 f [i] [y] 来保存每个f(i,y)的值，并且只计算一次；</li><li>二维数组需Θ(nc)空间；</li><li>函数Traceback从 f [i] [y] 产生优化的xi值；</li><li>Knapsack的复杂性Θ(nc)，似乎是多项式算法。但因c的二进制输入长度为logc(2为底)，所以nc仍是输入长度的指数函数；</li><li>Traceback的复杂性为Θ(n)。</li></ul><p>Example：n=5，p=[6,3,5,4,6]，w=[2,2,6,5,4]，且c=10，求f(1,10)</p><div class="table-container"><table><thead><tr><th>i\y</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>缺点：</p><ol><li>要求物品重量为整数；</li><li>当背包容量c很大时，例如c&gt;2^n，需要Ω(n*2^n)。</li><li>下述元组法克服了上述缺点。</li></ol><h4 id="3-元组法实现"><a href="#3-元组法实现" class="headerlink" title="3.元组法实现"></a>3.元组法实现</h4><ul><li><p>元组法将函数f(i,y)的跳跃点以元组(y,f(i,y))形式存储于一个线性表P(i)中；</p></li><li><p>表P(i)中的元组(y,f(i,y))按y的增序排列；</p></li><li><p>P(i)中的元组(a,b)表示：存在一种装物品{i,i+1,…,n}的方案，能以容量y，a≤y＜a‘，a’为下一元组的横坐标，得到效益值b；</p></li><li><p>下面给出从f(i+1,y)的线性表P(i+1)得出f(i,y)的线性表P(i)的算法；</p></li><li><p>按f(i,y)的定义：f(i,y)=max{f(i+1,y),f(i+1,y-wi)+pi}，首先需要从P(i+1)得到函数f(i+1,y)=f(i+1,y-wi)+pi的元组集合Q；</p></li><li><p>设(a,b)∈Q，则(a-wi,b-pi)必为P(i+1)的元组，反之亦然。所以，P(i+1)的每个元组(w,p)对应Q的一个元组(w+wi,p+pi)；</p></li><li><p>Q的元组(u,v)代表装物品{i,i+1,…,y}的元组(即P(i)的元组)；</p></li><li><p>从P(i+1)和Q得到P(i)的元组：</p><p>因P(i+1)和Q内元组均按w和p的增序排列，所以可以用以前学过的merge算法进行合并；</p></li><li><p>合并时使用以下支配(选优)规则：</p><p>设(a,b)和(u,v)是来自P(i+1)和Q的元组，若a≥u且b＜v，则称(a,b)受(u,v)支配；</p><p>因为(a,b)代表以容量a得到效益值b的方案；</p><p>而(u,v)代表以较少的容量u得到较大效益值v的方案；</p></li><li><p>在合并时舍弃被支配的元组(选优)。</p></li><li><p>P(i+1)于Q合并，并按支配规则舍弃被支配的元组即可得到P(i)；</p></li><li><p>在产生P(i)时丢弃w&gt;c的元组(w,v)；</p></li><li><p>得到P(2)后不再产生P(1)：</p><p>P(2)的最后一个元组是f(2,c)对应的元组；</p><p>设线性表P(2)中满足w+w1≤c的最后一个元组为(w,v)；</p><p>将v+p1于P(2)的最后一个元组对应的效益值p做比较，效益值大的即为优化效益值f(1,c)。</p></li></ul><p><strong>Example：n=5，p=[6,3,5,4,6]，w=[2,2,6,5,4]，且c=10，求f(1,10)</strong></p><p><strong>方便起见，w=[2,2,6,5,4]，p=[6,3,5,4,6]，(横坐标为W，纵坐标为P)</strong></p><ol><li><p><strong>P(5)={(0,0),(4,6)}, Q={(5,4),(9,10)};</strong></p></li><li><p><strong>P(4)={(0,0),(4,6),(9,10)}, delete(5,4), Q={(6,5),(10,11)};</strong></p></li><li><p><strong>P(3)={(0,0),(4,6),(9,10),(10,11)}, delete(6,5), Q={(2,3),(8,8),(7,7),(6,9)};</strong></p></li><li><p><strong>P(2)={(0,0),(2,3),(4,6),(6,9),(9,10),(10,11)};</strong></p></li><li><p><strong>(w1,p1)=(2,6)，P2中满足w+w1≤c的最后一个元组为(6,9)；</strong></p><p><strong>∵ (2,6)+(6,9)&gt;(10,11)</strong></p><p><strong>∴15为最大效益值，通过回溯法找到解为[1,1,0,0,1]</strong></p></li></ol><h3 id="矩阵乘法链"><a href="#矩阵乘法链" class="headerlink" title="矩阵乘法链"></a>矩阵乘法链</h3><ul><li>m×n矩阵A于n×p矩阵B相乘需要做mnp个元素乘法；</li><li>计算三个矩阵A，B和C的乘积ABC有两种方法：(AB)C和A(BC)；</li><li>结果相同，但所需元素乘法数不同；</li><li>问题：对任意给定长度q的矩阵乘法链M1×M2,…,Mq，求优化的乘法顺序使得计算该乘法链所用的乘法数最少；</li><li>长度为q的矩阵乘法链有指数量级Ω(2^q)的可能乘法顺序(有q个叶节点的二叉树的数目)；</li></ul><p><strong>动态规划解</strong></p><ul><li><p>用M(i,j)表示Mi×Mi+1×…×Mj(i≤j)的乘积。假设优化的矩阵乘法顺序最后计算乘积M(i,k)×M(k+1,j)；</p></li><li><p>则计算M(i,j)的优化乘法顺序在计算子链M(i,k)和M(k+1,j)时也是优化的；</p></li><li><p>设c(i,j)为计算M(i,j)的优化乘法数(优化值)，根据优化原理，优化值之间满足：</p><p>c(i,j)=min{c(i,k)+c(k+1,j)+ri<em>r(k+1)</em>r(j+1)}，i≤k&lt;j；</p><p>令kay(i,j)为达到最小值的k；</p></li><li><p>可用上述递归式计算c(1,q)；</p></li><li><p>用kay(i,j)回溯找到优化的乘法顺序。</p></li></ul><p><strong>Example：q=5，r=(10,5,1,10,2,10)</strong></p><p><strong>递归</strong></p><ol><li><strong>c(1,5)=min{c(1,1)+c(2,5)+500, c(1,2)+c(3,5)+100, c(1,3)+c(4,5)+1000, c(1,4)+c(5,5)+200};</strong></li><li><strong>c(2,5)=min{c(2,2)+c(3,5)+50, c(2,3)+c(4,5)+500, c(2,4)+c(5,5)+100};</strong></li><li><strong>c(3,5)=min{c(3,3)+c(4,5)+100,c(3,4)+c(5,5)+20};</strong></li><li><strong>c(4,5)=min{c(4,4)+c(5,5)+200}=200;</strong></li><li><strong>c(3,5)=c(3,4)+c(5,5)+20=20+0+20=40;</strong></li><li><strong>c(2,5)=c(2,2)+c(3,5)+50=0+40+50=90;</strong></li><li><strong>c(1,5)=c(1,2)+c(3,5)+100=50+40+100=190;</strong></li><li><strong>解为M(1,2)×M(3,4)×M(5,5);</strong></li></ol><p><strong>迭代</strong>：可避免大量重复计算，但需要O(q²)的存储空间，时间复杂度为Θ(q³)。</p><p>s=2，3，4；</p><p>s=2，计算c(1,3),c(2,4),c(3,5);</p><p>s=3，计算c(1,4),c(2,5);</p><p>s=4，计算c(1,5).</p><h3 id="All-Pair最短路问题"><a href="#All-Pair最短路问题" class="headerlink" title="All-Pair最短路问题"></a>All-Pair最短路问题</h3><ul><li>最短路径：设G为有向图，其中每条边都有一个成本(cost)，图中每条有向路径的长度(或成本)定义为该路径上各边的成本之和；</li><li>对于没对顶点(i,j)，定义从i到j的所有路径中，具有最小长度的路径为从i到j的最短路；</li><li>All-Pair最短路问题：求每对点间的最短路；</li><li>假定图上无负成本的环路，这是只需考虑简单路径，加上环路只会增加路径成本。</li></ul><p>动态规划解：</p><ul><li><p>将节点按1到n编号；</p></li><li><p>定义c(i,j,k)=i到j的中间节点编号不超过k的最短路长度，即包含节点i和j即节点1,2,…,k的子图上的最短路；</p></li><li><p>c(i,j,n)是在原来的图上i到j的最短路长度，即我们要求的最短路长度；</p></li><li><p>因为只考虑简单路径，所以：</p><p>c(i,k,k)=c(i,k,k-1);</p><p>c(k,j,k)=c(k,j,k-1);</p><p>c(i,i,k)=0 for all k;</p></li><li><p>特别地，c(i,j,0)=cost(i,j)或∞。</p></li></ul><p>Example：</p><p><img src="https://pic.downk.cc/item/5fddacd83ffa7d37b36cb9aa.jpg" alt=""></p><ul><li><p>建立c(i,j,k)和c(i,j,k-1)之间的递归关系；</p></li><li><p>对于任意k＞0，i到j的中间节点编号不超过k的最短路上，或包含节点k或不包含节点k，所以有递归如下：</p><p>c(i,j,k)=min{c(i,j,k-1),c(i,k,k-1)+c(k,j,k-1)}；</p></li><li><p>如果直接用递归程序求解上式，则计算c(i,j,n)的复杂度极高。利用迭代方法可将计算c值得时间减少到O(n)³。</p></li></ul><p>迭代算法伪代码：</p><ul><li>n令C(k)代表矩阵(c(i,j,k))i,j=1,…,n,因c(i,i,k)=0 for all k,所以矩阵C(k)的对角线元素为0.</li><li>n算法迭代计算C(k) ,k=0,…,n</li><li>n初始C(0)=(c(i, j)),即图的邻接矩阵,无边相连的i和j 令c(i, j)=∞.</li><li>n因c(i,k,k)=c(i,k,k-1),c(k,j,k)=c(k,j,k-1),所以,矩阵C(k)的k行、k列上的元素不变:</li><li><p>C(k)(i,k)=C(k-1)(i,k), C(k)(k,j)=C(k-1)(k,j).</p></li><li><p>n矩阵C(k)非k行、k列上的元素,按下式计算</p></li><li><strong>C(k)(i,j)←min{C(k-1)(i, j), C(k-1)(i, k)+</strong></li><li>​                    <strong>C(k-1)(k,j)},</strong></li><li>即C(k)(i,j)←min{C(k-1)(i, j), C(k)(i, k)+</li><li>​                    C(k)(k,j)},</li><li>n所以算法只需使用一个矩阵,每次迭代时, 用第k列的i行元素和第k行的j列元素之和去更新元素C(k-1)(i, j).</li><li>n算法迭代至多n次，每次迭代需O(n2)时间，所以算法的时间复杂度为O(n3).</li></ul><p>Example：最短路径</p><p><img src="https://pic.downk.cc/item/5fddae053ffa7d37b36dbf9a.jpg" alt="最短路径实例"></p><p>解：</p><p><img src="https://pic.downk.cc/item/5fddae2d3ffa7d37b36de486.jpg" alt=""></p><p>C(3)(1,2)=min{C(2)(1,2), C(2)(1,3)+C(2)(3,2)}=min{4, 6+7}=min{4, 13}=4; </p><p>C(3)(2,1)=min{C(2)(2,1), C(2)(2,3)+C(2)(3,1)}=min{6, 2+3}=min{6, 5}=5. </p><h3 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h3><ul><li><p>首先需要说明，子序列与字串不同</p><p>一个给定的序列的子序列，就是将给定序列中零个或多个元素去掉之后的结果；</p><p>字串指给定串中任意个连续的字符组成的子序列；</p></li><li><p>可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中，可以避免大量的重复计算；</p></li><li><p>递归方程如下：</p></li><li><script type="math/tex; mode=display">C(i,j)=\begin{cases}0,&if&i=0orj=0\\C[i-1，j-1],&if&i,j>0andx_i=y_i\\max\{C[i,j-1],c[i-1,j]\}&if&i,j>0andx_i≠y_i\end{cases}</script></li></ul><p>Example：s1=[1,3,4,5,6,7,7,8]，s2=[3,5,7,4,8,6,7,8,2]</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">下标j</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center"><strong>下标i</strong></td><td style="text-align:center"></td><td style="text-align:center">s2</td><td style="text-align:center">3</td><td style="text-align:center">5</td><td style="text-align:center">7</td><td style="text-align:center">4</td><td style="text-align:center">8</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">s1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">8</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">5</td></tr></tbody></table></div><p>右下角元素即为最长公共子序列长度，得到问题的解。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Divide and Conquer</title>
      <link href="2020/12/15/AlgorithmChapter5/"/>
      <url>2020/12/15/AlgorithmChapter5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><h3 id="分治法思想"><a href="#分治法思想" class="headerlink" title="分治法思想"></a>分治法思想</h3><ul><li><p>分治法设计算法的思想是：</p><p>将问题分成(divide)多个子问题；</p><p>递归地解决(conquer)每个子问题；</p><p>将子问题的解合并(combine)成原问题的解。</p></li><li><p>分治法常常得到递归算法；</p></li><li><p>Merge-Sort是用分治法设计算法的范例</p></li><li><p>算法复杂性分析</p><p>Master method</p><p>Substitution method</p></li></ul><h3 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h3><ul><li><p>分治法所能解决的问题一般具有以下几个特征：</p><p>该问题的规模缩小到一定程度就可以容易地解决；</p><p>该问题可以分解为若干个规模较小的子问题；</p><p>利用该问题分解出的子问题的解可以合并为该问题的解；</p><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p></li><li><p>最后一条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用动态规划较好。</p></li></ul><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">divide-<span class="keyword">and</span>-conquer(P)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(P&lt;=n0) adhoc(P); <span class="comment">//解决小规模的问题</span></span><br><span class="line">    divide P into smaller subinstances P1,P2,...,Pk; <span class="comment">//分解问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        yi=divide-<span class="keyword">and</span>-conquer(Pi); <span class="comment">//递归地解决各子问题</span></span><br><span class="line">        <span class="keyword">return</span> merge(y1,...,yk); <span class="comment">//将各子问题地解合并成为原问题的解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人们从大量实践中发现，在用分治法设计算法时，最好使子问题的规模大致相同。即将一个字问题分成大小相等的k个子问题的处理方法是行之有效的。这种使子问题规模大致相等的做法好是出自一种平衡子问题的思想，它几乎总是比子问题规模不等的做法要好。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="1-Defective-Chessboard"><a href="#1-Defective-Chessboard" class="headerlink" title="1.Defective Chessboard"></a>1.Defective Chessboard</h4><p><img src="https://pic.downk.cc/item/5fd8244f3ffa7d37b3812772.jpg" alt="实例"></p><p><img src="https://pic.downk.cc/item/5fd824933ffa7d37b3817057.jpg" alt=""></p><ul><li>n=pow(4,k)；</li><li>需要(n-1)/3个3-方块填满棋盘；</li><li>算法的时间复杂度：t(n)=4t(n/4)+c，a=4，b=4，loga=1。∴t(n)=Θ(n)。</li></ul><h4 id="2-归并排序-Merge-Sort"><a href="#2-归并排序-Merge-Sort" class="headerlink" title="2.归并排序(Merge Sort)"></a>2.归并排序(Merge Sort)</h4><ul><li>我们采用平衡分割法来分割n个元素，即将n个元素分为A和B两个集合，其中A集合中含有n/k个元素，B中包含其余的元素；</li><li>然后递归地使用分治法对A和B进行排序；</li><li>当A或B内元素&lt;k时使用插入排序；</li><li>然后采用一个成为归并(merge)的过程，将已排好序的A和B合并成一个集合。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T E,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对E中的n个元素进行排序，k为全局变量</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;=k)</span><br><span class="line">    &#123;</span><br><span class="line">        i=n/k;</span><br><span class="line">        j=n-i;</span><br><span class="line">        令A包含E中的前i个元素</span><br><span class="line">        令B包含E中余下的j个元素</span><br><span class="line">        sort(A,i);</span><br><span class="line">        sort(B,j);</span><br><span class="line">        merge(A,B,E,i,j); <span class="comment">//把A和B合并到E</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> 使用插入排序算法对E进行排序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度：</p><p>设t(n)为分治排序算法，则有以下递推公式</p><p><img src="https://pic.downk.cc/item/5fd828793ffa7d37b385eb02.jpg" alt=""></p><p>当n/k≈n-(n/k)时，t(n)的值最小(balance原理)</p><p>因此，当k=2时，分治法通常具有最佳性能：当k&gt;2时递归展开的深度超过 以2为底n的对数。</p><p>k=2时，有</p><p><img src="https://pic.downk.cc/item/5fd829273ffa7d37b386a9fd.jpg" alt=""></p><h4 id="3-快速排序-Quick-Sort"><a href="#3-快速排序-Quick-Sort" class="headerlink" title="3.快速排序(Quick Sort)"></a>3.快速排序(Quick Sort)</h4><ul><li>分治法还可以用于实现另一种完全不同的排序方法：快速排序；</li><li>在这种方法中，n个元素被分成三段，左短left，中段middle，右段right；</li><li>中段仅包含一个元素；左段中各元素都小于等于中段元素；右段中各元素都大于等于中段元素。因此left和right中的元素可以独立排序，并且不必对left和right的排序结果进行合并，middle中的元素被成为支点(pivot)。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="comment">//使用快速排序方法对a[0:n-1]排序</span></span><br><span class="line"><span class="comment">//从a[0:n-1]中选择一个元素作为middle，该元素为支点</span></span><br><span class="line"><span class="comment">//把余下的元素分割成为两段，left和right，使得left中的元素都小于等于支点，right中的元素都大于等于支点</span></span><br><span class="line"><span class="comment">//递归地使用快速排序方法对left进行排序</span></span><br><span class="line"><span class="comment">//递归地使用快速排序方法对right进行排序</span></span><br><span class="line"><span class="comment">//所得结果为left+middle+right</span></span><br></pre></td></tr></table></figure><p>快速排序的平均复杂性是Θ(nlogn)。</p><p>各种排序算法的比较</p><div class="table-container"><table><thead><tr><th>排序方法</th><th>比较次数</th><th></th><th>移动次数</th><th></th><th>稳定性</th><th>附加存储</th><th></th></tr></thead><tbody><tr><td></td><td>最好</td><td>最差</td><td>最好</td><td>最差</td><td></td><td>最好</td><td>最差</td></tr><tr><td>直接插入排序</td><td>n</td><td>n²</td><td>0</td><td>n²</td><td>√</td><td>1</td><td>1</td></tr><tr><td>折半插入排序</td><td>nlogn</td><td>nlogn</td><td>0</td><td>n²</td><td>√</td><td>1</td><td>1</td></tr><tr><td>冒泡排序</td><td>n</td><td>n²</td><td>0</td><td>n²</td><td>√</td><td>1</td><td>1</td></tr><tr><td>快速排序</td><td>nlogn</td><td>n²</td><td>nlogn</td><td>n²</td><td>×</td><td>logn</td><td>n²</td></tr><tr><td>简单选择排序</td><td>n²</td><td>n²</td><td>0</td><td>n</td><td>×</td><td>1</td><td>1</td></tr><tr><td>锦标赛排序</td><td>nlogn</td><td>nlogn</td><td>nlogn</td><td>nlogn</td><td>√</td><td>n</td><td>n</td></tr><tr><td>堆排序</td><td>nlogn</td><td>nlogn</td><td>nlogn</td><td>nlogn</td><td>×</td><td>1</td><td>1</td></tr><tr><td>归并排序</td><td>nlogn</td><td>nlogn</td><td>nlogn</td><td>nlogn</td><td>√</td><td>n</td><td>n</td></tr></tbody></table></div><p><img src="https://pic.downk.cc/item/5fd82ef73ffa7d37b38d3633.jpg" alt=""></p><h4 id="4-选择-Selection-Problem"><a href="#4-选择-Selection-Problem" class="headerlink" title="4.选择(Selection Problem)"></a>4.选择(Selection Problem)</h4><ul><li>定义：对于给定的n个元素的数组a[0:n-1]，要求从中找出第k小的元素；</li><li>选择问题可在O(nlogn)时间内解决，方法是首先对这n个元素进行排序(如使用堆排序或归并排序)，然后取出a[k-1]中的元素；</li><li>若使用快速排序，可以获得更好的平均性。尽管该算法在最坏情形下有一个比较差的渐进复杂性O(n²)。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Select</span><span class="params">(T a[],<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//返回a[0:n-1]中第k小的元素</span></span><br><span class="line">    <span class="comment">//假定a[n]是一个伪最大元素</span></span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">1</span>||k&gt;n) <span class="keyword">throw</span> OutOfBound();</span><br><span class="line">    <span class="keyword">return</span> select(a,<span class="number">0</span>,n<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">select</span><span class="params">(T a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在a[l:r]中选择第k小的元素</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="keyword">int</span> i=l;<span class="comment">//从左至右的游标</span></span><br><span class="line">    <span class="keyword">int</span> j=r+<span class="number">1</span>;<span class="comment">//从右到左的游标</span></span><br><span class="line">    T pivot=a[l];</span><br><span class="line">    <span class="comment">//把左侧&gt;=pivot的元素与右侧&lt;=pivot的元素进行交换</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;<span class="comment">//在左侧寻找&gt;=pivot的元素</span></span><br><span class="line">           i=i+<span class="number">1</span>; </span><br><span class="line">        &#125;<span class="keyword">while</span>(a[i]&lt;pivot)；</span><br><span class="line">        <span class="keyword">do</span>&#123;<span class="comment">//在右侧寻找&lt;=pivot的元素</span></span><br><span class="line">            j=j<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(a[j]&gt;pivot)</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;<span class="comment">//未发现交换对象</span></span><br><span class="line">        Swap(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j-l+<span class="number">1</span>==k) <span class="keyword">return</span> pivot;</span><br><span class="line">    <span class="comment">//设置pivot</span></span><br><span class="line">    a[l]=a[j];</span><br><span class="line">    a[j]=pivot;</span><br><span class="line">    <span class="comment">//对一个段进行调用</span></span><br><span class="line">    <span class="keyword">if</span>(j-l+<span class="number">1</span>&lt;k) <span class="keyword">return</span> select(a,j+<span class="number">1</span>,r,k-j+l<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> select(a,l,j<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序复杂度分析：</p><ul><li><p>最坏情况下复杂性是Θ(n²)；</p></li><li><p>如果left和right总是同样大小或者相差不超过一个元素，那么可以得到以下递归式：</p><p><img src="https://pic.downk.cc/item/5fd8543a3ffa7d37b3b5656c.jpg" alt=""></p></li><li><p>如果n是2的幂，则通过使用迭代方法，可以得到t(n)=Θ(n)；</p></li><li><p>提示：选择较好的pivot可得到较好的性能。</p></li></ul><p>中间的中间规则：</p><ul><li>若仔细地选择支点元素，则最坏情况下的时间开销也可以变成Θ(n)；</li><li>一种选择支点元素的方法是使用“中间的中间(median-of-median)”规则：首相将数组a中的n个元素分成n/r组，r为某一整常数，除了最后一组外，每组都有r个元素。然后通过在每组中对r个元素进行排序来寻找每组中位于中间位置的元素。最后对所得到的n/r个中间元素，递归使用选择算法，求得“中间之中间”作为支点元素。</li></ul><p>Example：</p><p><img src="https://pic.downk.cc/item/5fd855613ffa7d37b3b69742.jpg" alt="中间的中间实例"></p><h4 id="距离最近的点对"><a href="#距离最近的点对" class="headerlink" title="距离最近的点对"></a>距离最近的点对</h4><ul><li>问题描述：给定平面上n个点，找其中的一对点，使得在n个点所组成的所有点对中，该点对距离最小；</li><li>严格来讲，最接近点对可能多于一对，为简便起见，我们只找其中的一对作为问题的解；</li><li>一个简单的做法是将每一个点于其他n-1个点的句里算出，找出最小距离的点对即可。该方法的时间复杂性是T(n)=n(n-1)/2 + n = O(n²)，效率较低；</li></ul><h5 id="一维空间中的情形"><a href="#一维空间中的情形" class="headerlink" title="一维空间中的情形"></a>一维空间中的情形</h5><ul><li><p>为了使问题易于理解和分析，先来考虑一维的情形。此时，S中的n个点退化为x轴上的n个实数x1，x2，…，xn。最接近的点对即为这n个实数中相差最小的两个实数；</p></li><li><p>一个简单的办法就是先把x1，x2，…，xn排好序，再进行一次线性扫描就可以找出最接近点对，T(n)=O(nlogn)。然而这种方法无法推广到二维情形；</p></li><li><p>假设我们用x轴上某个点m将S划分为2个子集S1和S2，基于平衡子问题的思想，用S中各点坐标的中位数来作分割点；</p></li><li><p>递归地在S1和S2上找出最接近点对{p1，p2}和{q1，q2}，并设d=min{|p1-p2|，|q1-q2|}，S中的最接近点对或者是{p1，p2}，或者是{q1，q2}，或者是某个{p3，q3}，其中p3∈S1且q3∈S2；</p><p><img src="https://pic.downk.cc/item/5fd870c23ffa7d37b3d5bace.jpg" alt=""></p></li><li><p>可以用线性时间就可以找到问题的解；</p></li><li><p>分割点m的选取不当，会造成|Si|=1，|Sj|=n-1的情形，使得T(n)=T(n-1)+O(n)=O(n²)。这种情形可以通过“平衡子问题”方法加以解决：选取各坐标的中位数作分割点。</p></li></ul><h5 id="二维空间中的情形"><a href="#二维空间中的情形" class="headerlink" title="二维空间中的情形"></a>二维空间中的情形</h5><ul><li><p>选取一垂直线l：x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1和S2；</p></li><li><p>递归地在S1和S2上找出其最小距离d1和d2，并设d=min{d1，d2}，S中的最接近点1对或者是d，或者是某个{p，q}，其中p∈S1且q∈S2；</p><p><img src="https://pic.downk.cc/item/5fd871ec3ffa7d37b3d709d1.jpg" alt=""></p></li><li><p>复杂度分析</p><p><img src="https://pic.downk.cc/item/5fd8720a3ffa7d37b3d72be0.jpg" alt=""></p></li></ul><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>任何求最大最小的算法从起始状态到完成状态所用比较次数不可少于 <strong>(3n/2)(上取整)-2</strong>；</li><li><strong>(3n/2)(上取整)-2</strong>是所有基于比较的求最大最小算法所需比较次数的下界；</li><li>堆排序，归并排序在最坏情况下有较好的性能(针对渐进复杂性而言)；</li><li>堆排序，归并排序，快速排序在平均情况下性能较优。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Greedy</title>
      <link href="2020/12/11/AlgorithmChapter4/"/>
      <url>2020/12/11/AlgorithmChapter4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>优化问题：贪心法常用于解优化问题</p><p>应用：</p><ol><li>货箱装船问题</li><li>背包问题</li><li>拓扑排序问题</li><li>哈夫曼编码问题</li><li>最短路径问题</li><li>最小代价生成树</li><li>偶图覆盖问题</li></ol><p>优化解即指始目标函数极大化(或极小化)的可行解，对应的目标函数值成为优化值。</p><p>很多优化问题时NP-难度问题，迄今找不到他们的多项式算法。所以计算上可行的方法就是求其近似解。贪心法是求近似算法的主要途径。</p><h3 id="贪心法：一种多步求解的方法"><a href="#贪心法：一种多步求解的方法" class="headerlink" title="贪心法：一种多步求解的方法"></a>贪心法：一种多步求解的方法</h3><p>每步按一种局部优化的策略选择解(元组)的一个分量；</p><p>算法以第n步结束时构造出的对象(元组)作为问题的解；</p><p>这种局部优化的策略又称为“贪心标准”。</p><h3 id="贪心法主要特点"><a href="#贪心法主要特点" class="headerlink" title="贪心法主要特点"></a>贪心法主要特点</h3><ol><li>不回溯：选定一个分量后，不重试其他可能。</li><li>使用局部优化策略的主要原因是减小计算开销。但局部优化策略不保证得到精确优化解，可能得到的是近似解。特别是对NP-难度问题。</li><li>不同的“贪心”策略得到不同的算法。</li><li>常常采纳使目标函数有最大增量的策略为贪心策略；增量是局部性概念。</li></ol><p>遗传算法，神经网络等等都是具有这类贪心性质的启发式算法。</p><h3 id="贪心算法性能"><a href="#贪心算法性能" class="headerlink" title="贪心算法性能"></a>贪心算法性能</h3><p>贪心算法并不总能求得问题的整体最优解。但对于活动安排问题，机器调度问题，上述贪心算法却总能求得整体最优解。</p><h3 id="K-优化算法"><a href="#K-优化算法" class="headerlink" title="K-优化算法"></a><strong>K-优化算法</strong></h3><p>K-优化算法是上述密度贪心算法的改进，改进后误差可控制在1/(k+1)*100%之内</p><p>算法得时间复杂度随k的增大而增加：</p><ul><li>需要测试的子集数目为O(pow(n,k))；</li><li>每一个子集做贪心法需时间O(n)；</li><li>因此当k&gt;0时总的时间开销为O(pow(n,k+1))；</li></ul><p>内容：</p><ul><li>先对物品按密度从大到小排序；</li><li>先将一些物品装入背包，然后对其余物品使用贪心法；</li><li>预先装入的物品数不超过k；</li><li>对所有物品数不超过k的物品子集执行上述过程，并从中找到有最大效益值得解作为k-优化算法得解。</li></ul><h3 id="哈夫曼编码问题"><a href="#哈夫曼编码问题" class="headerlink" title="哈夫曼编码问题"></a>哈夫曼编码问题</h3><p>前缀码：对每一个字符规定一个0，1串作为其代码，并要求任一字符的代码都不是其他字符代码的前缀，这种编码成为前缀码。</p><p>使平均码长达到最小的前缀码编码方案成为未定编码字符集C的最优前缀码。</p><p>哈夫曼提出构造最优前缀码的贪心算法，由此产生的编码方案成为哈夫曼编码。</p><p>具体算法：</p><ol><li>根据n个权值{w1, w2, …, wn}构成n棵二叉树的集合F={T1，T2,… Tn}，其中每棵二叉树Ti中只有一个带权值为wi的根节点，其左右子树均为空。</li><li>在F中选取两棵根节点权值最小的树作为左右子树来构造一棵新的二叉树，且置新的二叉树的根节点的权值为其左右子树的根节点权值之和。</li><li>在F中删除这两棵树，同时将新得到的二叉树加入F中。</li><li>重复step2，3，直到F中只含一棵树时为止。称这棵树为最优二叉树或哈夫曼树。</li></ol><p>如果约定将每个节点的左分支表示字符‘0’，右分支表示字符‘1’，则可以把从根节点到某叶子节点的路径上分支字符组成的字符串作为该叶子节点的编码。</p><p>哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。</p><p>算法以|C|个叶节点开始，执行|C|-1次的“合并”运算后产生最终所要求的树T。</p><p>关于n个字符的哈夫曼算法的计算时间为O(nlogn)。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>邻接矩阵与邻接表</p><p><img src="https://pic.downk.cc/item/5fd5c5063ffa7d37b3435a23.jpg" alt="邻接矩阵"></p><p><img src="https://pic.downk.cc/item/5fd5c5253ffa7d37b34385ae.jpg" alt="邻接表"></p><p>拓扑排序定义：根据任务的有向图建立拓扑序列的过程。</p><p>贪心策略：从当前尚不在拓扑排序序列的顶点中选择一项顶点w，其所有先行节点v都在已产生的拓扑序列中(或无先行顶点)并将其加入到拓扑序列中。</p><p>使用栈的伪代码：</p><ol><li><p>计算每个顶点的入度</p></li><li><p>将入度为0的顶点入栈</p></li><li><p>While(栈不空){</p><p>​    任取一入度为0的顶点放入拓扑序列中；</p><p>​    将与其相邻的顶点的入度减1；</p><p>​    如有新的入度为0的顶点出现，将其放入栈中；</p><p>}</p></li><li><p>如有剩余的顶点则该图有环路</p></li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Network::Topological</span><span class="params">(<span class="keyword">int</span> v[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算有向图中顶点的拓扑次序</span></span><br><span class="line">    <span class="comment">//如果找到了一个拓扑次序，则返回true，此时，在v[0:n-1]中记录拓扑次序</span></span><br><span class="line">    <span class="comment">//如果不存在拓扑次序，则返回false</span></span><br><span class="line">    <span class="keyword">int</span> n=Vertices();</span><br><span class="line">    <span class="comment">//计算入度</span></span><br><span class="line">    <span class="keyword">int</span> *InDegree=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    InitializePos();<span class="comment">//图遍历器数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//初始化</span></span><br><span class="line">        InDegree[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//从i出发的边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=Begin(i);</span><br><span class="line">        <span class="keyword">while</span>(u)</span><br><span class="line">        &#123;</span><br><span class="line">            InDegree[u]++;</span><br><span class="line">            u=NextVertex(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把入度为0的顶点压入堆栈</span></span><br><span class="line">    LinkedStack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!InDegree[i]) S.Add(i);</span><br><span class="line">    <span class="comment">//产生拓扑次序</span></span><br><span class="line">    i=<span class="number">0</span>;<span class="comment">//数组v的游标</span></span><br><span class="line">    <span class="keyword">while</span>(!S.IsEmpty())<span class="comment">//从堆栈中选择下一个顶点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        S.Delete(w);</span><br><span class="line">        v[i++]=w;</span><br><span class="line">        <span class="keyword">int</span> u=Begin(w);</span><br><span class="line">        <span class="keyword">while</span>(u)<span class="comment">//修改入度</span></span><br><span class="line">        &#123;</span><br><span class="line">            InDegree[u]--;</span><br><span class="line">            <span class="keyword">if</span>(!InDegree[u]) S.Add[u];</span><br><span class="line">            u=NextVertex(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DeactivatePos();</span><br><span class="line">    <span class="keyword">delete</span> [] InDegree;</span><br><span class="line">    <span class="keyword">return</span> (i==n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述算法的时间复杂度：</p><p>Θ(n²)：使用邻接矩阵；Θ(n+e)：使用邻接表</p><h3 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h3><p>任给一有向图G，它的每条边都有一个非负的权值，路径的长度定义为路径上边的权值之和。</p><p>单源最短路径问题：给定的源节点s，找出从s到图中所有其他节点(成为目的)的最短路径(优化解)及其长度(优化值)</p><h3 id="Dijkstra‘s最短路算法"><a href="#Dijkstra‘s最短路算法" class="headerlink" title="Dijkstra‘s最短路算法"></a>Dijkstra‘s最短路算法</h3><ul><li>如果链路权值非负，则最短路的子路径也是最短路，其长度小于原来路径的长度。所以，长度较小的最短路容易找到。</li><li>贪心策略：按最短路长度从小到大依次求解。</li><li>Dijkstra’s最短路算法使用上述贪心策略，是图论算法中应用最为广泛的算法，主要原因是其计算复杂度低且容易实现。</li></ul><p>基本步骤：</p><ol><li>维护一个集合S，该集合中源节点到其他节点的最短路已知，初始时该集合为空；</li><li>从V-S结合中找一节点v，满足源节点到该节点距离最小；</li><li>更新v的临界点的到源节点的距离值。</li></ol><p>Example：1</p><p><img src="https://pic.downk.cc/item/5fd6fde83ffa7d37b35ee9ca.jpg" alt="Dijkstra‘s最短路算法实例"></p><p>S：{A,C,E,B,D}</p><p>源节点为A，所以S：{A}；</p><p>在S中的节点中找到于之有关的最短路径，将另一节点放入S中；</p><p>即AC=min，所以S：{A,C}；</p><p>CE=min，所以S：{A,C,E}；</p><p>CB=min，所以S：{A,C,E,B}；</p><p>BD=min，所以S：{A,C,E,B,D}</p><p>∴S：{A,C,E,B,D}</p><p>Example：2</p><p><img src="https://pic.downk.cc/item/5fd701953ffa7d37b3622a6e.jpg" alt="实例"></p><p>Example of breadth-first search：</p><p><img src="https://pic.downk.cc/item/5fd7035a3ffa7d37b363d1b4.jpg" alt="广度优先搜索实例"></p><h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>介绍：Dijkstra算法无法判断含负权边的图的最短路。如果遇到负权，在没有负权回路（回路的权值和为负，即便有负权的边）存在时，也可以采用Bellman - Ford算法正确求出最短路径。</p><p>Bellman-Ford算法能在更普遍的情况下（存在负权边）解决单源点最短路径问题。对于给定的带权（有向或无向）图 G=(V,E), 其源点为s，加权函数 w是 边集 E 的映射。对图G运行Bellman - Ford算法的结果是一个布尔值，表明图中是否存在着一个从源点s可达的负权回路。若不存在这样的回路，算法将给出从源点s到 图G的任意顶点v的最短路径d[v]。</p><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>时间复杂度：O(n³)；空间复杂度：O(n²)(矩阵)</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ul><li>具有n个顶点的连通无向图G，图的每条边e有一非负权值c(e)，也称为成本，求有最小成本的生成树。</li><li>每个生成树刚好具有n-1条边，所以问题是用某种方法选择n-1条边使它们形成G的最小生成树。</li><li>Kruskal’s算法；Prim‘s算法。</li></ul><h3 id="Kruskal’s算法"><a href="#Kruskal’s算法" class="headerlink" title="Kruskal’s算法"></a>Kruskal’s算法</h3><p>贪心策略：每次选择权值c(e)最小且与以前选择的边不构成回路的边。</p><p>上述策略要求按权值从小到大对边排序。</p><p>算法可在O(n+eloge)找出最小生成树。</p><p><img src="https://pic.downk.cc/item/5fd7588d3ffa7d37b3bb7cd8.jpg" alt="算法正确性证明"></p><h3 id="Prim‘s算法"><a href="#Prim‘s算法" class="headerlink" title="Prim‘s算法"></a>Prim‘s算法</h3><p>步骤：</p><ol><li>在图中选出权值最小的边，边的两个顶点放入点集V；</li><li>在图中找到权值最小且与点集V有关的边；</li><li>重复2直至找到最小生成树。</li></ol><h3 id="偶图覆盖问题-二分覆盖"><a href="#偶图覆盖问题-二分覆盖" class="headerlink" title="偶图覆盖问题(二分覆盖)"></a>偶图覆盖问题(二分覆盖)</h3><ul><li>偶图是一个无向图，它的n个顶点分为集合A和集合B，且同一集合中的任意两个顶点无边相连。</li><li>A的一个子集A’覆盖集合B iff B中每一个顶点至少和A’中一顶点相连。覆盖A‘的大小指A’中的顶点数目。</li><li>在偶图中寻找最小覆盖的问题成为偶图覆盖(bipartite-cover)问题。</li></ul><p>Example：</p><p><img src="https://pic.downk.cc/item/5fd719d53ffa7d37b37d8140.jpg" alt="偶图覆盖问题实例"></p><ul><li>上图为有17个顶点的二分图；</li><li>A={1，2，3，16，17}；B={4，5，6，7，8，9，10，11，12，13，14，15}；</li><li>子集A’={1，16，17}是B的最小覆盖：1覆盖{4，6，7，8，9，13}；16覆盖{5，6，8，12，14，15}；17覆盖{4，9，10，11}</li><li>贪心策略：选择覆盖B中那些尚未被覆盖的顶点数最多的A的系节点。</li><li>对上图应用上述贪心法，得到A‘={1，16，17}。</li><li>覆盖算法总的算法复杂性为O(Sizeof(A²)+n²)或O(Sizeof(A²)+n+e)。</li></ul><h3 id="连续背包问题"><a href="#连续背包问题" class="headerlink" title="连续背包问题"></a>连续背包问题</h3><p>一种可行的贪心策略：按价值密度非递减的顺序检查物品，若剩余容量能容下正在考察的物品，将其装入；否则往背包中装入此物品的一部分。</p><p>证明这种贪心算法总能产生最优解：</p><p><img src="https://pic.downk.cc/item/5fd757e73ffa7d37b3baa65d.jpg" alt="证明这种贪心算法总能产生最优解"></p><p><img src="https://pic.downk.cc/item/5fd7581a3ffa7d37b3bae72a.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Analysis of Algorithms</title>
      <link href="2020/12/10/AlgorithmChapter3/"/>
      <url>2020/12/10/AlgorithmChapter3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="Pseudocode（伪代码）"><a href="#Pseudocode（伪代码）" class="headerlink" title="Pseudocode（伪代码）"></a>Pseudocode（伪代码）</h2><h2 id="Soving-Recurrences（解递归）"><a href="#Soving-Recurrences（解递归）" class="headerlink" title="Soving Recurrences（解递归）"></a>Soving Recurrences（解递归）</h2><h3 id="1-Recursion-tree"><a href="#1-Recursion-tree" class="headerlink" title="1.Recursion tree"></a>1.Recursion tree</h3><p><img src="https://pic.downk.cc/item/5fd202493ffa7d37b3765357.jpg" alt="解递归树"></p><p>解T(n)=2T(n/2)+cn，其中c&gt;0为常数。递归展开到T(n0)，会导致推导的麻烦。所以解递归展开到T(1)，然后再从前n0个T(n)的值确定渐进分析的常数。</p><p>继续展开得到</p><p><img src="https://pic.downk.cc/item/5fd2034e3ffa7d37b377516a.jpg" alt="完全展开"></p><p>Total=Θ(nlgn)。</p><p>很多递归式用递归树解不出来，但递归树能提供直觉，帮助我们用归纳法求解(Guess归纳假设)</p><p>较一般的递归式：T(n)=aT(n/b)+cn</p><p>a，b是大于1的整数，递归树方法仍可使用。</p><h3 id="2-Substitution-method"><a href="#2-Substitution-method" class="headerlink" title="2.Substitution method"></a>2.Substitution method</h3><p><strong>The most general method：</strong></p><p>1.Guess the form of the solution；</p><p>2.Vertify by induction；</p><p>3.Solve for constants。</p><h3 id="3-Master-method"><a href="#3-Master-method" class="headerlink" title="3.Master method"></a>3.Master method</h3><p>T(n)=aT(n/b)+f(n)。式中a&gt;=1，b&gt;=1，为整数，f(n)&gt;0</p><p><strong>以下loga均指以b为底a的对数</strong></p><h4 id="Case-1：f-n-lt-pow-n-loga"><a href="#Case-1：f-n-lt-pow-n-loga" class="headerlink" title="Case 1：f(n)&lt;pow(n,loga)"></a>Case 1：f(n)&lt;pow(n,loga)</h4><p>f(n)=O(pow(n,loga-ε))，ε&gt;0，为某一常数。f(n)的增长渐进地慢于pow(n,loga)(慢pow(n,ε)倍)</p><p>∴Solution：T(n)=Θ(pow(n,loga))。</p><h4 id="Case-2："><a href="#Case-2：" class="headerlink" title="Case 2："></a>Case 2：</h4><p>f(n)=Θ(pow(n,loga)*pow(lgn,k))  k&gt;=0为某一常数</p><p>f(n)和pow(n,loga)几乎有相同的渐进增长率。</p><p>∴Solution：T(n)=Θ(pow(n,loga)*pow(lgn,k+1))。</p><h4 id="Case-3：f-n-gt-pow-n-loga"><a href="#Case-3：f-n-gt-pow-n-loga" class="headerlink" title="Case 3：f(n)&gt;pow(n,loga)"></a>Case 3：f(n)&gt;pow(n,loga)</h4><p>f(n)=Ω(pow(n,loga+ε))，ε&gt;0，为某一常数。f(n)的增长渐进地快于pow(n,loga)(快pow(n,ε)倍)</p><p>其中，f(n)满足：af(n/b)&lt;=cf(n)，0&lt;c&lt;1为常数</p><p>∴Solution：T(n)=Θ(f(n))。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>等式右边，哪项变化得快，T(n)就属于哪项的数量级。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是非黑白 自在人心</title>
      <link href="2020/12/10/%E6%98%AF%E9%9D%9E%E9%BB%91%E7%99%BD-%E8%87%AA%E5%9C%A8%E4%BA%BA%E5%BF%83/"/>
      <url>2020/12/10/%E6%98%AF%E9%9D%9E%E9%BB%91%E7%99%BD-%E8%87%AA%E5%9C%A8%E4%BA%BA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><img src="https://pic.downk.cc/item/5fe05a933ffa7d37b361f22e.jpg" alt="Title"></p><p>​        世上本没有路，走的人多了，也便成了路；类似地，有的言论说多了，就有人选择相信。在现在的信息化时代中，人们对信息的获取非常便捷，但是人们接受信息的时间和方式非常的碎片化，很可能尝尝因为一张图片，一个视频片段，一段采访，一篇文章，而相信一个所谓的事实。而往往很多人会去选择相信一个错误的事实。人的观点和思想很容易被改变，往往很多时候不是被事实所影响，甚至是被言语所影响。<!--短视频爆火，我也很轻易顺着一些视频的节奏去相信一个事实，后来了解到其中，有很多是在断章取义，颠倒黑白。--></p><p><img src="https://pic.downk.cc/item/5fe05b013ffa7d37b36279ab.jpg" alt=""></p><p><img src="https://pic.downk.cc/item/5fe05b7e3ffa7d37b362f2c5.jpg" alt="庆余年"></p>]]></content>
      
      
      <categories>
          
          <category> Humanity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Humanity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 2 程序性能</title>
      <link href="2020/12/10/AlgorithmChapter2/"/>
      <url>2020/12/10/AlgorithmChapter2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="空间复杂度Sp-n"><a href="#空间复杂度Sp-n" class="headerlink" title="空间复杂度Sp(n)"></a>空间复杂度Sp(n)</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>指程序运行时所需的内存空间大小和实例特征的函数关系。</p><h3 id="2-程序运行时所需空间包括"><a href="#2-程序运行时所需空间包括" class="headerlink" title="2.程序运行时所需空间包括"></a>2.程序运行时所需空间包括</h3><p>指令空间：与实例特征无关的常数；</p><p>数据空间：常量和简单变量-与实例无关；</p><p>​                  复合变量-数组，链表，树和图等；</p><p>​                  环境栈空间-函数调用-是否递归；</p><p>复合变量所需空间尝尝和问题实例特征有关； </p><h3 id="3-计算"><a href="#3-计算" class="headerlink" title="3.计算"></a>3.计算</h3><p>S(p)=c+Sp(instance characteristics)</p><p>其中c为常量(实例无关部分)，Sp为可变部分。在使用解析方法研究程序p的空间复杂度时仅考虑Sp。在分析空间复杂度时我们忽略与实例特征无关的空间需求量。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SequentialSearch</span><span class="params">(T a[], <span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Search the unordered list a[0:n-1] for x.</span></span><br><span class="line">    <span class="comment">//Return position if found; Return -1 otherwise.</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n&amp;&amp;a[i]!=x;i++)</span><br><span class="line">        <span class="keyword">if</span>(i==n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例特征：n，S(n)=0;</p><p>该程序所占空间均为常量，与实例特征无关，所以S(n)=0。</p><h2 id="时间复杂度T-n"><a href="#时间复杂度T-n" class="headerlink" title="时间复杂度T(n)"></a>时间复杂度T(n)</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>指程序执行时所用的时间。</p><h3 id="2-计算"><a href="#2-计算" class="headerlink" title="2.计算"></a>2.计算</h3><p>在使用解析方法时程序p的时间复杂度表示为输入量的函数T。</p><p>在解析地分析时间复杂度时，使用以下两种时间单位并计算：</p><p>​        操作步数(operation count)：算法的基本操作；</p><p>​        (程序)步计数(step count)：分析全部程序。</p><p>要点：基本操作或程序步执行的时间必须时常数。</p><h3 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h3><p>s/e：代表该语句执行后步数(count)的变化(增量)；</p><p>Frequency：代表该语句执行的次数；</p><p>Total steps：代表该语句在整个程序执行过程中引发的总步数。</p><div class="table-container"><table><thead><tr><th>Statement</th><th>s/e</th><th>Frequency</th><th>Total steps</th></tr></thead><tbody><tr><td>T Sum(T a[],int n)</td><td>0</td><td>0</td><td>0</td></tr><tr><td>{</td><td>0</td><td>0</td><td>0</td></tr><tr><td>T tsum=0;</td><td>1</td><td>1</td><td>1</td></tr><tr><td>for(int i=0;i&lt;n;i++)</td><td>1</td><td>n+1</td><td>n+1</td></tr><tr><td>tsum+=a[i];</td><td>1</td><td>n</td><td>n</td></tr><tr><td>return tsum;</td><td>1</td><td>1</td><td>1</td></tr><tr><td>}</td><td>0</td><td>0</td><td>0</td></tr><tr><td>Total</td><td></td><td></td><td>2n+3</td></tr></tbody></table></div><h2 id="渐进分析（O-Ω-Θ）"><a href="#渐进分析（O-Ω-Θ）" class="headerlink" title="渐进分析（O,Ω,Θ）"></a>渐进分析（O,Ω,Θ）</h2><h3 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h3><p>计算机科学使用最多的符号-讨论算法时使用的共同语言</p><p>O：上界；Ω：下界；Θ：同阶。</p><h3 id="2-随n的增加T-n-的增长率"><a href="#2-随n的增加T-n-的增长率" class="headerlink" title="2.随n的增加T(n)的增长率"></a>2.随n的增加T(n)的增长率</h3><p><img src="https://pic.downk.cc/item/5fd198d13ffa7d37b3f58ffa.jpg" alt="随n的增加T(n)的增长率"></p><h3 id="3-渐进分析时用到的一些等式"><a href="#3-渐进分析时用到的一些等式" class="headerlink" title="3.渐进分析时用到的一些等式"></a>3.渐进分析时用到的一些等式</h3><p><img src="https://pic.downk.cc/item/5fd199e33ffa7d37b3f68904.jpg" alt="渐进分析时用到的一些等式"></p><p>E8：i form 1 to n. ∑1/i   -&gt;   Θ(logn)</p><h3 id="4-例题-1"><a href="#4-例题-1" class="headerlink" title="4.例题"></a>4.例题</h3><div class="table-container"><table><thead><tr><th>Statement</th><th>s/e</th><th>Frequency</th><th>Total steps</th></tr></thead><tbody><tr><td>T Sum(T a[], int n)</td><td>0</td><td>0</td><td>Θ(0)</td></tr><tr><td>{</td><td>0</td><td>0</td><td>Θ(0)</td></tr><tr><td>T tsum=0;</td><td>1</td><td>1</td><td>Θ(1)</td></tr><tr><td>for(int i=0;i&lt;n;i++)</td><td>1</td><td>n+1</td><td>Θ(n)</td></tr><tr><td>tsum+=a[i];</td><td>1</td><td>n</td><td>Θ(n)</td></tr><tr><td>return tsum;</td><td>1</td><td>1</td><td>Θ(1)</td></tr><tr><td>}</td><td>0</td><td>0</td><td>Θ(0)</td></tr></tbody></table></div><p>∴ t(n)=Θ(max{})=Θ(n)</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 1 算法概述</title>
      <link href="2020/12/10/AlgorithmChapter1/"/>
      <url>2020/12/10/AlgorithmChapter1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>1.定义：是对特定问题求解步骤的一种描述，是指令的有限序列。</p><p>2.特征：</p><p>输入：算法有零个或多个输入量；</p><p>输出：算法至少产生一个输出量；</p><p>确定性：算法的每一条指令都有确切的定义，没有二义性；</p><p>能行性：算法的每一条指令必须足够基本，他们可以通过已经实现的基本运算执行有限次来实现。</p><p>有穷性：算法必须总能在执行有限步之后终止。</p><h2 id="程序：程序是算法用某种程序语言的具体实现"><a href="#程序：程序是算法用某种程序语言的具体实现" class="headerlink" title="程序：程序是算法用某种程序语言的具体实现"></a>程序：程序是算法用某种程序语言的具体实现</h2><p>程序可以不满足算法的5条性质。</p><p>操作系统，是一个在无限循环中执行的程序，因而不是一个算法。</p><p>操作系统的各种任务可看成是单独的问题，每一个问题由操作系统中的一个子程序通过特定的算法来实现。该子程序得到输出结果后便终止。</p><h2 id="算法的性能：算法所需的计算时间和占用的内存空间"><a href="#算法的性能：算法所需的计算时间和占用的内存空间" class="headerlink" title="算法的性能：算法所需的计算时间和占用的内存空间"></a>算法的性能：算法所需的计算时间和占用的内存空间</h2><h2 id="问题和问题求解"><a href="#问题和问题求解" class="headerlink" title="问题和问题求解"></a>问题和问题求解</h2><h3 id="常见的应用问题类型："><a href="#常见的应用问题类型：" class="headerlink" title="常见的应用问题类型："></a>常见的应用问题类型：</h3><p>1.搜索问题；2.排序问题；3.图论问题；4.组合数学问题；5.几何问题；6.数值计算问题；</p><h2 id="P问题"><a href="#P问题" class="headerlink" title="P问题"></a>P问题</h2><ul><li>P问题能够保证存在多项式时间求解算法；</li><li>NP问题不确定是否存在多项式时间求解算法，但确定存在多项式时间验证算法；</li><li>P问题是NP问题的子集，因为存在多项式时间求解算法的问题，一定能够在多项式时间内被验证；</li><li>NP-hard问题不一定是NP问题，有可能是不可判定问题。这时候说明原问题也是不可判定的；</li><li>NPC问题既是NP问题的子集，又是NP-hard问题的子集，所以NPC问题是NP问题和NP-hard问题的交集；</li><li>NP-hard问题和NPC问题都要求能够在多项式时间内规约成另外一个问题。这里规约的意思是将一个特殊问题一般化，即将原问题推广为一个最一般的，最有概括性，也更难得，计算复杂度更高的问题，这个问题具有最高的计算复杂度，如果这个最一般的问题也能有多项式时间求解算法，那么那些特殊的原问题也能有多项式时间求解算法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IM</title>
      <link href="2020/12/08/IM/"/>
      <url>2020/12/08/IM/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Part-of-the-journey-is-the-end"><a href="#Part-of-the-journey-is-the-end" class="headerlink" title="Part of the journey is the end."></a><strong>Part of the journey is the end.</strong></h1><p><a href="https://www.bilibili.com/video/BV1jb411G7Ks?from=search&amp;seid=6201754850823827634">LoveU3000</a> ←click here to watch a marvelous video.</p><h2 id="Lines"><a href="#Lines" class="headerlink" title="Lines"></a>Lines</h2><h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><p>Gosh seems like thousand years ago.</p><p>I fought my way out of the cave, became iron man. </p><p>Realized I loved you. </p><p>I know I said no more surprises, but I was really hoping to pull off the one last one. </p><h3 id="Avengers：Endgame"><a href="#Avengers：Endgame" class="headerlink" title="Avengers：Endgame"></a>Avengers：Endgame</h3><p><img src="https://pic.downk.cc/item/5fd5a07a3ffa7d37b31abcd4.jpg" alt=""></p><p>This thing on? Hey, Miss Potts. Pep. </p><p>If you find this recording, don’t post it on social media. It’s gonna be a real tearjerker. </p><p>I don’t know if you’re ever gonna see these. I don’t even know if you’re still … Oh, God, I hope so. </p><p>Today’s day 21. No, 22. </p><p>You know, if it wasn’t for the existential terror of staring into the literal void of space, I’d say I’m feeling a little better today. </p><p>Infection’s run its course, thanks to the Blue Meanie back there. </p><p>You’d love her. Very practical. Only a tiny bit sadistic. </p><p>So, the fuel cells were cracked during battle and we figured out a way to reverse the ion charge and bought ourselves about 48 hours of flight time. </p><p>But it’s now dead in the water. Thousand light years from the nearest 7-Eleven. </p><p>Oxygen will run out tomorrow morning and that’ll be it. </p><p>Pep, I know I said no more surprises but I gotta say I was really hoping to pull off one last one. </p><p>But it looks like … Well, you know what it looks like. </p><p>Don’t feel bad about this. I mean, actually, if you grovel for a couple weeks and then move on with enormous guilt.</p><p>I should probably lie down for a minute. Go rest my eyes. </p><p>Please know, when I drift off, it’ll be like every night lately. </p><p>I’m fine. Totally fine. I dream about you. Because it’s always you. </p><p><img src="https://pic.downk.cc/item/5fdc3da03ffa7d37b3429df3.jpg" alt=""></p><p>No amount of money ever bought a second of time. </p><p><img src="https://pic.downk.cc/item/5fdad5c73ffa7d37b32d66ae.jpg" alt=""></p><p>Everybody wants a happy ending, right? But it doesn’t always roll that way. Maybe this time. </p><p>I’m hoping if you play this back, it’s in celebration. </p><p>I hope families are reunited. I hope we get it back. </p><p>And something like a normal version of the planet has been restored. </p><p>If there ever was such a thing. God, what a world. Universe, now. </p><p>If you told me 10 years ago that we weren’t alone, let alone to this extent, I mean, I wouldn’t have been surprised, but come on, who knew?</p><p>The epic forces of darkness and light that have come into play. </p><p>And for better or worse, that’s the reality Morgan’s gonna have to find a way to grow up in. </p><p>So, I thought I’d probably better record a little greeting in the case of an untimely death. On my part. Not that death at any time isn’t untimely. </p><p>This time travel thing that we’re gonna try and pull off tomorrow, it’s got me scratching my head about the survivability of it all. That’s the thing. </p><p>Then again, that’s the hero gig, right? </p><p><strong>Part of the journey is the end.</strong> </p><p>What am I even tripping for? </p><p>Everything is gonna work out exactly the way it’s supposed to. </p><p>I love you 3000. </p><p><img src="https://pic.downk.cc/item/5fdad5ca3ffa7d37b32d68dc.jpg" alt=""></p><p><img src="https://pic.downk.cc/item/5feabefb3ffa7d37b30e9907.jpg" alt="RDJ:That&#39;s all done."></p>]]></content>
      
      
      <categories>
          
          <category> IM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New beginning</title>
      <link href="2020/12/08/New-beginning/"/>
      <url>2020/12/08/New-beginning/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>​    2020/12/8, I built up this website to write down my different phases and some details in my life. This is a totally new start. I will improve this blog gradually and share my  ideas and feelings. </p>]]></content>
      
      
      <categories>
          
          <category> New </category>
          
      </categories>
      
      
        <tags>
            
            <tag> New </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/08/hello-world/"/>
      <url>2020/12/08/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Original-website"><a href="#Original-website" class="headerlink" title="Original website"></a>Original website</h1><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post <span class="string">&quot;Post Name&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>注意：</p><p>1.现安装douban插件，生成网页的命令为hexo douban，由于前缀和hexo deploy相同，所以以后上传时要使用hexo deploy命令。</p><p>2.hexo根目录下_config,yml文件中douban中builtin已设置为true，即在hexo g和hexo s时包括了hexo douban命令。</p><h3 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo cl</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/zh-cn/docs/commands.html">Clean</a></p><h3 id="Font-Awesome"><a href="#Font-Awesome" class="headerlink" title="Font Awesome"></a>Font Awesome</h3><p><a href="http://www.fontawesome.com.cn/">http://www.fontawesome.com.cn/</a></p><h3 id="Font-Awesome（foreign）"><a href="#Font-Awesome（foreign）" class="headerlink" title="Font Awesome（foreign）"></a>Font Awesome（foreign）</h3><p><a href="https://fontawesome.com/">https://fontawesome.com/</a></p><h3 id="聚合图床"><a href="#聚合图床" class="headerlink" title="聚合图床"></a>聚合图床</h3><p><a href="http://www.superbed.cn/admin">http://www.superbed.cn/admin</a></p><h3 id="Iconfont"><a href="#Iconfont" class="headerlink" title="Iconfont+"></a>Iconfont+</h3><p><a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><h3 id="引用JS-CSS文件"><a href="#引用JS-CSS文件" class="headerlink" title="引用JS/CSS文件"></a>引用JS/CSS文件</h3><h4 id="Take-CSS-as-an-example："><a href="#Take-CSS-as-an-example：" class="headerlink" title="Take CSS as an example："></a>Take CSS as an example：</h4><p>1.新建一个CSS文件，移动到 \butterfly\source\css\ 目录下。</p><p>2.在主题配置文件(\hexo\themes\butterfly_config.yml)中定位搜索 inject。</p><p>3.其中head是用来引入 CSS 文件；bottom 是用来引用 JS 文件。</p><h3 id="页内跳转"><a href="#页内跳转" class="headerlink" title="页内跳转"></a>页内跳转</h3><p>Format：[ ] ( ) 中括号内为名称，小括号内为跳转位置</p><p>Example：<a href="#页内跳转">go</a></p><h3 id="Hexo文章的密码访问"><a href="#Hexo文章的密码访问" class="headerlink" title="Hexo文章的密码访问"></a>Hexo文章的密码访问</h3><p>方法一</p><p>方法实现，因Hexo中Markdown语言和html是混用的，所以可直接在Markdown中直接插入以下这段<code>script</code>(建议放到<code>&lt;!-- more --&gt;</code>段后面)。<br>这里用到了windows对象的<code>alert()</code>方法和<code>prompt()</code>方法。<code>prompt()</code>方法的作用即是显示一个可提示用户输入的对话框，而其本身的返回值就是你输入的那个字符串。因此只需要将其与你默认的密码比较一下就好，如果不正确，则直接将当前页面的loaction属性设为上一个页面即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="string">&quot;123&quot;</span>==prompt(<span class="string">&quot;请输入文档密码&quot;</span>))</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;密码正确&quot;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">else</span></span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;密码错误返回主页&quot;</span>);</span></span><br><span class="line"><span class="javascript">        location=<span class="string">&quot;/&quot;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方法二</p><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure><p>在front-matter中添加password</p><p>password: your password</p>]]></content>
      
      
      <categories>
          
          <category> Introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> New </tag>
            
            <tag> Introduction </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
