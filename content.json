{"meta":{"title":"CheeseburgerIM","subtitle":"IM灬Tony Pan","description":"I d like a cheeseburger^_^","author":"Tony Pan","url":"https://CheeseburgerIM.github.io","root":"/"},"pages":[{"title":"Accounts","date":"2021-01-22T10:38:54.000Z","updated":"2021-06-22T13:06:38.827Z","comments":false,"path":"Accounts/index.html","permalink":"https://cheeseburgerim.github.io/Accounts/index.html","excerpt":"","text":"Accounts Communication Game 小米 576638119 pyz…_…(Q) 赛尔号 66466715 1029 造梦西游 44799141 Steam xinger8im pyz1029 Rockstar 邮箱QQ166 Pyz1029 Epic 邮箱QQ166 pyz1029 TapTap 130 vivo 130 1029 GOG 邮箱130 pyz1029 Fun 斗鱼 WX166 虎牙 QQ166 微博 QQ2497 Bilibili 邮箱QQ166 130 pyz1029 喜马拉雅 130 QQ166 WX166 Study 金山词霸 130 CET 邮箱QQ166 130 pyz1029_ Github 邮箱130 pyz1029 Gitee 130 pyz1029 Github与Gitee已关联 聚合图床 Cheese 1029 牛客 130 1029 Autodesk 邮箱130 pyz1029 Others 红手指 QQ166 130 pyz1029 腾达 admin fbn123 小黑盒 WX166 Microsoft 邮箱QQ166 130 pyz1029 摇号 130 pyz200 Apple 130 T…P…2… if(\"pyz200168\"==prompt(\"Password\")) { alert(\"Correct!\"); } else { alert(\"Wrong!\"); location=\"/\"; } Todos GamesMoviesVariety ShowsAnimationsTeleplaysNovelsVideosStudyTodosGoalsTo the moon COC破解版(WX公众号：玄柒阁) 海岛奇兵破解版() 天谕MARVEL(IronMan123·Avengers1234·GuardiansOfTheGalaxy1234) 变形金刚 加勒比海盗 哈利波特 让子弹飞 正义联盟-扎导 风声 环太平洋 全民目击 中国合伙人 斯嘉丽约翰逊《她》 秘密访客 赛车总动员123 功夫熊猫 驯龙高手 老男孩 七剑 哪吒之魔童降世 小丑王牌对王牌 青春德云社 我们的歌 平行时空遇见你 约吧大明星 我想开个店 我去上学啦 青春环游记 姐姐妹妹的武馆 极限挑战 无限歌谣祭 你好生活 五十公里桃花坞柯南 英雄觉醒 B站追番 RO COC 进击的巨人 海绵宝宝 刀剑神域 寄生兽 EVA 环太平洋 全职高手 攻壳机动队 死亡笔记 东京喰种 进击的巨人 学战都市 落第骑士英雄谭 希望的花 领袖之证唐探网剧 司藤 红色RO 庆余年 赘婿骚男去月球 骚男带妹视频易语言(EPL),LUA,VB,VC,汇编 COC大本营LV9~Max-截图 Butterfly主题 Android Studio XML语言 Kotlin 英语四册书单词，词组，句式，笔记 百词斩爱阅读收藏整理 HTML CSS JS SVG Blender MagicaVoxel Python图片转移到Gitee 钢铁侠视频PS，bgm：《陪你去流浪》 迪迦奥特曼台词剪辑 post-迪迦奥特曼，寄生兽，庆余年，唐探三，薛之谦专辑《渡 The Crossing》，明星大侦探，哪吒之魔童降世 MagicaVoxel-Tesseract，Interior 完善Fort背景故事 葫芦侠 MagicaVoxel gitee API MAVEL spaceship LEGO 乐高银护飞船 漫威观影顺序Supercell-COC建模源文件 考研 精通Android Studio 精通Java，C/C++ 精通HTML，CSS，JS 精通MagicaVoxel"},{"title":"About Me","date":"2021-03-16T06:42:27.000Z","updated":"2021-04-10T14:05:03.785Z","comments":true,"path":"About/index.html","permalink":"https://cheeseburgerim.github.io/About/index.html","excerpt":"","text":""},{"title":"Detective Conan","date":"2020-12-17T02:48:20.000Z","updated":"2021-04-10T02:55:24.540Z","comments":false,"path":"DetectiveConan/index.html","permalink":"https://cheeseburgerim.github.io/DetectiveConan/index.html","excerpt":"","text":"国语版 34：在北半球，手表短针指向太阳，与12点之间二分之一的方向是南方； 174：6点半的时候时钟的时针和分针不重合； 570-571：AB型和O型血的父母不会生出O型血的孩子； 美人尖是显性遗传，父母都没有美人尖是不会生出有美人尖的孩子； 伤痕是不会随着年龄增长而改变长度的； 啤酒里放盐(会下沉的颗粒物，盐，沙子等)会产生泡沫； 风筝需要尾巴才能放；"},{"title":"Fort(IM\"F\")","date":"2020-12-08T14:35:56.000Z","updated":"2021-06-18T12:21:40.908Z","comments":false,"path":"Fort/index.html","permalink":"https://cheeseburgerim.github.io/Fort/index.html","excerpt":"","text":"🏠Exterior 🏠Main 🏠Disguise 🏠Interior 🏠Others Exterior Main Original：Tesseract Disguise Interior if(\"pyz200168\"==prompt(\"Password is required here:\")) { alert(\"Correct\"); } else { alert(\"Wrong\"); location=\"/\"; } COC LV13LV11LV10LV9 暂无 Others Images Fort Date 2020.11.28 15 2020.12.13 26 2021/1/8 17 2021/1/25(m) 3 2021/1/28 6 2021/2/3 4 2021/2/7 13 2021/2/20 6 2021/2/26 3 2021/3/1 13 2021/3/14 10 2021/3/24 2 2021/3/26(m) 11 2021/4/6 3 2021/4/9 19 2021/4/28 6 2021/5/4(m) 5 2021/5/9 7 2021/5/16 19 2021/6/4 4 2021/6/8 10 2021/6/18"},{"title":"Gallery","date":"2020-12-30T12:50:59.000Z","updated":"1970-01-01T00:00:00.001Z","comments":false,"path":"Gallery/index.html","permalink":"https://cheeseburgerim.github.io/Gallery/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 漫威 关于漫威的图片 部落冲突 Clash Of Clans 建模 MagicaVoxel 仙境传说 Ragnarok"},{"title":"Good Gifs","date":"2021-03-24T10:47:34.000Z","updated":"2021-04-06T13:03:09.916Z","comments":false,"path":"GoodGifs/index.html","permalink":"https://cheeseburgerim.github.io/GoodGifs/index.html","excerpt":"","text":"以上gif均存放在Gitee个人仓库"},{"title":"Happy Time","date":"2021-03-25T07:42:06.000Z","updated":"2021-03-26T09:15:23.249Z","comments":false,"path":"HappyTime/index.html","permalink":"https://cheeseburgerim.github.io/HappyTime/index.html","excerpt":"","text":"以上视频均转自B站个人收藏"},{"title":"留言板","date":"2021-03-25T08:22:08.000Z","updated":"2021-05-20T12:17:35.502Z","comments":true,"path":"MessageBoard/index.html","permalink":"https://cheeseburgerim.github.io/MessageBoard/index.html","excerpt":"","text":"点击左侧按钮有惊喜哦 !function (e) { function r(r) { for (var n, u, a = r[0], c = r[1], l = r[2], s = 0, p = []; s < a.length; s++)u = a[s], Object.prototype.hasOwnProperty.call(o, u) && o[u] && p.push(o[u][0]), o[u] = 0; for (n in c) Object.prototype.hasOwnProperty.call(c, n) && (e[n] = c[n]); for (f && f(r); p.length;)p.shift()(); return i.push.apply(i, l || []), t() } function t() { for (var e, r = 0; r < i.length; r++) { for (var t = i[r], n = !0, a = 1; a < t.length; a++) { var c = t[a]; 0 !== o[c] && (n = !1) } n && (i.splice(r--, 1), e = u(u.s = t[0])) } return e } var n = {}, o = { 1: 0 }, i = []; function u(r) { if (n[r]) return n[r].exports; var t = n[r] = { i: r, l: !1, exports: {} }; return e[r].call(t.exports, t, t.exports, u), t.l = !0, t.exports } u.e = function (e) { var r = [], t = o[e]; if (0 !== t) if (t) r.push(t[2]); else { var n = new Promise((function (r, n) { t = o[e] = [r, n] })); r.push(t[2] = n); var i, a = document.createElement(\"script\"); a.charset = \"utf-8\", a.timeout = 120, u.nc && a.setAttribute(\"nonce\", u.nc), a.src = function (e) { return u.p + \"static/js/\" + ({}[e] || e) + \".\" + { 3: \"19833bb7\" }[e] + \".chunk.js\" }(e); var c = new Error; i = function (r) { a.onerror = a.onload = null, clearTimeout(l); var t = o[e]; if (0 !== t) { if (t) { var n = r && (\"load\" === r.type ? \"missing\" : r.type), i = r && r.target && r.target.src; c.message = \"Loading chunk \" + e + \" failed.\\n(\" + n + \": \" + i + \")\", c.name = \"ChunkLoadError\", c.type = n, c.request = i, t[1](c) } o[e] = void 0 } }; var l = setTimeout((function () { i({ type: \"timeout\", target: a }) }), 12e4); a.onerror = a.onload = i, document.head.appendChild(a) } return Promise.all(r) }, u.m = e, u.c = n, u.d = function (e, r, t) { u.o(e, r) || Object.defineProperty(e, r, { enumerable: !0, get: t }) }, u.r = function (e) { \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e, \"__esModule\", { value: !0 }) }, u.t = function (e, r) { if (1 & r && (e = u(e)), 8 & r) return e; if (4 & r && \"object\" == typeof e && e && e.__esModule) return e; var t = Object.create(null); if (u.r(t), Object.defineProperty(t, \"default\", { enumerable: !0, value: e }), 2 & r && \"string\" != typeof e) for (var n in e) u.d(t, n, function (r) { return e[r] }.bind(null, n)); return t }, u.n = function (e) { var r = e && e.__esModule ? function () { return e.default } : function () { return e }; return u.d(r, \"a\", r), r }, u.o = function (e, r) { return Object.prototype.hasOwnProperty.call(e, r) }, u.p = \"/\", u.oe = function (e) { throw console.error(e), e }; var a = this[\"webpackJsonpair-conditioner\"] = this[\"webpackJsonpair-conditioner\"] || [], c = a.push.bind(a); a.push = r, a = a.slice(); for (var l = 0; l < a.length; l++)r(a[l]); var f = c; t() }([])"},{"title":"Movie","date":"2021-02-19T04:45:33.000Z","updated":"2021-06-22T08:12:12.230Z","comments":false,"path":"Movie/index.html","permalink":"https://cheeseburgerim.github.io/Movie/index.html","excerpt":"","text":"漫威 Marvel Comic Universe 变形金刚 Transformer"},{"title":"Motto","date":"2021-02-17T12:21:46.000Z","updated":"2021-04-05T11:48:52.828Z","comments":false,"path":"Motto/index.html","permalink":"https://cheeseburgerim.github.io/Motto/index.html","excerpt":"","text":"不知全貌，不予置评 未经他人苦，莫劝他人善 上山的人不要瞧不起下山的人，因为他曾经风光过 下山的人也不要瞧不起上山的人，因为他会爬上来 不要因为一个人的行为而贬低他的作品不要因为一个人的作品而支持他的行为"},{"title":"Category","date":"2020-12-08T13:00:32.000Z","updated":"2021-04-11T01:43:03.126Z","comments":false,"path":"categories/index.html","permalink":"https://cheeseburgerim.github.io/categories/index.html","excerpt":"","text":""},{"title":"Emoji","date":"2021-03-10T12:36:36.000Z","updated":"2021-03-22T15:16:19.251Z","comments":false,"path":"emoji/index.html","permalink":"https://cheeseburgerim.github.io/emoji/index.html","excerpt":"","text":"2021 3/11"},{"title":"Link","date":"2020-12-09T10:59:50.000Z","updated":"2021-05-25T05:43:57.386Z","comments":true,"path":"link/index.html","permalink":"https://cheeseburgerim.github.io/link/index.html","excerpt":"","text":"这是我的友链信息🏠 1234- name: CheeseburgerIM link: https://CheeseburgerIM.github.io/ avatar: https://gitee.com/CheeseburgerIM/imagehosting/raw/master/Image/Home/Avatar.jpg descr: IMF,I’ve got a lot to learn. 🔗如果大佬想加友链，按照格式在下面评论即可🖱️"},{"title":"Tag","date":"2020-12-08T12:57:56.000Z","updated":"2021-04-11T01:41:35.673Z","comments":false,"path":"tags/index.html","permalink":"https://cheeseburgerim.github.io/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2020-12-11T07:10:24.000Z","updated":"1970-01-01T00:00:00.001Z","comments":false,"path":"music/index.html","permalink":"https://cheeseburgerim.github.io/music/index.html","excerpt":"","text":"使用方法請參考插件文档"},{"title":"","date":"2021-06-03T14:06:49.428Z","updated":"2021-06-03T14:06:49.428Z","comments":true,"path":"english/index.html","permalink":"https://cheeseburgerim.github.io/english/index.html","excerpt":"","text":"Catalog DailySentences Composition Vacabulary Structure Phrase Article DailySentences 2021 1/23：The size of your dreams must always exceed your current capacity to achieve them. 1/19：No amount of money ever bought a second of time. 1/7：You can nearly always enjoy something, if you make up your mind firmly that you will. 1/2：But in times of crisis the wise build bridges, while the foolish build barriers. ——《Black Panther》 2020 12/8：As long as there are those that always remember what was, there will invariably be those that are unable to accept what can be. 12/7：Everyone fails at who they’re supposed to be. The measure of a person, of a hero is how well they succeed at being who they are. Composition 2021 5/6 In some countries, governments are encouraging industries and businesses to move out of large cities and into regional areas. Do you think the advantages of this development outweigh its disadvantages? ​ Currently, several countries are faced with markedly mounting population and lack of resources, just to name a few, food, jobs, spaces. Hence, governments are propelling industries and businesses to relocate from big cities to regional areas in an effort to disperse innumerable people. ​ To begin with, there is no denying that the economy of large cities would assuredly be affected by this reaction whereas the motivation of people in regional areas can be elicited with their pressures alleviated. What’s more, they are able to work locally instead of moving into big cities, which is bound to progressively render their hometown prosperous in the long term. ​ As for society, in my point of view, insufficient and invaluable resources subordinate economic recession so that the governments are determined to make this prudent decision, which is of great benefits as a whole. In addition, the chances are that developing countries are capable of transforming into developed countries. ​ Generally speaking, governments and the public are making joint efforts to lead better lives and stride towards marvelous future, in face of which troubles and difficulties pale. As a result, in my perspective, the advantages of this development definitely outweigh its disadvantages. 4/13 People can perform everyday tasks, such as shopping and banking as well as business transactions, without meeting other people face-to-face. What are the effects of this on individuals and society as a whole? ​ Currently, people who opt to perform routine tasks online turn out to dominate the trend in that science and technology develops rapidly. The time has come to figure out the effects of this on us and our society. Admittedly, it couldn’t be more convenient to lead our life like this, which was pretty impossible several years ago. Not only don’t we have to confront others in person, but also some problems of our society, say, traffic jams, are being tackled effectively. Be the situation the former or the latter, we are capable of saving time and effort to relish our fabulous life. In the meantime, our society is certainly the beneficiary in aspects of economy. Convenient as it is, many of us ended up being addicted to that self - centered lifestyle. They became isolated and were getting used to this solitary environment, which indeed posed a serious threat to the operation and efficiency of our society. Scientists made unremitting effort perfect our city but instead rendered us idle and elicited our growing desire. Instead of improving our productivity, we might have wound up damaging the harmony of society. Generally speaking, what we are facing is an unprecedented situation. There are pros and cons of this tendency. Life would be marvelous as long as we made a balance between online and offline and collapsed provided that we considered this convenience nothing beyond temptation. As such, the choice is in our hands. Under no circumstance can we regret our option when we retrospect in the future. 3/24 Some people say that children should obey the rules of their parents and teachers, while other people think children will not be well-prepared for their adult life if they are given too much control. Discuss in both sides and give your opinion. ​ Recently, heated debates on a prevailing topic that whether children should obey the rules of their parents and teachers is negative or positive are right on their way. From my own perspective, it seems like a coin with two sides. ​ Initially, children are not able to make it possible to live a good life without parents or teachers. Hardly a day goes by without a child getting hurt and even killed on account of the disregard of the rules given by parents or teachers, some of which are of great benefits to the safety, sanitary and so forth. As it turns out these sorts of rules would equip us for lifetime provided that we truly obey them when we are young. ​ Additionally, regulations set by parents and teachers are not supposed to be our restrictions, which would wind up pushing rules through children instead of pushing children through rules. Admittedly, it is said that a mounting number of individuals are becoming less independent and impractical with limitations instead of rules and they would suddenly find themselves unprepared to encounter the adult life in future without their parents and teachers, which is exceedingly awful. ​ Ultimately, rules are indeed like a rose with its thorns. It is not what parents and teachers tell children how to do but to teach children how to react and respond to the things they confront after pondering by themselves that really matters. 2020 12/10 Some people say that playing computer games is bad for children in every aspect. Others say that playing computer games can have positive effects on the way children develop. Discuss both views and give your opinion. ​ Recently, heated debates on a prevailing topic that whether playing computer games is negative or positive, particularly for children, are right on their way. From my own perspective, it seems like a coin with two sides. ​ Initially, speaking of the detrimental effect that playing computer games have on children, quite a few people support that computer games would do nothing beneficial to children but to rot their brains, render them shortsighted and deprive them of precious time. Actually, it is understandable that they are concerned that these games are liable to cause slipping grades of their children. Moreover, these games serve no purpose beyond temptation so that children would devote their energy and money to the virtual world and even be addicted, which their parents regard as a serious problem. ​ Nevertheless, there are some people standing by the opinion that playing computer games can have positive effects on the way children develop. For example, children are capable of relieving stress in the school by playing computer games with their friends and classmates, which can also facilitate the relationships between them. In addition, children and even adults are overly fond of the feeling that they can do a large quantity of things in the games that seem pretty impossible in the real world. ​ Ultimately, playing computer games is indeed like a rose with its thorns, but I am in favor of the latter viewpoint. On condition that children can distinguish between hobbies and addictions, I perceive it is advisable to play computer games. Vacabulary A alleviate(~ pressures)/lessen aspire(v.)/aspiration(n.)&amp;? abort&amp;stop apparent/manifest/evident&amp;obvious advent&amp; abundant&amp;many articulate&amp;express clearly authentic? amend(vt.)&amp;correct adverse&amp;bad？ assuredly&amp;indeed? address&amp;deal with? augment&amp;? abound&amp;? EG: Grapes ~ in this farm. affix&amp;attach/stick? apt&amp;proper? alter&amp;change？ advisable&amp;wise? apprehend&amp;think/worry/understand? apprehensive？ apprehension？ atop&amp;on top of accommodate&amp;get accustomed to ample&amp;？ acquire attain B bear brilliant/fabulous/fantastic/marvelous/terrific&amp;great brute&amp;cruel boost? barely&amp;? C conceive？ consequently/hence&amp;as a result condemn/denounce&amp;criticize or blame conquer&amp;overcome criterion/criteria&amp;standard commence(vt.)&amp;start/begin climax/culmination/peak/summit&amp; cardinal&amp;basic？ collapse&amp;? compelling&amp;convincing cherish&amp;treasure? comprehend&amp;understand/consist of? comprehensive&amp;? cohesive&amp;united? considerable(adj.)&amp;big? considerably(adv.)&amp;very? conclusive&amp;？ conversely&amp;instead？ crystal-clear&amp;very clear cease(vi.)&amp;stop? conspicuous&amp;obvious? constitute&amp;? crucial&amp;key? core&amp;? complement collective&amp;? cohesive&amp;united? crowning&amp;the most important？ claim&amp;express？ correlation&amp;connection? consent EG: give you my consent contemplate&amp;ponder，think of？ D delicate/exquisite&amp;perfect daunt&amp;prevent or discourage denounce/condemn&amp;criticize or blame disinterested&amp;公正无私的，客观的 delegate&amp;代表 deficient&amp; definitive/decisive&amp;/决定性的；best/optimum? dramatically&amp;大幅度地，very? devoid(of)&amp;completely lacking of distinguish&amp;? distinguished&amp;? demoralize&amp;discourage/frustrate denote&amp;indicate? defect(n.)/defective(adj.)&amp;? dictate&amp;order，命令? dimension diminish&amp;decrease？ determinant&amp;factor? dominant&amp;? deem&amp;think definitely diverse&amp;various？ distinct&amp; discrepancy&amp;difference? E exquisite/delicate&amp;perfect economize&amp;save essential(of the essence)/momentous/integral/imperative/indispensable&amp;important extensive essence&amp;本质，实质，精髓 evident/manifest/apparent&amp;obvious enormous/immense&amp;big equip? exceedingly&amp;very ensue&amp;follow? EG: A ~ after B exotic(adj.)&amp;foreign? envisage&amp;imagine exhilarate&amp;please/delight/excite exhaustive&amp; enormously&amp;very excessively&amp;badly，very，过分地，非常地? exceptional&amp;excellent? embody&amp;? extend&amp;offer explicit&amp;? exaggerate&amp;overstate? evoke&amp;？ enhance&amp;improve, increase? elite&amp;? elicit&amp;? escalate&amp;become worse or more serious eliminate&amp;get rid of？ enlighten&amp;？ exclusively&amp;particularly？ extremely&amp;very endeavor(to do)&amp;strive? emphasize&amp;？ F fabulous/fantastic/marvelous/brilliant/terrific&amp;great feasible/tangible&amp; fuel&amp;fill (size,amount,quality,etc)fluctuate&amp; fascinate&amp;attract futile&amp;useless facilitate&amp;improve function&amp;? feature&amp;? fuse&amp;combine? forsake&amp;放弃，抛弃，离开？ foe&amp;enemy? fancy&amp;like？ futile&amp;useless? G glamorous&amp;attractive genuine&amp;real? gorgeous&amp;beautiful H hence/consequently&amp;as a result handle/tackle&amp;deal with hitherto&amp;so far，until now harmonious(in harmony)&amp; heterogeneous&amp;? wholesome&amp;healthy halt&amp;stop？ hamper(v.)/hinder(v.)&amp;obstacle? harness&amp;? homogeneous&amp;same？ highlight heterogeneous&amp;a group that consists of many kinds of people? I imprudent&amp;not wise or sensible integral/imperative/indispensable/momentous/essential(of the essence)&amp;important indelible(~ memory)&amp;unforgettable or not removable immortal instantaneous&amp;immediate invaluable&amp;priceless/precious innumerable&amp;too many to be counted immense&amp;extremely large in size or amount? incentive&amp;? illuminate implicit&amp;? illustrate&amp;? EG: ideal irrespective&amp;regardless? incorporate&amp;包含？ incentive(n.)&amp;encourage/stimulus? instruct&amp;teach/help? J K L lessen/alleviate(~ pressures) liable&amp;? likewise&amp;同样地 lest&amp;in case？ M moderately momentous/integral/imperative/indispensable/essential(of the essence)&amp;important marvelous/fabulous/brilliant/terrific/fantastic&amp;great manifest/evident/apparent&amp;obvious mounting&amp;increasing?(mount&amp;increase?) miraculous(miracle) milestone&amp; measurable&amp;important EG: have~impacts/effects on momentary&amp;? multiply&amp;increase rapidly? moreover&amp;besides markedly&amp;?a lot EG: the pace of improvement has slowed ~. massive&amp;big？ mobilize&amp;? merit&amp;feature？ moreover monotonous&amp;boring？ magnificent&amp;great？ marginal&amp;small and not important N nourish&amp;培养，助长(情绪、观点等)；抚养；怀抱(希望) notion&amp;idea nevertheless necessarily notwithstanding noticeable(effect)&amp;obvious? notable&amp;noticable? noteworthy&amp; O ongoing&amp; outright? out…(outnumber) optimum&amp;best? omit&amp;ignore? overall&amp;? optimize&amp;？ ornament&amp;decorate? opt(vi.) opt for&amp;? P precede(v.)/preceding(adj.)&amp;? prudent&amp;wise and sensible picturesque&amp;beautiful ponder&amp;think postpone&amp;delay principal&amp;chief or main preliminary&amp;at the beginning? protest&amp; plentiful&amp; prestige&amp;reputation prominent/remarkable&amp;excellent pale&amp; propel&amp;motivate/encourage perspective&amp;opinion/idea/view/notion peak/climax/culmination/summit&amp; plight&amp;a difficult and sad situation prosperity prosper&amp;n adj 繁荣，兴旺 primarily&amp;mostly，mainly，at first，originally，principally persevere&amp;？ priceless/precious&amp;invaluable preferable(to)&amp;更可取的，更好的，更合适的 promote&amp;improve presumably&amp;probably perplex&amp;confuse？ painstaking/~ly&amp;不辞劳苦的，辛勤的，煞费苦心 perpetual&amp;everlasting/forever/eternal? preclude&amp;prevent? polish&amp;? preface predominant&amp;important? progressive&amp;gradual？ perceive&amp;think，feel，realise？ pursue preferable(to) premise&amp;前提？ premium&amp;expensive? prevail&amp;be popular EG：A ~ed in the 19th century portion&amp;part？ Q R robust&amp;strong and healthy remarkable/prominent&amp;excellent relish&amp;enjoy？ reluctant&amp;not willing to do … resolve(v.)/resolution(n.)&amp;? recede&amp;? respectively&amp;各自，分别 remarkably&amp;very resultant&amp;? reportedly&amp; relevant&amp;? reckless&amp;careless？ retain&amp;remain? reproach&amp;blame/criticize? reckon&amp;think reciprocal&amp;mutual？ respective&amp;？ render&amp;？ radiant&amp;beautiful，光芒四射的，绚丽的 requisite(n./adj.)&amp;需要的，必不可少的，必备的，必需品 S specialize starting/~ly? summit/peak/climax/culmination&amp; speculate&amp;guess/suppose shortcut&amp;? scold&amp;blame resourceful&amp;wise？ significantly&amp;very EG:~ more single+最高级&amp; strive&amp;endeavor? stride? superfluous&amp;redundant surmount&amp;overcome？ substitute&amp;replace? surpass&amp;? splendid&amp;? spectacle&amp;？ surplus&amp;？ superb&amp;excellent spectacular&amp;？ striking&amp;attractive? supreme&amp;? stimulate&amp;encourage？ sublime&amp;? say&amp;for example sensible&amp;wise sane&amp;sensible? simultaneous&amp;happen at the same time? shrewd&amp;clever and smart? streamline&amp;simplify？ T terrific/brilliant/fabulous/fantastic/marvelous&amp;great tangible/feasible&amp; tackle/handle&amp;deal with transcend&amp; triumph&amp;? long-term/short-term tremendous&amp;big/large? tenacious&amp;? thorough&amp;? tact&amp;? EG: trait&amp;feature？ throughout&amp;? terribly&amp;very/badly？ U unprecedented&amp;happen first time utilize&amp;use? utmost&amp;? underlie(过去式:underlay)/underpin&amp;to be the basis or cause of sth. underscore&amp;emphasis EG:~the importance undesirable&amp;upsetting？ ultimate&amp;final? unique&amp;distinct? V venerable&amp;respectable vicinity&amp;the area around a particular place undertake&amp; upcoming&amp;coming soon(adj.) virtuous&amp;? vivid volition&amp;决定，自主，意志力 W whereas(conj.)&amp;although wage(vt.)&amp;进行，进展 EG: The battle is currently being waged on land. wane&amp;decrease？ wholesome&amp;healthy？ X Y Z Structure Make sentences by combining the following groups of words. Use while to introduce information that contrasts with what is conveyed in the main clause. Make changes where necessary. Model: you, an early bird; your roommate, a night owl. -&gt; You may be an early bird while your roommate is a night owl. Complete the following sentences by translating the Chinese into English, using the emphatic sentences structure &quot;It is/was … that/who … &quot;. Model: ______(正是在这里你会真正发现) what learning is about. -&gt; It is here that you will truly discover what learning is about. Make sentences by combining the following groups of words using “not that … but (that) …”. Model: he, often,get up on his own; once in a while, suddenly, have a surge of strength. -&gt; Not that he often gets up on his own, but once in a while he 'll suddenly have a surge of strength. Using the infinitive phrase “to do something” to express purpose. Model: ______(为了弥补这一点), it spent tens of thousands of dollars to give every one of its incoming freshmen a free Apple iPad. -&gt; To compensate (for it), it spent tens of … . Using the structure &quot;do/did not + verb + because … &quot; to express transferred negation. Model: These things happened to these people. It was not because they were lazy or stupid. -&gt; These things did not happen to these people because they were lazy or stupid. 这些事情不是因为他们懒或蠢才发生的。 Use the structure &quot;It used to be + that … &quot; to emphasize a discontinued habit or past situation in contrast to the present. Model: the word hero, reserve, those, perform, acts of distinct courage, beyond, the call of duty. -&gt; It used to be that the word hero was reserved for those who performed acts of distinct courage beyond the call of duty. Using the emphatic sentences structure &quot;participle + prepositional phrase + be &quot;. Model: ______(一半已被水流淹没的是) the car. -&gt; Half submerged in the current was the car. Using the structure &quot;It is/was said/reported, etc. that … &quot;. Model: Cliff Young was said never to keep a single prize. -&gt; It was said that Cliff Young never kept a single prize. said, reported, thought, known, etc. Using “not without” to express affirmative meaning. Model: Of course, participation in competitive teams sports is ______(并非没有危害). -&gt; Of … is not without hazards. Use whereas to suggest that although something is true of on thing, it is not true of another. Model: true, more disengaged students, more likely, work long hours, to begin with; appear working, marginal situation, worse. -&gt; Whereas it is true that more disengaged students are more likely to work long hours to begin with, it appears that working makes a marginal situation worse. Using the &quot;given that … &quot; structure. Model: ______(鉴于一半的大四打工学生…打工都超过20小时的上限). Indications are that a large number of students are at risk of compromising their school careers with their part-time jobs. -&gt; Given that half of all employed seniors … work above the 20-hour limit, indications … jobs. Using “whether or not” or “whether … or not”. Model: ______(不管是否会被发现), dishonesty has an undesirable effect on anyone who practices it. -&gt; Whether discovered or not, dishonesty … it. Using the structure &quot;hardly a day/week/month, etc. goes by without … &quot;. Model: Almost every day a reluctant office worker rides an elevator with someone talking loudly on the cell phone. -&gt; Hardly a day goes by without a reluctant office worker riding an elevator with someone talking loudly on the cellphone. Using the structure &quot;(much) to one’s relief/delight/surprise, etc. &quot;. Model: ______(让我颇感欣慰的是), research shows that I am, indeed, a “normal guy”. -&gt; Much to my relief, research … guy. Using the structure &quot;not so much … as … &quot;. 与其，不如。 Model: Young boys and girls from deeply sensitive alliances, walk and talk together - ______(目的与其说是为了变得更有智慧，不如说是为了分享他们的希望，忧虑和理想，以及为了共同参与对彼此内心世界的挖掘). -&gt; Young … together - not so much to polish their wits as to share their hopes, fears, and ideals, and to join in a kind of mutual discovery of each other’s own inner life. Using “make (no/much/any) sense”. Model: Therefore, there is no sense in criticizing our students. -&gt; Therefore, it doesn’t make any sense to criticize our students. Using “might as well + present perfect” to say that it would not make any difference if you did something else. Model: “______(它们还不如是用中文写的),” he wrote. -&gt; “They might as well have been in Chinese,” he wrote. Using “no matter how/what/where”. Model: Whatever we do in life, we will have a huge advantage if we can read complex ideas and understand their meaning. -&gt; No matter what we do in life, we … meaning. Using the structure “there is little/no doubt + that …”. Model: ______(毫无疑问，上大学能让年轻人接触到新思想和新关系) and helps promote their critical thinking skills. -&gt; There is little doubt that attending college has the potential for exposing young people to new ideas and relationships and … skills. have the potential for … Using the independent structure “with + n. + v.-ing”. Model: We think of infancy before childhood and middle age before old age, and each unique phase brings its own peculiar set of challenges. -&gt; We … age, with each unique phase bringing its own peculiar set of challenges. peculiar: adj, 奇怪的，古怪的；异常的；特有的，特殊的; Using the independent structure “with + n. + prepositional phrase”. Model: Four bamboo cane chairs are sitting on the porch, ______(每把椅子上面都有亮着的灯). -&gt; Four … porch, with lighted lamps in every one of them. Rewrite the following sentences by changing the “if” clause to a “with” phrase to indicate how a certain condition can affect a particular situation. Model: If it’s a casual dating, it relieves much pressure and achieves more equality. -&gt; With casual dating, there’s less pressure and more equality. Using the inverted structure “adj./adv. + as + main clause”. Model: ______(虽然很难), if I want to date - I have to ask guys out! -&gt; Hard as it is, if … out! Using “imperatives + and/or + statements” structure. Here the imperative sentence is similar to an “if” clause. Model: Your failure to pay is unacceptable. ______(马上支付，要不然你会有麻烦). -&gt; Your … unacceptable. Pay immediately or you’ll be in trouble. Using &quot;there is nothing more + adj. + than … &quot; to practice the structure of comparison. Model: To exemplify a parent’s nightmare was much terrifying to me than anything else. -&gt; There was nothing more terrifying to me than exemplifying a parent’s nightmare. exemplify: vt: 是…的典型；例示，举例证明； Using “the more … the more …” structure. Model: If you earned more money, you were the better player, given a total of 100 clicks. -&gt; The more money you earned, the better player you were, given a total of 100 clicks. Using &quot;when it comes to … &quot;. Model: We are told we’re in the “driver’s seat”, ______(谈到组织和规划我们的生活). -&gt; We … seat, when it comes to organizing and planning our lives. Using “would rather + v.”. Model: Monica applied for a job as an administrative assistant in 1971. She was asked whether she preferred working for a male or a female attorney. -&gt; When Monica … 1971, she was asked whether she would rather work for a male or a female attorney. attorney: 代理人；律师； Using the structure &quot;as is the case with … &quot;.同样的情况 Model: When the principles themselves are in question, computer modeling alone is of little value. The same is true of the complex biological systems of human life under study. -&gt; When … value, as is the case with the complex biological systems of human life under study. As is often the case：常有的事 Using the structure “as … as …”. Model: The two nice ladies were ______(如同人们期望的一样在收容所里小心地照顾着我们). -&gt; The … were as attentive to us in the shelter as they were expected. Using the sentence pattern &quot;prefer to do sth. (rather) than do sth.&quot; Model: Firms tended to hire less qualified men. They didn’t want to risk hiring a female lawyer, which was unprecedented. -&gt; Firms prefered to hire less qualified men rather than risk hiring a female lawyer, which was unprecedented. Using the conjunction “as” after a verb to mean that something is true despite what you are saying. Model: But______(无论他怎么尽力去找), none of the regular DJs were available. -&gt; But try as he might, none … available. Using the structure “nothing … as much as”. Model: Water scared me most. -&gt; **Nothing scared me as much as water. ** Using the subjunctive structure &quot;It be/become imperative/essential/crucial/vital/important/necessary that sb. (should) do …&quot; Model: It became______(我必须找到她). -&gt; It became imperative that I find her. Using the parallel structure “it is not … that … ; it is … that …”. Model: Steven isn’t in his present position by any coincidence. Steven’s committed spirit has strengthened him in standing fast against all rejections, prejudice and skepticism and driven him to keep moving onward. -&gt; It is not by any coincidence that Steven is in his present position; It is Steven’s committed spirit that has strengthened him standing fast agains all rejections, prejudice and skepticism and driven him to keep moving onward. stand fast 坚持立场，拒不让步 Using the pattern “as it is” or “as they are”(“as” used as conjunction) meaning “in the present situation sth. is in”. Model: Audrey had a complete lack of ego and accepted and______(欣赏别人的真我). -&gt; Audrey … and appreciated others as they were. Using “as it turned out”. Model: At last, I found that she was offering to let me stay at her flat and even had a friend come show me around the city the next day. -&gt; As it turned out,she … day. Using “take sth. with a laugh/a smile/gratitude/a nod/a deep bow, etc”. Model: those little annoyances, those inefficiencies, and those boring bureaucrats(对…一笑了之). -&gt; Take those bureaucrats with a laugh. Using “be it … or …”, which often introduces an adverbial clause of concession in subjunctive mood. Model: They hurl their passion into their work, no matter whether it is physical like the work of a smith, or more mental like that of a scientist or an artist. -&gt; They … work, be it physical … smith, or more … artist. Using “find onself v.ed/v.ing”, which means “discover or realize that one is in a state or doing something without really intending or planning to”. Model: Then I ______(发现自己在他的店里逗留或隔几天去拜访一下), just to chat with him for the joy he would impart. -&gt; Then I found myself lingering in his store or dorpping in every few days, just … impart. Using “be worth next to nothing”. Model: Death is the punishment for the robbery of coal or wood — human life is now not worth a penny. -&gt; Death … life is now worth next to nothing. Using the sentence pattern “look like + clause”. Model: This little guy______(看起来可以在这饱餐一顿), and the camp had more than enough food. -&gt; This little guy looked like he could use a good meal, and … food. Using “what if …”. Model: But what would happen if, instead, your eyes worked as a “positive feedback” mechanism? -&gt; But what if, instead … mechanism? Using the structure “end up doing something”. Model: Sue knew that in all likelihood, ______(她最终会以车为家). -&gt; Sue … likelihood, **she would end up living in a car. ** in all likelihood 十有八九，多半，可能性很大 Using “admittedly”. Model: To tell the truth, I also did not then go out and get hundreds of practice tests and work through them with my daughter far in to the night, doing whatever it took to get her the A. -&gt; Admittedly, I … A. admittedly (尤用于句首)诚然，无可否认 Using “when the time comes to”. Model: ______(当到了该表现时), Chinese children have a blueprint for success; they know how to compete with the best the world has to offer. -&gt;When the time comes to perform, Chinese … offer. when the time comes to + do when it comes to + doing/n. Using the structure &quot;the time has come for sth.(or for sb./sth. to do sth.)&quot; Model: It was now time to convert our relationship from academic to romantic. -&gt;The time has come for the conversion of our relationship from academic to romantic. Using the phrase “in that” to introduce the reason Model: These forums are unique______(因为它们给视角不同的人提供了一个进行公开、真诚交流的场所). -&gt; These forums are unique in that they provide a venue for those with varying perspectives to have an open and honest dialog. Using the structure &quot;sth. is not about … (Instead)It is about …&quot; Model: Life does not mean maintaining some young and stylish outward costume to hide behind. Instead, it means growing and deepening your soul. -&gt; Life is not about maintaining … behind. It’s about growing … soul. Using the structure &quot;be more than just sth.&quot; Model: The truth is that most men think______(美丽不仅仅来自于口红和香水) and take no notice of these extra details. -&gt; The truth … think beauty is more than just lipstick and perfume and … details. 倒装 独立主格 Phrase A attribute to&amp;ascribe to? adjacent to&amp;next to appear to&amp;seem to adhere(v.)/adherence(n.) to&amp;stick to be/get accustomed to&amp;be/get used to the advent of&amp;…的到来 aspire to do&amp;有志于… advance+a plan/idea/proposal&amp;提出 an abundance of&amp;a lot of? B boil down to&amp;归结于，归功于 have a bearing on&amp;have an effect on/have sth. to do with be bound to do&amp;必定，注定，一定，有责任做某事 be bound up&amp;紧密相连 EG：A and B are inseparable bound up C cure of&amp;？ consist in/of/with(consistent?) be composed/comprised of&amp;be made up of cope with&amp;deal with cling to&amp;stick to cleave to&amp;stick to at one/sth.'s core&amp;在…的核心，骨子里 a chunk of&amp;a lot of conform to? over the course of&amp;在…过程中，在…期间 comply with&amp;? complete with&amp;配有…的，包括…的 EG: So the Nature Conservancy launched a fierce war against the pigs, ~ helicopters and sharpshooters. contrive a clever method&amp;come up with? contribute to strike a chord with&amp;resonate，引起共鸣？ D dedicate to&amp;devote to derive from&amp;from dispose of + something you don’t need (into a bin) devise a plan/idea/notion&amp;come up with? devise a method&amp;come up with? deprive sb. of sth. a diversity of differentiate between A and B/A from B&amp;distinguish? A dwarfed by B&amp;与B相比下，A显得相形见绌 with distinction&amp;excellently? distinguish A from B E exert oneself to do&amp;try one’s to do endeavor to do&amp;try one’s to do embark on(upon)&amp;start to do time+elapse&amp;pass be eligible for&amp;be qualified for？ in an effort to do be equipped with excel in eradicate&amp;completely get rid of? F far from&amp;? EG：~ home/safe/sensible flaw(in)&amp;disadvantage? formulate a plan&amp;come up with a plan filter out&amp;滤除，过滤，get rid of G given that get sb. engaged in… H a heap of&amp;a lot of hang onto&amp;grasp heighten the pleasure&amp;? harness one’s power&amp;？ harness A against B&amp;利用A对抗/解决B？EG：~ one foe against the other. make headway&amp;make progress，取得进展 I be immersed in… incorporate not only A but also B make informed decision&amp;做出明智的选择 J K be keen on L M by no means&amp; a multitude of&amp;a lot of a majority of&amp;mostly，大多数 a mass of&amp;a lot of make one’s way to do? at the mercy of&amp;完全由…支配，任由…摆布？ N be noted for/as&amp;be known/famous for/as O over time&amp;? be obligated to do&amp;be responsible to do? originate in&amp;derive from？ opt for P provided that be prone to (do + sth. bad/suffer from) propose? in principle&amp;原则上，基本上 be proficient in&amp;be good at pit A against B&amp;使A与B竞争，对抗 keep a pulse on sth.&amp;pay attention to sth.? on the pretext of&amp;以…为接口 in a better position to do&amp;更能够做某事，更有能力做某事 a (large) portion of&amp;a part of？ be perceived as&amp;be regarded as？ be projected to do&amp;in order to do within the parameters of…&amp;在…范围内？ propagate (that)&amp;spread an idea… Q R be recognized/reputed as/for&amp;be known as/for rejoice at? in this respect&amp;in this aspect with respect to&amp;as to reach new levels of …&amp;…到达了新的高度 A run rings around B&amp;A明显比B好，胜过 with regard to&amp;关于，至于 make a resolution to do&amp;be determined to do S strive to do&amp;try one’s to do for the sake of take/have/make a stab at&amp;attempt，尝试 subordinate A to B&amp; seize on&amp;?对…大为关注; 抓住（有用的事物）; scale up/down&amp;? stay on track&amp;保持持续前进的状态，坚持正确的道路 in a standoff EG: A is ~ with B/between A and B T tend to do take … into account/consideration take a toll on&amp;对…产生消极影响，对…造成损失 in that&amp;因为 save that&amp;除了 beyond that&amp;除了 U do one’s utmost to do&amp;try one’s to do V A versus B, I chose A over B in the vicinity of&amp; W work one’s way (up) to do? X Y Z Others sb. is held in high regard in the face of in an effort to do&amp;in order to do pros and cons in the first place&amp;at the beginning as the next person&amp;像其他人一样 next to nothing EG：worth ~ at all：加强语气 肯定句：竟然？ 否定句：一点也不 疑问句：到底，究竟 Article 2021 6/3 From HERE We're All Glued to Our Screens With much of the globe now under coronavirus-related restrictions, we have never been so tethered to our screens --for work, to connect with friends, to unwind or to distract ourselves. One new data suggested that adults are spending more than 13 hours a day using screens, a spike up from 10 hours a day a year ago. With children cut off from physically attending school, they are more reliant on laptops and tablets for online lessons and entertainment. And with our new routines likely to have a lot more screen time for the foreseeable future, experts say it’s important to learn how to protect our eyes from suffering as a result. While there is no evidence of long-term eye damage from extended use of smartphones, computer screens or other devices, prolonged use can sometimes lead to blurred vision, eye fatigue, dry or irritated eyes and headaches, according to Moorfield Eye Hospital in London. Dr. Raj Maturi, the clinical spokesperson for the American Academy of Ophthalmology and a retina specialist, called these symptoms “digital vision syndrome.” He, along with the doctors at the Moorfield Eye Hospital, recommended a 20-20-20 approach --for every 20 minutes spent at a screen you must take a break and look 20 feet in front of you for 20 seconds. “When you are looking at a close target, your eyes are just training that one muscle at all time, and looking into the distance can relieve it,” he said. 4/29 From HERE Surfing the Internet in Class Harms Academic Performance Surfing the Internet during class doesn’t just steal focus from the educator; it also hurts students who are already struggling to grasp the material. A new study from Michigan State University, though, argues that all students — including high achievers — see a decline in performance when they browse the Internet during class for non-academic purposes. To measure the effects of Internet-based distractions during class, researchers evaluated 500 students taking an introductory psychology class at Michigan State University. Researchers used ACT scores as a measure of intellectual aptitude. Because previous research has shown that people with high intellectual abilities are better at filtering out distractions, researchers believed students with high ACT scores would not show a significant decrease in performance due to their use of digital devices. But students who surfed the web during class did worse on their exams regardless of their ACT score, suggesting that even the academically smartest students are harmed when they’re distracted in class. College professors are increasingly raising alarm bells about the effects smartphones, laptops, and tablets have on academic performance. One 2013 study of college students found that 80% of students use their phones or laptops during class, with the average student checking their digital devise 11 times in a typical class. A quarter of students report that their use of digital devices during class causes their grades to suffer. Professors sometimes implement policies designed to minimize students’ use of digital devices, and some instructors even confiscate tablets and phones. In a world where people are increasingly dependent on their phones, though, such strategies often fail. One international study found that 84% of people say they couldn’t go a day without their smartphones. Until students are able to resist the pull of social networking, texting, and endlessly surfing the web, they may continue to struggle in their classes. 4/13 From HERE Krill Fishing Poses Serious Threat to Antarctic Ecosystem Industrial fishing for krill in the unspoiled waters around Antarctica is threatening the future of one of the world’s last great wildernesses, according to a new report. The study by Greenpeace analysed the movements of krill fishing vessels in the region and found they were increasingly operating “in the immediate vicinity of penguin colonies and whale feeding grounds”. It also highlights incidents of fishing boats being involved in groundings, oil spills and accidents, which posed a serious threat to the Antarctic ecosystem. The report, published on Tuesday, comes amid growing concern about the impact of fishing and climate change on the Antarctic. A global campaign has been launched to create a network of ocean sanctuaries to protect the seas in the region and Greenpeace is calling for an immediate halt to fishing in the areas being considered for sanctuary status. Frida Bengtsson, from Greenpeace’s Protect the Antarctic campaign, said: “If the krill industry wants to show it’s a responsible player, then it should be voluntarily getting out of any area which is being proposed as an ocean sanctuary, and should instead be backing the protection of these huge tracts of the Antarctic.” A global campaign has been launched to turn a huge tract of Antarctic seas into ocean sanctuaries, protecting wildlife and banning not just krill fishing, but all fishing. One was created in the Ross Sea in 2016, another reserve is being proposed in a vast area of the Weddell Sea, and a third sanctuary is under consideration in the area west of the Antarctic Peninsula — a key krill fishing area. The Commission for the Conservation of Antarctic Marine Living Resources (CCAMLR) manages the seas around Antarctica. It will decide on the Weddell Sea sanctuary proposal at a conference in Australia in October, although a decision on the peninsula sanctuary is not expected until later. Keith Reid, a science manager at CCAMLR, said that the organisation sought “a balance between protection, conservation and sustainable fishing in the Southern Ocean.” He said although more fishing was taking place nearer penguin colonies it was often happening later in the season when these colonies were empty. “The creation of a system of marine protected areas is a key part of ongoing scientific and policy discussions in CCAMLR,” he added. &quot;Our long-term operation in the region depends on a healthy and thriving Antarctic marine ecosystem, which is why we have always had an open dialogue with the environmental non-governmental organisations. “We strongly intend to continue this dialogue, including talks with Greenpeace, to discuss improvements based on the latest scientific data. We are not the ones to decide on establishment ofmarine protected areas, but we hope to contribute positively with our knowledge and experience.” 4/12 From HERE Antarctica's King Penguins Could Disappear Rising temperatures and overfishing in the pristine waters around the Antarctic could see king penguin populations pushed to the brink of extinction by the end of the century, according to a new study. The study’s report states that as global warming transforms the environment in the world’s last great wilderness, 70 percent of king penguins could either disappear or be forced to find new breeding grounds. Co-author Céline Le Bohec, from the University of Strasbourg in France, warned: “If there’re no actions aimed at halting or controlling global warming, and the pace of the current human-induced changes such as climate change and overfishing stays the same, the species may soon disappear.” The findings come amid growing concern over the future of the Antarctic. Earlier this month a separate study found that a combination of climate change and industrial fishing is threatening the krill population in Antarctic waters, with a potentially disastrous impact on whales, seals and penguins. But today’s report is the starkest warning yet of the potentially devastating impact of climate change and human exploitation on the Antarctic’s delicate ecosystems. Le Bohec said: “Unless current greenhouse gas emissions drop, 70 percent of king penguins —1.1 million breeding pairs —will be forced to relocate their breeding grounds, or face extinction by 2100.” King penguins are the second-largest type of penguin and only breed on specific isolated islands in theSouthern Ocean where there is no ice cover and easy access to the sea. As the ocean warms, a body of water called the Antarctic Polar Front — an upward movement of nutrient-rich sea that supports a huge abundance of marine life — is being pushed further south. This means that king penguins, which feed on fish and krill in this body of water, have to travel further to their feeding grounds, leaving their hungry chicks for longer. And as the distance between their breeding grounds and their food grows, entire colonies could be wiped out. Le Bohec said: &quot;The plight of the king penguin should serve as a warning about the future of the entire marine environment in the Antarctic. Penguins, like other seabirds and marine mammals, occupy higher levels in the food chain and they are what we call bio-indicators of their ecosystems.&quot; Penguins are sensitive indicators of changes in marine ecosystems. As such, they are key species for understanding and predicting impacts of global change on Antarcticand sub-Antarctic marine ecosystems. The report found that although some king penguins may be able to relocate to new breeding grounds closer to their retreating food source, suitable new habitats would be scarce. Only a handful of islands in the Southern Ocean are suitable for sustaining large breeding colonies. 4/7 From HERE Original From https://www.smh.com.au/ Attitude Can Be a Powerful Mental Tool Last year, a child was born at a hospital in the UK with her heart outside her body. Few babies survive this rare condition, and those who do must endure numerous operations and are likely to have complex needs. When her mother was interviewed, three weeks after her daughter’s birth, she was asked if she was prepared for what might be a daunting task caring for her. She answered without hesitation that, as far as she was concerned, this would be a “privilege”. Rarely has there been a better example of the power of attitude, one of our most powerful psychological tools. Our attitudes allow us to turn mistakes into opportunities, loss into the chance for new beginnings. An attitude is a settled way of thinking, feeling and/or behaving towards particular objects, people, events or ideologies. We use our attitudes to filter, interpret and react to the world around us. You weren’t born with attitudes; rather they are all learned, and this happens in a number of ways. The most powerful influences occur during early childhood and include both what happened to you directly, and what those around you did and said in your presence. As you acquire a distinctive identity, your attitudes are further refined by the behavior of those with whom you identify — your family, those of your gender and culture, and the people you admire, even though you may not know them personally. Friendships and other important relationships become increasingly important, particularly during adolescence. About that same time and throughout adulthood, the information you receive, especially when ideas are repeated in association with goals and achievements you find attractive, also refine your attitudes. Many people assume that our attitudes are internally consistent, that is, the way you think and feel about someone or something predicts your behavior towards them. However, many studies have found that feelings and thoughts don’t necessarily predict behavior. In general, your attitudes will be internally consistent only when the behavior is easy, and when those around you hold similar beliefs. That’s why, for example, many say they believe in the benefits of recycling or exercise, but don’t behave in line with their views, because it takes awareness, effort and courage to go beyond merely stating that you believe something is a good idea. One of the most effective ways to change an attitude is to start behaving as if you already feel and think the way you’d prefer to. Take some time to reflect on your attitudes, to think about what you believe and why. Is there anything you consider a burden rather than a privilege? If so, start behaving — right now — as if the latter is the case. 4/5 From HERE What Does It Mean To Be Human? In a few decades, artificial intelligence (AI) will surpass many of the abilities that we believe make us special. This is a grand challenge for our age and it may require an “irrational” response. One of the most significant pieces of news from the US in early 2017 was the efforts of Google to make autonomous driving a reality. According to a report, Google’s self-driving cars clocked 1,023,330 km, and required human intervention 124 times. That is one intervention about every 8,047 km of autonomous driving. But even more impressive is the progress in just a single year: human interventions fell from 0.8 times per thousand miles to 0.2, a 400% improvement. With such progress, Google’s cars will easily surpass my own driving ability later this year. Driving once seemed to be a very human skill. But we said that about chess, too. Then a computer beat the human world champion, repeatedly. The board game Go took over from chess as a new test for human thinking in 2016, when a computer beat one of the world’s leading professional Go players. With computers conquering what used to be deeply human tasks, what will it mean in the future to be human? I worry about my six-year-old son. What will his place be in a world where machines beat us in one area after another? He’ll never calculate faster, never drive better, or even fly more safely. Actually, it all comes down to a fairly simple question: What’s so special about us? It can’t be skills like arithmetic, which machines already excel in. So far, machines have a pretty hard time emulating creativity, arbitrary enough not to be predicted by a computer, and yet more than simple randomness. Perhaps, if we continue to improve information-processing machines, we’ll soon have helpful rational assistants. So we must aim to complement the rationality of the machine, rather than to compete with it. If I’m right, we should foster a creative spirit because a dose of illogical creativity will complement the rationality of the machine. Unfortunately, however, our education system has not caught up to the approaching reality. Indeed, our schools and universities are structured to mould pupils to be mostly obedient servants of rationality, and to develop outdated skills in interacting with outdated machines. We need to help our children learn how to best work with smart computers to improve human decision-making. But most of all we need to keep the long-term perspective in mind: that even if computers will outsmart us, we can still be the most creative. Because if we aren’t, we won’t be providing much value in future ecosystems, and that may put in question the foundation for our existence. 2/24 From HERE Puppy Love For some people, there’s no better companion than man’s best friend –a dog. This four-legged canine can bring comfort and joy and provide much-needed exercise for you when it needs walkies! This probably explains why dog ownership increased last year because people spent more time at home during the coronavirus pandemic lockdown. It was demand for puppies in particular that saw the biggest increase. Who couldn’t resist their playful personalities, adorable eyes, and super-soft coats? However, as demand for a new puppy increased, so did the price tag. Popular breeds, such as Cockapoos and Cocker Spaniels, saw even sharper price increases, and puppies have been selling for £3,000or more. Animal welfare charities fear that high prices could encourage puppy farming, smuggling or dog theft. But despite some new owners purchasing a dog legally, maybe from a rescue centre or registered breeder, they’ve proved to be ill-prepared for life with a new pet, and the pet itself has found it hard tocome to terms with life in a new home. Looking to the future, there are concerns about the welfare of these much-loved pets. Ian Atkin, manager of the Oxfordshire Animal Sanctuary in the UK, told the BBC: “At the moment, the dogs are having a great time, but separation anxiety could still surface when people go back to work.” And Claire Calder from the UK’s Dogs Trust rescue charity says “the economic situation also means that some people may find they can’t afford to look after a dog.” The message is not to buy a puppy in haste and to pick one that fits into your lifestyle. 2/23 From HERE Two Apples A sweet little girl was holding two apples in both hands. Her mum came in, and with a smile, softly asked her daughter: “Sweetie, could you give your mum one of those apples?” The girl looked up at her mum for a few seconds, then suddenly took a quick bite of one apple, and then a quick bite of the other. The mum felt the smile on her face freeze. She tried hard not to reveal her disappointment. Then the little girl handed one of her bitten-into apples to her mum, and said: “Here you are, Mummy. This one is much sweeter.” No matter who you are, how experienced you are, or how knowledgeable you think you are, don’t pass judgment without giving others the chance to explain themselves first. What you first see, may not be the reality. Never conclude for others. 2/22 From HERE Everyone Has a Story in Life A 24-year-old boy seeing out from the train’s window shouted, “Dad, look the trees are going behind!” Dad smiled and a young couple, sitting nearby, looked at the 24-year-old’s childish behavior with pity. Suddenly he again exclaimed, “Dad, look the clouds are running with us!” The couple couldn’t resist and said to the old man, “Why don’t you take your son to a good doctor?” The old man smiled and said, “I did and we are just coming from the hospital. My son was blind frombirth. He just got his eyes today.” Every single person on the planet has a story. Don’t judge people before you truly know them. The truth might surprise you. 2/12 From HERE Why Do We Laugh? People from all cultures laugh, although we may laugh at different things. Humans start laughing as early as 3 months into life, even before we can speak. So, the ubiquitous nature of laughter suggests that it must serve a purpose, but what? Laughter serves a social function. It is a way for us to signal to another person that we wish to connectwith them. We’re more likely to laugh in a group. Young children between the ages of 2.5 and 4 were found to be eight times more likely to laugh at a cartoon when they watched it with another child. Evolutionarily speaking, this signal of connection likely played an important role in survival. Upon meeting a stranger, we want to know: What are your intentions with me? And who else are you aligned with? Another theory is that laughter may be a replacement for the act of grooming each other. Grooming another is a behavior seen in primates and requires trust and investment of time. As our communities got larger, we couldn’t all go around grooming each other to establish bonds. But laughter, like the commitment offered through grooming, is hard to fake; unlike grooming, it can be done in a larger group. When we genuinely laugh, we signal that we are comfortable and feel like we belong. There are also a multitude of physical health benefits to laughter. Laughter can increase your oxygen intake, which can in turn stimulate your heart, lungs, and muscles. The act of increasing and then decreasing our heart rate through laughter is also ultimately calming and tension-relieving. So laughter signals cooperation, a key aspect of human survival, and promotes a healthier body to boot. 2/1 From HERE What Makes Us Afraid？ What are the things that scare you: snakes, spiders or creepy crawlies? Or maybe you have a fear of heights or visiting the dentist. Although some of us just get scared or a bit nervous about these things, for others it can cause an irrational reaction that can’t be controlled –something we call a phobia. It occurs when someone develops an exaggerated or unrealistic sense of danger about a situation or object. Sometimes it’s good to be aware of the possible dangers from things. Our brain alerts us to the risks that might lie ahead, but then we often rationalise the risks and overcome them. But phobias are stronger than just fears. Clinical psychologist Warren Mansell says: “An area called the amygdala in the brain is recognising a threat and preparing your body for fight or flight.” With a phobia, your breathing gets quicker, your pulse speeds up, you sweat, and your brain is unable to control these reactions. But where does a phobia come from? Lauren Rosenberg, a fear and phobia expert, says: “Phobias usually are a copy behaviour from a higherauthority, like a parent or teacher, or something you have learnt from your own experience.” Or a trauma from a past event that comes back to haunt you. There are many different complex phobias some people suffer from, such as agoraphobia –triggered by being away from home, social anxiety disorder –feeling anxious in social situations, and iatrophobia –fear of doctors. But how can they be overcome? Cognitive behavioural therapy is one option, where you gradually get used to whatever it is you fear. Lauren Rosenburg says she likes to work with people to clear their subconscious memory and help them breathe. But if you do have a phobia, continually trying to avoid what you’re afraid of is likely to make the situation worse, so it’s a good idea to find help to overcome it. 1/31 From HERE Escapism，Procrastination，and the Dark Playground We often try to escape realities that seem overwhelming or that we don’t like. In a study from StudyMode, feeling overwhelmed and not liking the work are the top 2 reasons college students procrastinate. Because students do not like the work they are assigned to do, or don’t know where to start, instead they divert their attention and escape into things they would rather be doing or are easier to understand. In a post from two weeks ago, The Internet: Procrastination Station, it was noted that TV and movies, along with social media are the top two avenues used for procrastination among college students. However, indulging fantasy or our sense of instant gratification is a way to escape reality. And this takes us to a dark place; a place where we play and partake in unearned leisure activities. This place is named the dark playground. In the dark playground, we choose fun over work and responsibility and as a result that “fun” is clouded by guilt. The dark playground is important in appropriately giving escapism a home in relation to procrastination. Say, for example, if you were to spend 3 hours watching TV series when you should be writing an essay, that’s where escapism becomes procrastination and where guilt is wrapped in fun in the dark playground. As long as you are trying to avoid something, a part of you is vibrating at a level of shame or guilt. To avoid entering the dark playground, you need to confront what you are trying to escape from. Face it and get it done. This is the key to overcome the tricky beast, procrastination. 1/30 From HERE Comparison Is the Thief of Joy In our life, we all try to get better every day. We all set dreams in our life. To win the life race, we work hard and with the time we finally accomplish it. We become happy and celebrate it. It is all right and it should be in that way. But our happiness last for very short time when we start comparing the things with others. We all want to get ahead among friends, colleagues, and even among family. If today you are happy just because you have more than others then be ready to lose your happiness because it will start vanishing when you see someone else having more than you. You spent months or may be even years to get where you are. But it will only take a few days to end your feeling of joy if it is based on what others have. Actually you can never compare yourself with others. You may know yourself completely. You may be aware of what you have and how you got that. But you can never know what circumstances someone else has and how he got that. You can compare one factor but you never even know other factors. What you see is not always the whole thing. Respect every one for what he is and love yourself for whatever you are. If you still want to compare, compare with yourself. Think what you have done better today than you did yesterday. Keep yourself growing and celebrate your victories without comparing them to anyone else. It is good to get inspired from someone you think is better than you. But do not get caught by comparison. Always remember that you are absolutely unique. Just like everyone else. 1/25 From HERE How to Break Bad Habbits Habits are ways of dealing with issues in your environment. You often do not think about them. James Clear, in his book Atomic Habits, describes a four-step process by which habits are made. These steps are cue, craving, response, and reward. A cue is a signal. It tells your brain to do something: to begin a behavior. A craving is a desire for something. The response, or reaction, is the habit that you perform. The response gives you a reward. Imagine you are studying English. Perhaps you are learning new words or expressions. But then you feel the need to check your phone. You return to your studies, only to look again at your phone a short time later. This process, when repeated many times, could reduce your ability to learn new material. It is what you might call a bad habit –a custom or repeated action that has a negative effect on you or your goals. James Clear notes that to break bad habits, you need to think about each step in the habit-making process. In the cell phone example, the cue is seeing the cell phone. The craving is the desire or urge to check your phone. The response is checking your phone. The reward might be seeing something interesting on social media, for example. To break a habit, he writes, you should think about making the bad habit invisible, unattractive, difficult and unsatisfying. To make your phone invisible, you could hide it away. To make it unattractive, you could think about why it is a good idea to stop checking the phone. To make phone use difficult, you can increase the space between you and your phone. To make your phone unsatisfying, you could make a habit contract. The important thing to remember is that people can change their habits. Habit changes take time. But with patience, planning, and repetition, you can do it. 1/7 From HERE The Seasons of Life There was a man who had four sons. He wanted his sons to learn to not judge things too quickly. So he sent them each on a quest, in turn, to go and look at a pear tree that was a great distance away. The first son went in the winter, the second in the spring, the third in the summer, and the youngest son in the fall. When they had all gone and come back, he called them together to describe what they had seen. The first son said that the tree was ugly, bent, and twisted. The second son said no — it was covered with green buds and full of promise. The third son disagreed. He said it was laden with blossoms that smelled so sweet and looked so beautiful; it was the most graceful thing he had ever seen. The last son disagreed with all of them; he said it was ripe and drooping with fruit, full of life and fulfilment. The man then explained to his sons that they were all right, because they had each seen but one season in the tree’s life. He told them that you cannot judge a tree, or a person, by only one season, and that the essence of who they are — and the pleasure, joy, and love that come from that life — can only be measured at the end, when all the seasons are up. If you give up when it’s winter, you will miss the promise of your spring, the beauty of your summer and fulfilment of your fall. Don’t judge a life by one difficult season. Don’t let the pain of one season destroy the joy of all the rest. 2020 12/13 From HERE Why Is It So Hard to Put Down Our Phones? How many times have you picked up your phone and looked at something in the last hour? The average Brit checks their screen every 12 minutes, according to the latest research. You might find yourself checking your phone at the slightest feeling of boredom, purely out of habit. App developers are not relying on you to come to them whenever you have a bit of downtime, they want to grab your attention. For example, push notifications make sure you keep picking up your phone to see what the announcement is and to see what you may have missed. There may be something new and enticing for us to engage with, or we may have received lots of likes for a social media post. When we do get a like, a follower, comment or share of our post, it excites the brain and produces a chemical which you may have heard of called dopamine. This is a chemical that provides a “feel-good” response to these rewards. Because it feels good, we are tempted to repeat the activity that created the good feeling. This loop is one of the biggest reasons why we are checking our phones every 12 minutes. So, how can we break the loop so that real life does not pass us by? The first is to turn off all notifications on your phone so that you are not distracted or tempted by the alluring messages. Next is to put your phone out of sight. This is particularly helpful if you are revising or have a project to get done. Finally, look for and create opportunities for gaining a dopamine hit in other ways, for example through exercise or music."}],"posts":[{"title":"数字逻辑与数字系统-Summary","slug":"MLAMS/MLAMS-Summary","date":"2021-06-23T04:33:15.000Z","updated":"2021-06-23T04:34:49.382Z","comments":false,"path":"2021/06/23/MLAMS/MLAMS-Summary/","link":"","permalink":"https://cheeseburgerim.github.io/2021/06/23/MLAMS/MLAMS-Summary/","excerpt":"","text":"Summary","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"数字逻辑与数字系统-Lab5","slug":"MLAMS/MLAMS-Lab5","date":"2021-06-22T07:47:55.000Z","updated":"2021-06-22T07:58:13.719Z","comments":false,"path":"2021/06/22/MLAMS/MLAMS-Lab5/","link":"","permalink":"https://cheeseburgerim.github.io/2021/06/22/MLAMS/MLAMS-Lab5/","excerpt":"","text":"实验五 单周期MIPS处理器设计与实现 实验资料 实验源码","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"形式化方法-笔记","slug":"FSUZ","date":"2021-06-12T05:42:43.000Z","updated":"2021-06-19T12:21:07.880Z","comments":false,"path":"2021/06/12/FSUZ/","link":"","permalink":"https://cheeseburgerim.github.io/2021/06/12/FSUZ/","excerpt":"","text":"Introduction Z语言 定义 Z语言是一种用“数学文字”或“数学符号”来描述计算机系统的规范化语言，它不但能应用于计算机硬件系统，而且也特别适用于计算机软件系统，Z语言描述“做什么”而不涉及“怎么做”，只对目标软件系统进行功能描述。实际上，Z语言仅仅是一套规定的数学符号，使用Z语言所写的“程序”是对计算机软件或硬件系统的一种抽象化设计。所以，利用Z语言写出来的内容不是计算机程序，更不是可以编译而生成能够在计算机上运行的代码。利用Z语言写出来的内容不是让计算机运行的，而是供人理解和分析的。用户可以通过这些内容去理解计算机系统的模块、数据类型、过程、函数、对象、类等，进而对计算机系统的行为、结构、逻辑进行分析、验证、改进、测试等。 特征 形式化描述语言Z指的是著名数学家Zermelo，它是使用最广泛的一种形式化描述语言，在软件产业的一些大型项目中已经获得成功的应用，Z以带等词的一阶谓词逻辑ZF（Zermelo-Fraenkel，蔡梅罗-弗兰科尔）公理集合论为主要数学基础。在Z中有两种语言：数学语言和模式（Schema）语言。数学语言用来描述系统的各种特征：对象及其之间的关系。模式语言是一种半图形化的语言，它用来构造、组织形式化说明的描述、整理、封装信息块并对其命名以便可以重用这些信息块。通常，形式化说明的可读性都不太好，但由于Z采用半图形化的模式语言，能用一种比较直观、有条理的方式来表达形式化说明，这就改善了可读性。 应用 Z语言是由牛津大学程序设计研究小组开发的一种形式语言，之后该小组与IBM的Hursley实验室合作，将Z语言用于IBM客户信息控制系统(Customer Information and Control System,CICS)的开发，使得最终的产品质量得到了全面的提高，所监测出的错误数量大大减少，并且整体开发费用降低了9%。在ISO指导下的国际标准化Z工作于2002年完成。 Sets Types 一个集合是指若干组成部分的集合，它们也被叫做元素或成员； 集合中所有元素的值都有一些共通点，称这些元素是相同类型的； 类型的作用体现在两方面： 避免了数学悖论； 它允许检查关于集合的声明是否有意义。(it allows checks to be made that statements about sets make sense.) 通过计算机软件自动检查Z语言语句的连贯性，与对自然语言的拼写和语法的检查方法相同。 The built-in type Integer Integer可以在Z语言中直接使用，不需要显式声明，用符号Z表示 它包括所有的整数 …,-3,-2,-1,0,1,2,3,… The standard set Natural 用N表示，集合中的元素为非负整数 N1代表自然数 Operations on integers + addition - subtraction * multiplication div division mod modules Numerical relations = equal to ≠ not equal to ＜ less than ≤ less than or equal to ＞ greater than ≥ greater than or equal to Basic types 基本类型也被称为给定类型 声明基本类型时不需要关心如何表示其中的元素 For Example： [REGISTRATION] the set of all possible car registrations [PERSON] the set of all persons 可以在一行声明多个类型 [REGISTRATION, PERSON] 总的来说，基本类型的范围应该尽可能地广泛。此外，应保证该类型的元素具有唯一性。(Basic types should be chosen to be as widely encompassing as possible. Furthermore, it should be assumed that the elements of the type are uniquely identifiable.) Free types 有时可以把一个类型的所有元素列出来 可以通过自由类型来实现 自由类型的一般形式为 freeType ::= element1 | e2 | e3 | … | en For Example： REPONSE ::= yes | no STATUS ::= inUse | free | onHold | outOfOrder Declaring variables 每个变量必须要先声明，意思是必须明确说明这个变量的类型 For Example： chauffeur：PERSON 表示chauffeur的类型是PERSON Single value from a type 一个类型中只有一个取值 For Example： homeland：EU Set values 可以通过把值列在大括号内来给集合赋值 benelux={B, NL, L} 大括号内元素的顺序不影响集合的值 集合中每个元素只会出现一次 The empty set 当集合中没有元素时，称该集合为空集 可用 “∅” 或 “{}” 来表示 Singleton set 当集合中只包含一个元素，称该集合为单元素集 For Example：{GB} Range of integers m…n(m和n为整数)表示包括m到n所有整数的集合 如果m&gt;n，则为空集 For Example： Operators Equivalence = Non-equivalenc ≠ Membership ∈ Non-membership ∉ Validity of membership test Size, cardinality 集合中元素个数称为集合的大小或集合的基数 For Example： Powersets P 一个集合的幂集为包含这个集合所有子集的集合 S的幂集写作 “PS” For Example： 幂集中元素的个数 #(PS)=2#S Set inclusion ⊆ Union ∪ Intersection ∩ Difference \\ Distributed union Distributed intersection Disjoint sets 表示不相交的集合 对于两个集合来说很容易表示，S∩T=∅ Summary of notation Using sets to describe a system - a simple example Logic Negation ┐ Conjunction ∧ Disjunction ∨ Implication ⇒ P⇒Q等价于┐P∨Q Equivalence ⇔ De Morgan’s laws Summary of notation The example extended Schemas Schemas schema的一般形式如下 线性schema表示为 &quot;==&quot;表示代表 S==[a,b:N|a&lt;b] 用schema表示如下 全局schema Schema calculus 模式可以被视为单位，并通过各种操作符进行操作，这些操作符类似于逻辑操作符。(schemas can be regarded as units and manipulated by various operators that are analogous to the logical operators) Decoration 当一个schema的名字S被标记为S’，表示一些操作被执行后的schema For Example： Inclusion == Schema conjunction Schema disjunction Delta convention 当一个schema的名字S被标记为ΔS，表示一些操作执行前后的约束 Xi convention 当一个schema的名字S被标记为ΣS，表示一些操作执行前后的状态相同 Decoration of input and output variables 输入用&quot;?&quot;标记 输出用&quot;!&quot;标记 For Example： Further operations on schemas Renaming 一般形式如下 For Example： given then gives Hiding Projection Schema composition S与T的composition表示为 “S;T” 表示先做S，再做T Overall structure of a Z specification document Z规范文件由Z符号的数学文本组成，与自然语言的解释文本交错排列。解释文本应该用问题来表达，不应该直接引用数学公式。只有在作为Z语言教程的文件中才会打破这一规则。(A Z specification document consists of mathematical text in the Z notation, interleaved with explanatory text in a natural language. The explanatory text should be expressed in terms of the problem and should not refer directly to the mathematical formulation. This rule is broken only in the case of documents intended as tutorials on Z. ) Sections of a Z document Predicates and quantifiers Introduction 约束是取决于数值的逻辑表达式 当取值给定时约束就变成了一个命题 Quantifiers 约束可以使用量词来给出命题 Universal quantifier ∀ 一般形式如下 有时predicate可以省略 For Example： Existential quantifier ∃ 一般形式如下： For Example： 其中Even(x)的功能是判断x是否为偶数 Unique quantifier ∃1 唯一量词与存在量词类似，唯一的区别是唯一量词表达的是只有一个值可以使得约束条件为真 For Example： Counting quantifier Set comprehension 之前给集合赋值时是通过列出所有元素 也可以通过给定条件来给集合赋值，集合中的元素是符合条件的所有元素 一般形式如下 For Example： 给出一个无限集，包含所有偶数 { … -8, -6, -4, -2, 0, 2, 4, 6, 8 … } Ranges of numbers Relationship between logic and set theory Summary of notation Relations A relation is a set 目前考虑的都是单类型实例，这就意味着形式不可能过于复杂。现在需要的是将一个集合映射到另一个集合的方法。这可以通过关系来完成，基于笛卡尔乘积。 Cartesian product(笛卡尔乘积) Relations Declaring a relation ↔ Maplets |→ Membership 判断一对值是否有关，只需要判断这对值或maplet是否属于这个关系 Infix relations Domain and range Domain 大多数情况下，一个关系只会涉及到source的子集。这个子集被称作domain(定义域)，写作 “dom” Range 大多数情况下，一个关系也只会涉及到target集合的子集。这个子集被称作range(值域)，写作 “ran” Examples Relational image 从source集合得到target集合 Constant value for a relation 有一些关系中含有常量。如果这个量已知，可以通过定理定义给出。 Restriction 还有更多的运算符可用于限制一个关系 Domain restriction ◁ Range restriction ▷ Domain subtraction ◁ Range subtraction ▷ Example of restriction Composition Forward composition Backward composition Forward composition的另一种写法 Repeated composition Example 当不同国家有共同的边界时，通过关系borders连接 当两个国家都与第三个国家有borders的关系时，可以进行关系合成 Transitive closure 传递闭包 传递闭包的一般格式为 x R+ y，表示x与y间的关系是由关系R重复组合而成 Identity relation Identity relation is the one in which every elements maps to itself only. The rule for identity relation is given below. “Every element is related to itself only” 所有的元素只与自己有关 Reflexive transitive closure 与传递闭包的区别是，组合关系=R+∪ id X Inverse of a relation if x R y then y R~ x Examples Definitions given pyz father pyq ∩ pyz mother clx Parent x parent {f, m} means x has f and m as parent so giving pyz parent {pyq, clx} Sibling 表示除自己外的兄弟姐妹 Ancester Summary of notation Funtions A function is a relation Definition 在编程语言中函数是一个方法，它规定了一种产生结果的处理过程 在Z语言中，函数是一种数据结构 函数是关系的一种特殊情况，定义域中的每个值唯一对应值域中的某个值 定义域有限的函数也叫做映射 定义域对值域，可以多对一，不可以一对多 Examples of functions 每个人和身份证号是一一对应的关系 每个人只有一个母亲，但是可能有几个人的母亲是相同的 Function application 所有与关系有关的概念都可以应用到函数中 对于给定的一个x值，在值域中最多只能有一个值与之对应 应用到函数中的前提是x必须在定义域中 Partial and total functions Definition 上面例子中的函数只是一部分，部分source集中的值并不在函数的定义域中 total函数表示，任何集合X中的值x，f x都有意义。即source集就是函数的定义域 Examples of total functions 函数age：PERSON型指向N型，这是一个total函数，因为每个人都有年龄 同理，函数hasMother：PERSON型指向PERSON型，也是一个total函数 Other classes of functions 除了total和partial，还有一些其他类型的函数 Injection 单射：一对一，对于值域内内一个y，都只有唯一的一个x使得f x=y成立 Surjection 满射：值域上任何一个值都有定义域的值与之对应，即target集就是值域 Bijection 双射：既是单射，又是满射。一一对应。 Constant functions 有一些函数的功能就是提供一个数值，根据所给的参数得到相应的输出。 Overriding ⊕ f g为两个函数，两个关系 f 被 g 重写为：f⊕g，then f⊕g x=g x Example from business - stock control Example from data processing Indexed-sequential files COBOL语言，是一种面向过程的高级程序设计语言，主要用于数据处理，是目前国际上应用最广泛的一种高级语言。COBOL是英文Common Business-Oriented Language的缩写,原意是面向商业的通用语言。它采用 300多个英语单词作为保留字，以一种接近于英语书面语言的形式来描述数据特性和数据处理过程,因而便于理解和学习。COBOL语言是专门为企业管理而设计的高级语言，可用于统计报表、财务会计、计划编制、作业调度、情报检索和人事管理等方面。 在COBOL语言中，有一种数据文件为索引顺序文件 Read operation Rewrite operation Write operation Delete operation Error conditions Further facilities Summary of notation A seat allocation system Introduction This example concerns recording the allocation of seats to passengers on an aircraft The types The state 一个座位只能被一个人预定，但是一个人可以预定多个座位 Initialization operation 对于一个系统必须有一个初始化状态 这个系统的初始化状态为，所有座位都没有被预定 Operations Booking Cancel Enquiry operations 询问操作并不改变系统的状态 Whose seat 除了会改变系统状态的操作，查询座位主人的操作也是必要的 REPLY ::= yes | no Dealing with errors Booking 在predicate中应写 s?∈dom bookedTo Cancel A schema to handle errors on canceling a booking is defined： Sequence Definition and Representation 在集合中我们不关系元素的顺序，且集合中没有重复的元素 在序列中，元素的顺序是很重要的，且可以包含相同的元素 序列可以被看作一个函数 Example： 第 i 个元素 Example： 序列的长度 # Example： Sequence Operators Concatenation 连接 Example： Reverse 逆置 Example： Head，Last，Tail and Front given a sequence &lt;a,b,c,d,e,f,g&gt; head&lt;…&gt;=a last&lt;…&gt;=g tail&lt;…&gt;=&lt;b,c,d,e,f,g&gt; front&lt;…&gt;=&lt;a,b,c,d,e,f&gt; Squash (压缩) 其中min(dom f)代表f的定义域的最小值 Example： Extraction 提取 提取操作是对定义域的限制 Example： Filter 过滤 过滤操作是对值域的限制 Example： Extraction and Filter Distributed catenation(分布连接) / flattening(平展) Example： Bag Definition and Representation a.k.a. multiset [[·]]-representation of a bag 一个包中的元素必须是同类型的 包中的元素顺序不重要 Example： Limitation 包中可以有无限个元素 但是上面的这种表示方法并不能表示无限个元素的包 Function-representation of a bag Example： Bag Operators Bag count Example： Bag scaling Example： count and ⊗ 要与函数重写区分开 Bag membership and sub-bag relation membership sub-bag Example： Bag union and bag difference Example： Function items Example： Formal Specification Examples More about Logic Language Example Terms (项) Example： Formulas (公式) unary：一元的 Example： Sentences (语句) Every sentence is a formula without free variable w.r.t.：with respect to i.e.：也就是，换言之 Example： Informal semantics Conventions Example： Deductive System Introduction syntactic：adj.句法的 Inference rules Formal proof Points Relation和Maplet之间的区别? 传递闭包？例题？Reflexive transitive closure 离散数学 符号 Material 课程资料","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"FSUZ","slug":"FSUZ","permalink":"https://cheeseburgerim.github.io/tags/FSUZ/"}]},{"title":"数据库原理-Lab4","slug":"DataBase/DataBasePrinciple-Lab4","date":"2021-06-11T03:11:36.000Z","updated":"2021-06-17T06:30:27.244Z","comments":false,"path":"2021/06/11/DataBase/DataBasePrinciple-Lab4/","link":"","permalink":"https://cheeseburgerim.github.io/2021/06/11/DataBase/DataBasePrinciple-Lab4/","excerpt":"","text":"实验资料 实验源码 实验目的 通过上机练习掌握数据库编程技术 实验原理 用SQL进行高级数据库操作； 用JDBC编程连接数据库并进行操作。 实验内容 详情见实验指导书 实验步骤 Phase1 按实验要求建表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748CREATE TABLE employees (emp_no INT NOT NULL,birth_date DATE NOT NULL,first_name VARCHAR(14) NOT NULL,last_name VARCHAR(16) NOT NULL,gender CHAR(1) NOT NULL,hire_date DATE NOT NULL,CONSTRAINT pk_employees PRIMARY KEY (emp_no));CREATE TABLE departments (dept_no CHAR(4) NOT NULL,dept_name VARCHAR(40) NOT NULL,CONSTRAINT pk_departments PRIMARY KEY (dept_no));CREATE TABLE dept_emp (emp_no INT NOT NULL,dept_no CHAR(4) NOT NULL,from_date DATE NOT NULL,to_date DATE NOT NULL,CONSTRAINT pk_dept_emp PRIMARY KEY (emp_no, dept_no),CONSTRAINT fk_dept_emp_employees FOREIGN KEY (emp_no) REFERENCES employees(emp_no),CONSTRAINT fk_dept_emp_departments FOREIGN KEY (dept_no) REFERENCES departments(dept_no));CREATE TABLE dept_manager (dept_no CHAR(4) NOT NULL,emp_no INT NOT NULL,from_date DATE NOT NULL,to_date DATE NOT NULL,CONSTRAINT pk_dept_manager PRIMARY KEY (emp_no, dept_no),CONSTRAINT fk_dept_manager_employees FOREIGN KEY (emp_no) REFERENCES employees(emp_no),CONSTRAINT fk_dept_manager_departments FOREIGN KEY (dept_no) REFERENCES departments(dept_no));CREATE TABLE titles (emp_no INT NOT NULL,title VARCHAR(50) NOT NULL,from_date DATE NOT NULL,to_date DATE,CONSTRAINT pk_titles PRIMARY KEY (emp_no, title, from_date),CONSTRAINT fk_titles_employees FOREIGN KEY (emp_no) REFERENCES employees (emp_no));CREATE TABLE salaries (emp_no INT NOT NULL,salary INT NOT NULL,from_date DATE NOT NULL,to_date DATE NOT NULL,CONSTRAINT pk_salaries PRIMARY KEY (emp_no, from_date),CONSTRAINT fk_salaries_employees FOREIGN KEY (emp_no) REFERENCES employees(emp_no)); 将提供的数据导入到已创建的表中 12345678910111213COPY employees FROM &#x27;/root/resources/data_employees.txt&#x27;delimiter &#x27;,&#x27;;COPY titles FROM &#x27;/root/resources/data_titles.txt&#x27;delimiter &#x27;,&#x27;;COPY salaries FROM &#x27;/root/resources/data_salaries.txt&#x27;delimiter &#x27;,&#x27;;COPY departments FROM &#x27;/root/resources/data_departments.txt&#x27;delimiter &#x27;,&#x27;;COPY dept_emp FROM &#x27;/root/resources/data_dept_emp.txt&#x27;delimiter &#x27;,&#x27;;COPY dept_manager FROM &#x27;/root/resources/data_dept_manager.txt&#x27;delimiter &#x27;,&#x27;;-- 插入数据后可用SQL语句查询结果SELECT COUNT(*) FROM employees;SELECT COUNT(*) FROM titles;SELECT COUNT(*) FROM salaries;SELECT COUNT(*) FROM departments;SELECT COUNT(*) FROM dept_emp;SELECT COUNT(*) FROM dept_manager; 将表departments复制到新表中 1CREATE TABLE departments_copy AS (SELECT * FROM departments); 新建log表存修改记录 12345678910CREATE TABLE departments_copy_log(log_id SERIAL, -- 日志流水编号（自增）login_name VARCHAR(256), -- 登录名update_date TIMESTAMP WITH TIME ZONE, -- 修改时间dept_no CHAR(4), -- 部门编号dept_name_old VARCHAR(40), -- 部门名称的旧值dept_name_new VARCHAR(40), -- 部门名称的新值CONSTRAINT departments_copy_log_pk PRIMARY KEY(log_id)); 编写触发器，实现修改部门名称时，将数据库用户登录名、修改时间、部门编号、部门名称的旧值、部门名称的新值记录到departments_copy_log表中 1234567891011121314151617-- SequenceCREATE SEQUENCE adderSTART WITH 1INCREMENT BY 1;-- Functioncreate or replace function changeLog() returns trigger as $departments$ begin insert into departments_copy_log(log_id,login_name,update_date,dept_no,dept_name_old,dept_name_new) values(DEFAULT,&#x27;PYZ&#x27;,now(),old.dept_no,old.dept_name,new.dept_name); return null;end;$departments$ language plpgsql;create trigger changelogtriggerafter update of dept_name on departmentsfor each rowexecute procedure changeLog(); 执行查询语句 123456789101112131415UPDATE departmentsSET dept_name = CONCAT(dept_name, &#x27; Dept&#x27;)WHERE dept_no = &#x27;d005&#x27;;UPDATE departmentsSET dept_name = CONCAT(dept_name, &#x27; Dept&#x27;)WHERE dept_no = &#x27;d006&#x27;;UPDATE departmentsSET dept_name = CONCAT(dept_name, &#x27; Dept&#x27;)WHERE dept_no = &#x27;d007&#x27;;UPDATE departmentsSET dept_name = CONCAT(dept_name, &#x27; Dept&#x27;)WHERE dept_no = &#x27;d008&#x27;; 查询结果 1SELECT * FROM departments_copy_log; Phase2 按要求建立视图 123create view finance_employees_view as select emp_no,first_name,last_name,birth_date,hire_date from employees; 查询视图的前10行 1SELECT * FROM finance_employees_view LIMIT 10; Phase3 阶段三的目的是为了体现出索引的高效率查找 建立索引 1234create index employees_first_name_index on employees(first_name);create index employees_last_name_index on employees(last_name); 查看查询时间 1234EXPLAIN ANALYZESELECT *FROM employeesWHERE first_name=&#x27;Peternela&#x27; AND last_name=&#x27;Anick&#x27;; Phase4 与阶段三相似，除了索引，还涉及到了主键外键对查询时间的影响 建立索引 1234create index employees_first_name_index on employees(first_name);create index employees_last_name_index on employees(last_name); 删除/新建-主外键 123456789101112131415161718192021222324252627-- drop foreign keysALTER TABLE salaries DROP CONSTRAINT fk_salaries_employees;ALTER TABLE titles DROP CONSTRAINT fk_titles_employees;ALTER TABLE dept_emp DROP CONSTRAINT fk_dept_emp_employees;ALTER TABLE dept_emp DROP CONSTRAINT fk_dept_emp_departments;ALTER TABLE dept_manager DROP CONSTRAINT fk_dept_manager_employees;ALTER TABLE dept_manager DROP CONSTRAINT fk_dept_manager_departments;-- drop primary keysALTER TABLE employees DROP CONSTRAINT pk_employees;ALTER TABLE departments DROP CONSTRAINT pk_departments;ALTER TABLE dept_emp DROP CONSTRAINT pk_dept_emp;ALTER TABLE salaries DROP CONSTRAINT pk_salaries;-- add primary keysALTER TABLE employees ADD CONSTRAINT pk_employees PRIMARY KEY(emp_no);ALTER TABLE departments ADD CONSTRAINT pk_departments PRIMARY KEY(dept_no);ALTER TABLE dept_emp ADD CONSTRAINT pk_dept_emp PRIMARY KEY(emp_no, dept_no);ALTER TABLE salaries ADD CONSTRAINT pk_salaries PRIMARY KEY(emp_no, from_date);-- add foreign keysALTER TABLE salaries ADD CONSTRAINT fk_salaries_employees FOREIGN KEY (emp_no) REFERENCES employees(emp_no);ALTER TABLE titles ADD CONSTRAINT fk_titles_employees FOREIGN KEY (emp_no) REFERENCES employees (emp_no);ALTER TABLE dept_emp ADD CONSTRAINT fk_dept_emp_employees FOREIGN KEY (emp_no) REFERENCES employees(emp_no);ALTER TABLE dept_emp ADD CONSTRAINT fk_dept_emp_departments FOREIGN KEY (dept_no) REFERENCES departments(dept_no);ALTER TABLE dept_manager ADD CONSTRAINT fk_dept_manager_employees FOREIGN KEY (emp_no) REFERENCES employees(emp_no);ALTER TABLE dept_manager ADD CONSTRAINT fk_dept_manager_departments FOREIGN KEY (dept_no) REFERENCES departments(dept_no); 查看查询时间 1234567EXPLAIN ANALYZESELECT d.dept_no, d.dept_name, e.emp_no, e.first_name, e.last_name, s.salaryFROM departments AS dINNER JOIN dept_emp AS de ON d.dept_no=de.dept_noINNER JOIN employees AS e ON de.emp_no=e.emp_noINNER JOIN salaries AS s ON e.emp_no=s.emp_noWHERE e.first_name=&#x27;Peternela&#x27; AND e.last_name=&#x27;Anick&#x27;; Phase5 按要求创建存储方法 12345678910CREATE OR REPLACE FUNCTION calc_avg_salary_for_emp_no(IN emp_no_in INT,OUT avg INT)RETURNS INT AS $avg$BEGIN SELECT AVG(salary) INTO avg FROM salaries WHERE emp_no=emp_no_in; RETURN;END$avg$ LANGUAGE plpgsql; 执行下列语句 12345678do language plpgsql $$declare res NUMERIC;beginselect * from calc_avg_salary_for_emp_no(10002) into res;raise notice &#x27;%&#x27;,res;end $$;//执行结果为:68854.5//与答案相同 删除存储过程 1DROP FUNCTION calc_avg_salary_for_emp_no; Phase6 按要求创建存储过程 123456789101112CREATE OR REPLACE FUNCTION is_manager(IN emp_no_in INT)RETURNS BOOLEAN AS $$DECLARE cnt INT;BEGIN SELECT COUNT(*) INTO cnt FROM dept_manager WHERE emp_no=emp_no_in; IF(cnt=0) THEN RETURN FALSE; ELSE RETURN TRUE; END IF;END;$$ LANGUAGE plpgsql; 执行下列语句 1234SELECT is_manager(110022) AS is_manager;-- trueSELECT is_manager(100002) AS is_manager;-- false 删除函数 1DROP FUNCTION is_manager; Phase7 按要求创建存储方法 1234567891011121314151617181920212223242526272829CREATE OR REPLACE FUNCTION calc_avg_and_var_salary_for_emp_no( IN emp_no_in INTEGER, OUT avg REAL, OUT var REAL)RETURNS RECORD AS $$DECLARE cur_salary CURSOR(cur_emp_no INTEGER) FOR SELECT salary FROM salaries WHERE cur_emp_no=emp_no; sum REAL; cnt INT; temp REAL;BEGIN SELECT AVG(salary) INTO avg FROM salaries WHERE emp_no=emp_no_in; sum:=0; cnt:=0; temp:=0; OPEN cur_salary(emp_no_in); WHILE(FOUND)LOOP FETCH FROM cur_salary INTO temp; EXIT WHEN NOT FOUND; cnt:=cnt+1; sum:=sum+abs(temp-avg)*abs(temp-avg); END LOOP; var:=sum/cnt; CLOSE cur_salary;END;$$ LANGUAGE plpgsql; 执行下列语句 123456789101112do language plpgsql $$declare avg_salary REAL;declare var_salary REAL;beginSELECT * FROM calc_avg_and_var_salary_for_emp_no(10002) INTO avg_salary, var_salary;raise notice &#x27;avg:%&#x27;, avg_salary;raise notice &#x27;var:%&#x27;, var_salary;end $$;//执行结果://avg:68854.5 ans:68854.5//var:7.1651755e+06 ans:7165175.583333015//与答案相同 删除存储方法 1DROP FUNCTION calc_avg_and_var_salary_for_emp_no; 实验思考 在这次实验中使用了触发器，函数，存储过程，视图，序列，游标，索引。对数据库的操作与原理有了更深一层的认知。知道分别在什么情况下需要使用触发器，函数和存储过程。了解了他们的区别。函数一般只有一个返回值，而过程可以影响多个变量。通过建立视图来建立一个虚拟的表。当然也有物化视图。对视图的操作和对表的操作基本相同。通过建立索引减少查询语句所花费的时间，实验过程中查询了很多情况下同样的查询语句所消耗的时间，发现建立索引可以很大程度上减少时间的开销。与直接在原有的表中搜索，运用索引可以有效地帮助我们更快得获取有用的信息。经过此次实验，更好地掌握了SQL语言的语法结构，SQL是一种非常严谨的语言，不能出现任何一点纰漏。数据库是一个项目中非常重要的一环。懂得如何处理数据库中所遇到的问题至关重要。在不同的情况下选择用不同的方法解决相应的问题大大减少了维护与改善数据库的精力。今后要从事计算机行业，应该不断锻炼自己，前后端结合，综合发展。不能只学前端也不能只学后端。后端的数据库是必不可少的一个学科。参加实践的过程中应找机会锻炼自己对数据库的维护与开发。更深层次的理解数据库的原理与结构。数据库是DBMS的最新技术，是目前计算机科学的重要分支。反观这学期对数据库的学习以及实验中收获的对数据库的理解和对数据库的操作经验，后者有助于前者的理解，前者指导我实践后者。现在可以更加灵活自如地运用这些指令。以上是本次实验的实验总结。","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/tags/DataBase/"},{"name":"DataBasePrinciple","slug":"DataBasePrinciple","permalink":"https://cheeseburgerim.github.io/tags/DataBasePrinciple/"}]},{"title":"计算机网络-实验","slug":"Network/Network-Lab","date":"2021-06-07T13:00:55.000Z","updated":"2021-06-17T06:33:49.731Z","comments":false,"path":"2021/06/07/Network/Network-Lab/","link":"","permalink":"https://cheeseburgerim.github.io/2021/06/07/Network/Network-Lab/","excerpt":"","text":"计算机网络实验 路由实验 实验资料 实验指导 交换实验 实验资料 实验指导 Web服务器配置与管理 实验资料 实验指导 DNS服务器配置与管理 实验资料 实验指导 综合实验 实验资料 实验指导 RIP/OSPF组件三层网络 实验资料 实验指导 VLAN 实验资料 实验指导 综合组网设计实验 实验资料 实验指导","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"ComputerNetwork","slug":"ComputerNetwork","permalink":"https://cheeseburgerim.github.io/tags/ComputerNetwork/"}]},{"title":"数字逻辑与数字系统-Part5","slug":"MLAMS/MLAMS-Part5","date":"2021-06-02T07:54:41.000Z","updated":"2021-06-17T06:33:36.744Z","comments":false,"path":"2021/06/02/MLAMS/MLAMS-Part5/","link":"","permalink":"https://cheeseburgerim.github.io/2021/06/02/MLAMS/MLAMS-Part5/","excerpt":"","text":"Chapter5 指令集体系结构(ISA) 序言 思考题：为什么一个软件可以运行在装配有不同Intel处理器的个人电脑上？ 思考题：为什么一个软件可以运行在装配有不同ARM处理器的安卓手机上？ 兼容性解决了上述问题 指令集体系结构定义 指令集体系结构(ISA，也称指令系统)，是对处理器硬件细节的抽象描述，即设计规范，定义了处理器能够做什么，也是系统级程序员所能看到的处理器的属性； 指令系统结构不仅仅是关于指令功能的编码(指令集)，还包括 ISA中的“五朵金花” MIPS指令集体系结构 MIPS(无内部互锁流水级处理器)是最经典的RISC处理器，被视为处理器教科书的典范 由斯坦福大学的校长，John L. Hennessy领导的研究小组在1981年开始设计的。 其设计理念就是使用相对简单的指令，结合优秀的编译器以及采用流水线技术执行指令，从而使用更少的晶体管生产出更快的处理器。 MIPS体系结构设计准则 简单设计有助于规整化 加快常见功能 越小的设计越快 好的设计需要好的折中 指令集体系结构为什么重要 指令集体系结构是计算机产业的枢纽，控制产业生态 如成千上万家企业参与到x86生态(x86是最好的ISA吗？) 指令体系结构是计算机软硬件的重要标准 一个人当然可以发明自己的语言，但是如何让别人接受才是真正的问题 指令系统决定系统性能和实现复杂性等 如RISC、CISC 如32位/64位，媒体指令、向量指令等 微体系结构的定义 微体系结构是指指令集体系结构的一种具体硬件实现，如指令的数据通路结构，计算单元的电路结构(加法器等)，存储器体系(寄存器文件、主存的结构)等等。 汇编语言 定义 计算机机器语言——指明了需要完成什么操作以及操作数的来源 汇编语言：便于人来阅读，包括汇编指令、伪指令(标签)、宏指令等； 机器语言：机器可读(0和1形式)的指令，也叫机器指令； 汇编指令和机器指令是一一对应的关系。 本文主要介绍MIPS汇编指令(汇编语言) 由John Hennessy和同事于1980’s在斯坦福大学提出； 应用于许多商业系统：Silicon Graphics，Nintendo和Cisco等。 加法指令 汇编指令格式：助记符 目的操作数 源操作数； add(sub)：助记符，表明该指令完成什么操作，也称操作符； b、c：源操作数，表明输入数据的来源； a：目的操作数，表明输出数据的去处。 设计准则1：简单设计有助于规整化 指令格式前后一致 操作数格式一致 易于在硬件中编码和处理 设计准则2：加快常见功能 MIPS仅仅包含了简单常用的指令 硬件解码和执行指令可以变得简单、短小、速度快 更复杂的指令由多条MIPS指令完成 MIPS为RISC(精简指令)，而Intel的x86为CISC(复杂指令) 汇编操作数 操作数物理位置 寄存器 存储器 常熟(立即数) 操作数——寄存器 MIPS定义了32个32位寄存器组成的寄存器文件(register file)； 寄存器的访问速度快于内存，但存储容量有限； MIPS被称为32位体系，因为其操作的数据宽度为32位数据； 体现了“越小的设计越快”的设计准则。 寄存器 名字前面加$来表示 例如：$0，代表寄存器0 有些寄存器有专有用途 $0总是表示立即数0； s0−s0-s0−s7为保存寄存器，用于保存变量； t0−t0-t0−t9为临时寄存器，用于保存大型计算中的中间值； 本文中除了$0寄存器，其他寄存器可以任意使用。 带寄存器的指令 1a=b+c; 12# $s0 &#x3D; a, $s1 &#x3D; b, $s2 &#x3D; cadd $s0, $s1, $s2 存储器可以存储更多的数据； 存储器的访问时间更长，故经常使用的变量会存放在寄存器中； 综合使用存储器和寄存器，程序可以以较快的速度访问大量数据； 对于MIPS而言，存储器的地址为32位，一个存储字的长度也为32位； MIPS采用字节编址存储器，每个字节有一个单独地址。但可以按字节、半字和字的方式进行寻址。 MIPS32寄存器 通用寄存器(General Purpose Register) 共计32个×32位，统称为寄存器文件/寄存器堆(Register) 32个通用寄存器均为程序员可见的寄存器 特殊寄存器 用于存储乘/除法结果的寄存器HI和LO，程序员可见 用于存放指令地址的PC(程序计数器)，程序员不可见 系统控制状态寄存器 CP0协处理器中的寄存器 操作数——存储器 存储器可以存储更多的数据； 存储器的访问时间更长，故经常使用的变量会存放在寄存器中； 综合使用存储器和寄存器，程序可以以较快的速度访问大量数据； 对于MIPS而言，存储器的地址为32位，一个存储字的长度也为32位； MIPS采用字节编址存储器，每个字节有一个单独地址。但可以按字节、半字和字的方式进行寻址。 按字编址和寻址 注意：MIPS是按字节编址的，不是字编址。为了便于理解，先讲字编址再讲字节编址。 加载指令 读存储器的指令成为加载指令(load指令)； 加载一个字的指令助记符为&quot;lw&quot;(load a word)； 加载指令格式：lw s0,5(s0, 5(s0,5(t1) 计算访存地址：基地址($t1寄存器中的值)+偏移量(5)； 访存地址 = ($t1 + 5)。 含义：从主存地址&quot;t1+5&quot;处，读取一个字，将其放到寄存器t1 + 5&quot;处，读取一个字，将其放到寄存器t1+5&quot;处，读取一个字，将其放到寄存器s0中； 基地址可以存放在任意寄存器中。 存储指令 写入存储器的指令称为存储指令(store指令)； 存储一个字的指令助记符为&quot;sw&quot;(store a word)； 存储指令格式：sw s0,5(s0, 5(s0,5(s1) 计算访存地址：基地址($t1寄存器中的值)+偏移量(5)； 访存地址 = $t1 + 5。 含义：向主存地址&quot;t1+5&quot;处，写入寄存器t1 + 5&quot;处，写入寄存器t1+5&quot;处，写入寄存器s0中的字； 基地址可以存放在任意寄存器中。 按字节编址 每个字节有一个独立地址； 具有加载/存储字节、半字和字指令 加载/存储字节：lb，sb 加载/存储半字：lh，sh 加载/存储字：lw，sw 一个字(32-bit)为4字节，字地址按4递增。 读按字节编址存储器 写按字节编址存储器 大端和小端 在字节编址的存储器中，根据一个字中的字节存储顺序将存储器的组织方式分为两种：大端(big-endian)和小端(little-endian) 大端：一个字中，最高有效字节存储在低地址； 小端：一个字中，最高有效字节存储在高地址； 两种组织方式，字地址都是相同的，只是一个字中的字节地址不同； 大端/小端由ISA确定，对于MIPS而言，二者都可以使用。 解析： $s0=0x23456789 第一条指令含义为：将地址$s0寄存器中的值存在地址0($0)中； 第二条指令含义为：在地址1(0)读取一个字节存入到0)读取一个字节存入到0)读取一个字节存入到s0寄存器中； 对于大端存储：先将0x23456789存到地址0(s0)中，由于是大端存储，则存储顺序为[高地址23456789低地址]，再将地址1(s0)中，由于是大端存储，则存储顺序为[ 高地址 23 45 67 89 低地址 ]，再将地址1(s0)中，由于是大端存储，则存储顺序为[高地址23456789低地址]，再将地址1(s0)的值读到s0寄存器中，即将地址(0+1)的值，也就是45存在s0寄存器中，即将地址(0+1)的值，也就是45存在s0寄存器中，即将地址(0+1)的值，也就是45存在s0寄存器中，所以当为大端存储时，$s0的值为0x00000045； 对于小端存储：先将0x23456789存到地址0(s0)中，由于是小端存储，则存储顺序为[高地址89674523低地址]，再将地址1(s0)中，由于是小端存储，则存储顺序为[ 高地址 89 67 45 23 低地址 ]，再将地址1(s0)中，由于是小端存储，则存储顺序为[高地址89674523低地址]，再将地址1(s0)的值读到s0寄存器中，即将地址(0+1)的值，也就是67存在s0寄存器中，即将地址(0+1)的值，也就是67存在s0寄存器中，即将地址(0+1)的值，也就是67存在s0寄存器中，所以当为大端存储时，$s0的值为0x00000067。 思考题 编写一段C程序，确定所运行机器采用的是大端存储还是小端存储？ 1234567int big_little_endian()&#123; int i=0x12345678; char c*=(char *)&amp;i; return (c*==0x12);&#125;//如果返回值为1,则为大端存储//如果返回值为0,则为小端存储 操作数——立即数 操作数既不来自寄存器，也不来自存储器，而直接来自指令； 立即数通常被表示为一个16位的二进制补码，嵌入在指令中。 12a=a+4;b=a-12; 123# $s0&#x3D;a, $s1&#x3D;baddi $s0, $s0, 4 #a&#x3D;a+4addi $s1, $s0, -12 #b&#x3D;a-12 机器语言 格式 共有3种指令格式： 寄存器类型指令(R型指令) 立即数类型指令(I型指令) 跳转类型指令(J型指令) 寄存器类型指令 32位指令字被划分为6个字段 op字段表示操作码，通常全为0； func字段与op字段一起决定指令的功能； rs字段和rt字段为寄存器编号，表示两个源操作数来自于寄存器； rd字段表示目的寄存器的编号； sa(shamt)字段只在位移指令中使用，表示移位位数，对于其他R-型指令sa字段为全0。 寄存器类型指令举例 立即数类型指令 32位指令字被划分为4个字段 op字段表示操作码； rs字段为寄存器编号，表示一个源操作数来自于寄存器； imm字段是一个16位立即数，表示另一个操作数，需要扩展至32位； rt字段表示目的寄存器的编号，用于存放指令运行结果。 立即数类型指令举例 跳转型指令 32位指令字被划分为2个字段 op字段表示操作码，用于确定指令的类型； instr_index用于产生跳转的目标地址； 跳转地址：(PC+4)31:28|| instr_index || 00。 总结：3种指令格式 单周期MIPS32处理器的设计 MIPS指令集 MIPS最基本的指令集 R-type指令：and, or, add, sub, slt； 存储器指令：lw, sw； 分支指令：beq。 扩展：Addi，j … 设计要求 单周期MIPS32处理器 每条指令均在一个时钟周期完成； 32个32位寄存器，哈佛结构，小端模式，支持23条指令。 数据通路+控制通路 数据通路：完成对指令中操作数的运算、存储等处理工作； 控制通路：从数据通路中接收指令，并对其进行翻译以告知数据通路如何处理； 处理器设计相当于在各个记忆部件之间添加组合逻辑电路，在控制单元的控制下根据当前电路的状态计算出电路的新状态。 概念模型 MiniMIPS32处理器概念模型 记忆部件 数据通路——LW STEP1：取指阶段 STEP2-1：译码阶段——从寄存器取操作数 STEP2-2：译码阶段——另一个操作数进行符号扩展 STEP3：执行阶段——计算访存地址 STEP4：访存阶段/写回阶段——从数据存储器取回数据，写入寄存器文件 STEP5：更新PC——计算下一条指令的地址 数据通路——SW 将rt字段指定的寄存器中的数据写入数据存储器 数据通路——R型指令 译码阶段从rs和rt寄存器中读操作数； 将ALU运算结果写回寄存器文件； 目的寄存器由rt字段给出。 数据通路——分支指令BEQ 判断rs和rt寄存器的值是否相等； 计算分支地址BTA=(sign-extended)(immediate&lt;&lt;2)+(PC+4) 控制通路 控制单元 ALU译码 主译码 addi指令数据通路 addi指令主译码控制信号 J指令数据通路 J指令主译码控制信号 单周期处理器的性能分析 =[30+2(250)+150+25+200+20] ps =925 ps","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"数据库原理-Lab3","slug":"DataBase/DataBasePrinciple-Lab3","date":"2021-06-01T05:27:52.000Z","updated":"2021-06-17T06:30:20.571Z","comments":false,"path":"2021/06/01/DataBase/DataBasePrinciple-Lab3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/06/01/DataBase/DataBasePrinciple-Lab3/","excerpt":"","text":"实验资料 实验源码 实验目的 巩固ER模型的基本概念； 巩固ER模型到关系数据模型的转换规则； 加强使用SQL创建关系模式； 加强使用SQL创建主键和外键约束； 加强使用SQL添加数据库表的实例数据。 实验原理 采用PostgreSQL数据库作为实验用DBMS； 根据需求描述构建ER模型，绘制ER图； 根据转换规则，将ER模型转换为关系模型； 使用SQL创建数据库的关系模式； 使用SQL创建关系模式的主键和外键约束； 使用SQL添加数据库表的实例数据。 实验内容 详情见实验指导书 实验步骤 建表 1234567891011121314151617181920212223242526CREATE TABLE shipper( id INT, name VARCHAR, address VARCHAR);CREATE TABLE carrier( id INT, name VARCHAR, point INT);CREATE TABLE waybill( id INT, goods_name VARCHAR, loading_addr VARCHAR, unloading_addr VARCHAR, freight INT, order_time DATE);CREATE TABLE bid( id INT, shipper_id INT, carrier_id INT, waybill_id INT, bid_time DATE, price INT); 建立约束 12345678910111213141516-- PRIMARY KEYALTER TABLE shipper ADD CONSTRAINT pk_shipper PRIMARY KEY(id);ALTER TABLE carrier ADD CONSTRAINT pk_carrier PRIMARY KEY(id);ALTER TABLE waybill ADD CONSTRAINT pk_waybill PRIMARY KEY(id,freight);ALTER TABLE bid ADD CONSTRAINT pk_bid PRIMARY KEY(id);-- FOREIGN KEYALTER TABLE bid ADD CONSTRAINT fk_bid_shipper FOREIGN KEY(shipper_id)REFERENCES shipper(id);ALTER TABLE bid ADD CONSTRAINT fk_bid_carrier FOREIGN KEY(carrier_id)REFERENCES carrier(id);ALTER TABLE bid ADD CONSTRAINT fk_bid_waybill FOREIGN KEY(waybill_id,price)REFERENCES waybill(id,freight); 实验结果 E/R模型图 实验总结 经过此次实验，知道E/R图可以帮助我更好地理解各表之间的关系，也可以帮助我更轻松的建立主键与外键约束。同时，可以更加熟练地运用SQL语句进行建表以及建立约束等操作。","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/tags/DataBase/"},{"name":"DataBasePrinciple","slug":"DataBasePrinciple","permalink":"https://cheeseburgerim.github.io/tags/DataBasePrinciple/"}]},{"title":"数据库原理-Lab2","slug":"DataBase/DataBasePrinciple-Lab2","date":"2021-05-30T04:58:18.000Z","updated":"2021-06-17T06:30:12.810Z","comments":false,"path":"2021/05/30/DataBase/DataBasePrinciple-Lab2/","link":"","permalink":"https://cheeseburgerim.github.io/2021/05/30/DataBase/DataBasePrinciple-Lab2/","excerpt":"","text":"实验资料 实验源码 实验目的 巩固关系数据模型及其基本概念； 掌握使用SQL创建关系模式； 掌握使用SQL创建主键和外键约束； 掌握关系模式与ER模型的转换。 实验原理 采用PostgreSQL数据库作为实验用DBMS； 用SQL创建数据库模式； 用SQL创建主键和外键约束； 将关系模式转换为ER模型并绘制ER图。 实验内容 详情见实验指导书 实验步骤 建表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106CREATE TABLE bmsql_warehouse( w_id INT NOT NULL, w_ytd DECIMAL(12,2), w_tax DECIMAL(4,4), w_name VARCHAR(10), w_street_1 VARCHAR(20), w_street_2 VARCHAR(20), w_city VARCHAR(20), w_state CHAR(2), w_zip CHAR(9));CREATE TABLE bmsql_district( d_w_id INT NOT NULL, d_id INT NOT NULL, d_ytd DECIMAL(12,2), d_tax DECIMAL(4,4), d_next_o_id int, d_name VARCHAR(10), d_street_1 VARCHAR(20), d_street_2 VARCHAR(20), d_city VARCHAR(20), d_state CHAR(2), d_zip CHAR(9));CREATE TABLE bmsql_customer( c_w_id INT NOT NULL, c_d_id INT NOT NULL, c_id INT NOT NULL, c_discount DECIMAL(4,4), c_credit CHAR(2), c_last VARCHAR(16), c_first VARCHAR(16), c_credit_lim DECIMAL(12,2), c_balance DECIMAL(12,2), c_ytd_payment DECIMAL(12,2), c_payment_cnt INT, c_delivery_cnt INT, c_street_1 VARCHAR(20), c_street_2 VARCHAR(20), c_state CHAR(2), c_zip CHAR(9), c_phone CHAR(16), c_since TIMESTAMP, c_middle CHAR(2), c_data VARCHAR(500));CREATE TABLE bmsql_history( hist_id INT, h_c_id INT, h_c_d_id INT, h_c_w_id INT, h_d_id INT, h_w_id INT, h_date TIMESTAMP, h_amount DECIMAL(6,2), h_data VARCHAR(24));CREATE TABLE bmsql_new_order( no_w_id INT NOT NULL, no_d_id INT NOT NULL, no_o_id INT NOT NULL);CREATE TABLE bmsql_oorder( o_w_id INT NOT NULL, o_d_id INT NOT NULL, o_id INT NOT NULL, o_c_id INT);CREATE TABLE bmsql_order_line( ol_w_id INT NOT NULL, ol_d_id INT NOT NULL, ol_o_id INT NOT NULL, ol_number INT NOT NULL, ol_i_id INT NOT NULL, ol_delivery_d TIMESTAMP, ol_amount DECIMAL(6,2), ol_supply_w_id INT, ol_quantity INT, ol_dist_info CHAR(24));CREATE TABLE bmsql_item( i_id INT NOT NULL, i_name VARCHAR(24), i_price DECIMAL(5,2), i_data VARCHAR(50), i_im_id INT);CREATE TABLE bmsql_stock( s_w_id INT NOT NULL, s_i_id INT NOT NULL, s_quantity INT, s_ytd INT, s_order_cnt INT, s_remote_cnt INT, s_data VARCHAR(50), s_dist01 CHAR(24), s_dist02 CHAR(24), s_dist03 CHAR(24), s_dist04 CHAR(24), s_dist05 CHAR(24), s_dist06 CHAR(24), s_dist07 CHAR(24), s_dist08 CHAR(24), s_dist09 CHAR(24), s_dist10 CHAR(24)); 建立约束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869-- Primary Key-- Correct-- 1alter table bmsql_warehouse add constraint bmsql_warehouse_pkey primary key (w_id);-- 2alter table bmsql_district add constraint bmsql_district_pkey primary key (d_w_id, d_id);-- 3alter table bmsql_customer add constraint bmsql_customer_pkey primary key (c_w_id, c_d_id, c_id);-- 4alter table bmsql_oorder add constraint bmsql_oorder_pkey primary key (o_w_id, o_d_id, o_id);-- 5alter table bmsql_new_order add constraint bmsql_new_order_pkey primary key (no_w_id, no_d_id, no_o_id);-- 6alter table bmsql_order_line add constraint bmsql_order_line_pkey primary key (ol_w_id, ol_d_id, ol_o_id, ol_number);-- 7alter table bmsql_stock add constraint bmsql_stock_pkey primary key (s_w_id, s_i_id);-- 8alter table bmsql_item add constraint bmsql_item_pkey primary key (i_id);-- Foreign Key-- Correct-- 1alter table bmsql_district add constraint d_warehouse_fkeyforeign key (d_w_id)references bmsql_warehouse (w_id);-- 2alter table bmsql_customer add constraint c_district_fkeyforeign key (c_w_id, c_d_id)references bmsql_district (d_w_id, d_id);-- 3alter table bmsql_history add constraint h_customer_fkeyforeign key (h_c_w_id, h_c_d_id, h_c_id)references bmsql_oorder (o_w_id, o_d_id, o_id);-- 4alter table bmsql_history add constraint h_district_fkeyforeign key (h_w_id, h_d_id)references bmsql_district (d_w_id, d_id);-- 5alter table bmsql_new_order add constraint no_order_fkeyforeign key (no_w_id, no_d_id, no_o_id)references bmsql_oorder (o_w_id, o_d_id, o_id);-- 6alter table bmsql_oorder add constraint o_customer_fkeyforeign key (o_w_id, o_d_id, o_c_id)references bmsql_customer (c_w_id, c_d_id, c_id);-- 7alter table bmsql_order_line add constraint ol_order_fkeyforeign key (ol_w_id, ol_d_id, ol_o_id)references bmsql_oorder (o_w_id, o_d_id, o_id);-- 8alter table bmsql_order_line add constraint ol_stock_fkeyforeign key (ol_supply_w_id, ol_i_id)references bmsql_stock (s_w_id, s_i_id);-- 9alter table bmsql_stock add constraint s_warehouse_fkeyforeign key (s_w_id)references bmsql_warehouse (w_id);-- 10alter table bmsql_stock add constraint s_item_fkeyforeign key (s_i_id)references bmsql_item (i_id); 实验结果 E/R模型图 实验总结 经过此次实验，知道在实践中可能需要大量使用SQL语句或交互页面建立主键与外键。每个表的属性很多，非常容易导致思路混乱。可以建立约束前先画好E/R图理清思路，帮助自己更好地且效率更高的完成工作。","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/tags/DataBase/"},{"name":"DataBasePrinciple","slug":"DataBasePrinciple","permalink":"https://cheeseburgerim.github.io/tags/DataBasePrinciple/"}]},{"title":"数字逻辑与数字系统-Lab4","slug":"MLAMS/MLAMS-Lab4","date":"2021-05-29T05:46:46.000Z","updated":"2021-06-22T07:48:43.226Z","comments":false,"path":"2021/05/29/MLAMS/MLAMS-Lab4/","link":"","permalink":"https://cheeseburgerim.github.io/2021/05/29/MLAMS/MLAMS-Lab4/","excerpt":"","text":"实验四 自动贩售机的设计与实现 实验资料 实验源码 实验目的 掌握有限状态机的设计方法； 能够使用 SystemVerilog 进行三段式状态机的建模。 实验原理 有限状态机分为 Moore 型状态机和 Mealy 型状态机。前者，状态机的输出 仅由当前状态决定，如图 4-1 所示，在状态转换图的绘制中，输出信息标在状态 （圆圈）中。后者，状态机的输出由当前时刻状态和输入共同决定，如图 4-2 所 示，在状态转换图的绘制中，输出信息标在状态转换箭头之上。 采用硬件描述语言进行状态机建模时，建议使用 3 段式。第一段描述状态的 转换（即对状态机中的寄存器进行建模），采用时序逻辑实现；第二段描述状态 转换条件和规律（即对状态机中的次态逻辑进行建模），采用组合逻辑实现；第 三段描述输出逻辑，根据实际设计需要可采用组合逻辑或时序逻辑实现。 实验内容 详情见实验资料中实验指导书pdf或简略版实验指导书 采用有限状态机，基于 SystemVerilog HDL 设计并实现一个报纸自动贩售机。 整个工程的顶层模块如图 4-3 所示，输入/输出端口如表 4-1 所示。使用 4 个七 段数码管实时显示已付款和找零情况。其中，两个数码管对应“已付款”，另两个 数码管对应“找零”，单位为分。通过 1 个拨动开关对数字钟进行复位控制。使用 两个按键模拟投币，其中一个按键对应 5 分，另一个按键对应 1 角。使用 1 个 LED 灯标识出售是否成功，灯亮表示出售成功，否则表示已付款不够，出售失败。 假设报纸价格为 15 分，合法的投币组合包括： ⚫ 1 个 5 分的硬币和一个 1 角的硬币，不找零 ⚫ 3 个五分的硬币，不找零 ⚫ 1 个 1 角的硬币和一个 5 分的硬币，不找零 ⚫ 两个 1 角的硬币是合法的，找零 5 分。 当投入硬币的组合为上面 4 种之一时，则购买成功，LED 灯亮。购买成功后，LED 灯持续亮 10 秒，然后自动熄灭，同时 4 个数码管也恢复为 0。 实验步骤 首先完成使能时钟模块实现分频的功能。时钟沿周期为40ns，而扫描周期为1ms。说明没经过25000个时钟沿才产生一个有效的时钟沿 123456789101112131415161718192021222324252627282930313233343536373839404142`timescale 1ns / 1psmodule en_clock #(parameter N = 25000) ( input sys_clk, input sys_rst_n, output logic cout); //时钟周期为40ns //每经过25000个时钟上升沿为1ms //每1ms输出一个有效上升沿 //分频 logic [31 : 0] temp; always_ff@(posedge sys_clk) begin if(!sys_rst_n) temp &lt;= 0; else if(temp == N-1) temp &lt;= 0; else temp &lt;= temp + 1; end always_ff@(posedge sys_clk) begin if(!sys_rst_n) cout &lt;= 1&#x27;b0; else if(temp == N-1) cout &lt;= 1&#x27;b1; else cout &lt;= 1&#x27;b0; end // always_ff@(posedge sys_clk) begin // if(sys_rst_n==1) begin // if(temp==N-1) begin // temp &lt;= 0; // cout &lt;= 1&#x27;b1; // end // else begin // temp &lt;= temp + 1; // end // end // else begin // cout &lt;= 1&#x27;b0; // end // end endmodule 然后完成边沿检测模块。由于已经分频，所以理论上应该是每1ms检测到一个有效时钟上升沿。用移位寄存器完成设计。 12345678910111213141516171819202122232425262728`timescale 1ns / 1psmodule chk_asc( input sys_clk, input sys_rst_n, input i_start, output logic en);//现态和次态logic Q0, Q1;always_ff@(posedge sys_clk) begin if(sys_rst_n) begin //i_start为高电平时，代表有效上升沿 //即每1ms一次 Q0 &lt;= i_start; Q1 &lt;= Q0; end else begin Q0 &lt;= 0; Q1 &lt;= 0; endendassign en = (~Q1)&amp;Q0;endmodule 接着完成计时器模块。售出一份报纸后灯会亮10s，这里的计时功能由计时器来完成。与使能时钟类似，需要分频。时钟沿的周期为40ns，所以10s需要经过250000000个时钟沿。 1234567891011121314151617181920212223242526272829303132`timescale 1ns / 1psmodule next_state #(parameter M = 250000000)( input sys_clk, input sys_rst_n, input en, output logic state ); logic [31 : 0] temp; //灯要持续亮10s always_ff@(posedge sys_clk) begin if(!sys_rst_n) begin temp &lt;= 0; state &lt;= 0; end //en=1，灯亮10s后灭 else if(en) begin if(temp &lt; M - 1) temp &lt;= temp + 1; else begin temp &lt;= 0; state &lt;= 1; end end else if(!en) begin temp &lt;= 0; state &lt;= 0; end endendmodule 之后完成有限状态机模块。售卖机共有5个状态。可以用case语句完成 已投入￥0 已投入￥0.05 已投入￥0.10 已投入￥0.15 已投入￥0.20 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104`timescale 1ns / 1psmodule State_Mache ( input sys_clk, input sys_rst_n, input coin5_asc, input coin10_asc, input reset_flg, output logic [7 : 0] price, output logic [7 : 0] change, output logic open ); logic [3 : 0] current_state, next_state; always_ff@(posedge sys_clk) begin if(!sys_rst_n) current_state &lt;= 4&#x27;d0; else current_state &lt;= next_state; end always_ff@(posedge sys_clk) begin if(!sys_clk) begin price &lt;= 8&#x27;d0; change &lt;= 8&#x27;d0; open &lt;= 1&#x27;b0; end else begin //通过现态和输入得到次态 case(current_state) 4&#x27;d0: begin //￥0 if(coin5_asc) next_state &lt;= 4&#x27;d1; else if(coin10_asc) next_state &lt;= 4&#x27;d2; end 4&#x27;d1: begin //￥0.05 if(coin5_asc) next_state &lt;= 4&#x27;d2; else if(coin10_asc) next_state &lt;= 4&#x27;d3; end 4&#x27;d2: begin //￥0.10 if(coin5_asc) next_state &lt;= 4&#x27;d3; else if(coin10_asc) next_state &lt;= 4&#x27;d4; end 4&#x27;d3: begin //￥0.15 if(reset_flg) next_state &lt;= 4&#x27;d0; end 4&#x27;d4: begin //￥0.20 if(reset_flg) next_state &lt;= 4&#x27;d0; end endcase end end //通过次态得到输出结果 always@(*) begin if(!sys_rst_n) begin price = 8&#x27;d0; change = 8&#x27;d0; open = 1&#x27;b0; end else begin case(next_state) 4&#x27;d0: begin //￥0 price = 8&#x27;d0; change = 8&#x27;d0; open = 1&#x27;b0; end 4&#x27;d1: begin //￥0.05 price = 8&#x27;d5; change = 8&#x27;d0; open = 1&#x27;b0; end 4&#x27;d2: begin //￥0.10 price = 8&#x27;d10; change = 8&#x27;d0; open = 1&#x27;b0; end 4&#x27;d3: begin //￥0.15 price = 8&#x27;d15; change = 8&#x27;b0; open = 1&#x27;b1; end 4&#x27;d4: begin //￥0.20 price = 8&#x27;d20; change = 8&#x27;d5; open = 1&#x27;b1; end endcase end endendmodule 接着完成BCD码转七段数码管信号模块。同样使用case语句完成。 1234567891011121314151617181920212223`timescale 1ns / 1psmodule BCD_2_7Dig( input [3 : 0] BCD, output logic [7 : 0] a_to_g ); always@(*) begin case(BCD) 4&#x27;b0000:a_to_g=8&#x27;b11000000; 4&#x27;b0001:a_to_g=8&#x27;b11111001; 4&#x27;b0010:a_to_g=8&#x27;b10100100; 4&#x27;b0011:a_to_g=8&#x27;b10110000; 4&#x27;b0100:a_to_g=8&#x27;b10011001; 4&#x27;b0101:a_to_g=8&#x27;b10010010; 4&#x27;b0110:a_to_g=8&#x27;b10000010; 4&#x27;b0111:a_to_g=8&#x27;b11011000; 4&#x27;b1000:a_to_g=8&#x27;b10000000; 4&#x27;b1001:a_to_g=8&#x27;b10010000; default: a_to_g=8&#x27;b11111111; endcase end endmodule 完成七段数码管扫描模块 123456789101112131415161718192021222324252627`timescale 1ns / 1psmodule _7Dig_Scan( input sys_clk, input sys_rst_n, input cout, input [7 : 0] price, input [7 : 0] change, output logic [3 : 0] BCD, output logic [3 : 0] an ); //七段数码管每1ms扫描一次 always_ff@(posedge sys_clk) begin if(!sys_rst_n) an &lt;= 4&#x27;d1; //与实验三相同，四个七段数码管并不是同时亮，同时灭 //an为4个七段数码管的使能端 else if(cout) an &lt;= &#123;an[2 : 0], an[3]&#125;; end always@(*) begin if(an == 1) BCD &lt;= price[3 : 0]; else if(an == 2) BCD &lt;= price[7 : 4]; else if(an == 4) BCD &lt;= change[3 : 0]; else if(an == 8) BCD &lt;= change[7 : 4]; endendmodule 最后在vend.sv中进行结构建模 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778`timescale 1ns / 1psmodule vend( input sys_clk, sys_rst_n, input coin5, coin10, output [3 : 0] an, output [7 : 0] a_to_g, output open ); //使能时钟的输出 //每1ms一次高电平 logic cout; //是否投入一个5分硬币或一个一角硬币 logic coin5_asc,coin10_asc; //投入硬币的总额以及找零 logic [7:0] price,change; //转换为BCD码 logic [7:0] price_BCD,change_BCD; logic [3:0] BCD; //复位标志 logic reset_flg; en_clock en_clock( .sys_clk(sys_clk), .sys_rst_n(sys_rst_n), .cout(cout) ); chk_asc coin5_chk_asc( .sys_clk(sys_clk), .sys_rst_n(sys_rst_n), .i_start(coin5), .en(coin5_asc) ); chk_asc coin10_chk_asc( .sys_clk(sys_clk), .sys_rst_n(sys_rst_n), .i_start(coin10), .en(coin10_asc) ); next_state next_state( .sys_clk(sys_clk), .sys_rst_n(sys_rst_n), .en(open), .state(reset_flg) ); State_Mache State_Mache( .sys_clk(sys_clk), .sys_rst_n(sys_rst_n), .coin5_asc(coin5_asc), .coin10_asc(coin10_asc), .reset_flg(reset_flg), .price(price), .change(change), .open(open) ); bin2bcd_0 price_bin2bcd_0( .bin(price), .bcd(price_BCD) ); bin2bcd_0 change_bin2bcd_0( .bin(change), .bcd(change_BCD) ); _7Dig_Scan _7Dig_Scan( .sys_clk(sys_clk), .sys_rst_n(sys_rst_n), .cout(cout), .price(price_BCD), .change(change_BCD), .BCD(BCD), .an(an) ); BCD_2_7Dig BCD_2_7Dig( .BCD(BCD), .a_to_g(a_to_g) );endmodule 实验结果 波形图 FPGA截图 投入硬币之前 投入一个1角硬币 再投入一个1角硬币 10s后复位 FPGA视频 各模块电路图 使能时钟生成器 边沿检测电路 贩售状态机 七段数码管扫描显示 BCD码转七段数码管模块 七段数码管使能信号生成模块 状态转换图","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"基于ORB-SLAM2的Android手机实时定位-进度","slug":"Project/DaChuang2021-2022/DaChuang2021-2022-Process","date":"2021-05-15T02:28:48.000Z","updated":"2021-05-26T11:29:32.004Z","comments":false,"path":"2021/05/15/Project/DaChuang2021-2022/DaChuang2021-2022-Process/","link":"","permalink":"https://cheeseburgerim.github.io/2021/05/15/Project/DaChuang2021-2022/DaChuang2021-2022-Process/","excerpt":"","text":"Android Studio学习 2021/5/15~Now：学习Android Studio的使用 练习源码 学习过程","categories":[{"name":"Project","slug":"Project","permalink":"https://cheeseburgerim.github.io/categories/Project/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://cheeseburgerim.github.io/tags/Android/"},{"name":"Project","slug":"Project","permalink":"https://cheeseburgerim.github.io/tags/Project/"},{"name":"DaChuang","slug":"DaChuang","permalink":"https://cheeseburgerim.github.io/tags/DaChuang/"},{"name":"DaChuang2021-2022","slug":"DaChuang2021-2022","permalink":"https://cheeseburgerim.github.io/tags/DaChuang2021-2022/"},{"name":"ORB-SLAM2","slug":"ORB-SLAM2","permalink":"https://cheeseburgerim.github.io/tags/ORB-SLAM2/"}]},{"title":"数字逻辑与数字系统-Lab3","slug":"MLAMS/MLAMS-Lab3","date":"2021-05-14T05:33:46.000Z","updated":"2021-06-17T06:32:38.450Z","comments":false,"path":"2021/05/14/MLAMS/MLAMS-Lab3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/05/14/MLAMS/MLAMS-Lab3/","excerpt":"","text":"实验三 分秒数字钟的设计与实现 实验资料 实验源码 实验目的 掌握基于 SystemVerilog HDL 的时序逻辑电路建模方法； 掌握计数器设计方法，并能够使用计数器设计使能时钟（用于时钟分频）； 掌握移位寄存器设计方法，并能够利用移位寄存器设计边沿检测电路； 掌握 7 段数码管的动态显示。 实验内容 基于 SystemVerilog HDL 设计并实现一个分秒数字钟。整个工程的顶层模块 如图 3-6 所示，输入/输出端口如表 3-1 所示。使用 4 个七段数码管显示当前的 计时。其中，两个数码管对应“分”，另两个数码管对应“秒”。通过 1 个拨动开关 对数字钟进行复位控制。使用 1 个按键对数字中进行“暂停/计时”控制，按键每按 下一次，进行暂停和计时的切换，即暂停时，按下按键启动计时；计时过程中， 按下按键暂停计时。 实验原理 详情见实验资料中实验指导书 实验步骤 首先实现边沿检测电路，命名为chk_asc模块。阅读实验指导书可知，i_start可看作一个按钮，每按一次改变一次当前电路的状态。所以chk_asc模块中需要使用到2位移位寄存器，来存储两个状态，可看作现态和次态。 123456789101112131415161718192021222324`timescale 1ns / 1psmodule chk_asc( input sys_clk, input sys_rst_n, input cin, output logic cout ); logic [1:0]temp=0; logic en=0; always_ff @(posedge sys_clk) begin if(sys_rst_n==1) begin temp=&#123;cin,temp[1]&#125;; if(temp[1]==1&amp;&amp;temp[0]==0) en=~en; end else begin temp=0; en=0; end end assign cout=(en==1?1:0);endmodule 然后实现使能时钟生成器，命名为en_clock模块。其中时钟周期为40ns，而七段数码管动态扫描周期为1ms，所以可以得出每经过25000个时钟周期，七段数码管会进行一次扫描。建模时可以使用一个计数器来实现这个功能。同时，分秒数字时钟一共需要4个七段数码管，所以输出an应该有4个状态。 123456789101112131415161718192021222324252627282930`timescale 1ns / 1psmodule en_clock( input sys_clk, input sys_rst_n, output logic [3:0]cout ); integer r_cnt=0; always_ff @(posedge sys_clk) begin if(sys_rst_n==1) begin if(r_cnt==24999) begin if(cout==4&#x27;b0000) cout=4&#x27;b0001; else if(cout==4&#x27;b0001) cout=4&#x27;b0010; else if(cout==4&#x27;b0010) cout=4&#x27;b0100; else if(cout==4&#x27;b0100) cout=4&#x27;b1000; else if(cout==4&#x27;b1000) cout=4&#x27;b0001; r_cnt=0; end else begin r_cnt=r_cnt+1; end end else begin r_cnt=0; cout=4&#x27;b0; end endendmodule 之后实现计时电路，命名为cnt_clock模块。分秒时钟每加1秒需要经过2千500万个40ns的时钟周期。与使能时钟生成器类似，可以使用计数器实现此功能。 1234567891011121314151617181920212223242526272829303132333435363738394041`timescale 1ns / 1psmodule cnt_clock( input sys_clk, input sys_rst_n, input en, output logic [7:0]min, output logic [7:0]sec ); integer cnt=0; integer CNT=0; always_ff @(posedge sys_clk) begin if(sys_rst_n==1) begin if(en==1) begin if(cnt==24999) begin cnt=0; CNT=CNT+1; if(CNT==999) begin CNT=0; sec=sec+1; if(sec==60) begin min=min+1; sec=0; end end end else begin cnt=cnt+1; end end end else begin cnt=0; CNT=0; min=0; sec=0; end endendmodule 还需要写一个BCD码转换为七段数码管信号的模块，命名为BCD_2_7Dig模块。使用case语句即可完成。 123456789101112131415161718192021222324252627282930313233343536`timescale 1ns / 1psmodule BCD_2_7Dig( input [3:0] BCD, output logic [7:0] a_to_g ); always @(*) begin case (BCD) // gfedcba 4&#x27;b0000:a_to_g=8&#x27;b11000000; 4&#x27;b0001:a_to_g=8&#x27;b11111001; 4&#x27;b0010:a_to_g=8&#x27;b10100100; 4&#x27;b0011:a_to_g=8&#x27;b10110000; 4&#x27;b0100:a_to_g=8&#x27;b10011001; 4&#x27;b0101:a_to_g=8&#x27;b10010010; 4&#x27;b0110:a_to_g=8&#x27;b10000010; 4&#x27;b0111:a_to_g=8&#x27;b11011000; 4&#x27;b1000:a_to_g=8&#x27;b10000000; 4&#x27;b1001:a_to_g=8&#x27;b10010000; default: a_to_g=8&#x27;b11111111; endcase // 8&#x27;b11111111:nothing // 8&#x27;b01111111:P(dot) // 8&#x27;b10111111:G // 8&#x27;b11011111:F // ? // 8&#x27;b11101111:E // 8&#x27;b11110111:D // 8&#x27;b11111011:C // 8&#x27;b11111101:B // 8&#x27;b11111110:A // ? endendmodule 完成以上4个模块后，可以在dig_clock中进行实例化了。 需要： 1个cn_clock模块：每个7段数码管扫描周期提供一个使能信号，即输出an，判断当前需要控制哪一个7段数码管； 1个chk_asc模块：通过i_start判断当前时钟的状态； 1个cnt_clock模块：当使能端有效时，进行计时； 2个bin2bcd_0模块(由老师提供)：将cnt_clock模块得到的分和秒的二进制数转换为BCD码； 4个BCD_2_7Dig模块：将所得到的BCD码分成四部分再转换为7段数码管的信号； 此外，由于每次输出a_to_g只能控制一个7段数码管(即实验报告中所提到的，4个7段数码管并不是同时亮或灭，是有规律地高频的切换)，所以要根据cn_clock模块得到的使能信号，给a_to_g赋值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051`timescale 1ns / 1psmodule dig_clock( input sys_clk, input sys_rst_n, input i_start, output logic [3 : 0] an, output logic [7 : 0] a_to_g ); // 输出七段数码管的使能端 logic [3:0] en; en_clock en_clk(sys_clk,sys_rst_n,en); assign an=en; // 输出计时器状态，开始/暂停 logic i_start_en; chk_asc chkasc(sys_clk,sys_rst_n,i_start,i_start_en); // 输出计时器的时间，分+秒 logic [7:0]min; logic [7:0]sec; cnt_clock cnt_clk(sys_clk,sys_rst_n,i_start_en,min,sec); // Binary to BCD logic [7:0]minBCD; logic [7:0]secBCD; bin2bcd_0 minute(min,minBCD); bin2bcd_0 second(sec,secBCD); // BCD to a_to_g logic [7:0] a_to_g_min_01; BCD_2_7Dig min_01(minBCD[3:0],a_to_g_min_01); logic [7:0] a_to_g_min_10; BCD_2_7Dig min_10(minBCD[7:4],a_to_g_min_10); logic [7:0] a_to_g_sec_01; BCD_2_7Dig sec_01(secBCD[3:0],a_to_g_sec_01); logic [7:0] a_to_g_sec_10; BCD_2_7Dig sec_10(secBCD[7:4],a_to_g_sec_10); integer r_cnt=0; always @(*) begin a_to_g=8&#x27;b11111111; if(i_start_en==1) begin if(en==4&#x27;b0000) a_to_g=8&#x27;b11111111; else if(en==4&#x27;b0001) a_to_g=a_to_g_sec_01; else if(en==4&#x27;b0010) a_to_g=a_to_g_sec_10; else if(en==4&#x27;b0100) begin a_to_g=a_to_g_min_01; a_to_g[7]=0; end else if(en==4&#x27;b1000) a_to_g=a_to_g_min_10; end end endmodule 实验主要工作完成，过程中用到了很多仿真文件进行检查。之后进行仿真，运行，生成bin文件，在实验平台运行即可。 实验过程中所用到的所有完整代码均已存放到git仓库中 实验结果 波形图 FPGA 测试截图 测试视频 实验问题 画出分秒数字钟电路的原理图（模块级别即可，如使能时钟模块、边沿 检测模块等） 分秒数字钟电路中一共使用了几个计数器，作用分别是什么？ 答：2个。 第一个用来将时钟频率分频为7段数码管扫描的频率； 第二个用来将时钟频率分频为1Hz，实现计时功能，每秒+1。","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"Android-Process","slug":"Android-Process","date":"2021-05-05T09:01:42.000Z","updated":"2021-05-26T12:39:41.816Z","comments":false,"path":"2021/05/05/Android-Process/","link":"","permalink":"https://cheeseburgerim.github.io/2021/05/05/Android-Process/","excerpt":"","text":"练习源码 学习过程 Process 2021/5/15~Now：学习Android Studio的使用 Hello World MyFirstApp Points 更改AVD默认路径 在想要存放的地方新建文件夹，假设命名为ADK； 打开编辑系统环境变量并点击环境变量； 新建一个系统变量 变量名：ANDROID_SDK_HOME 变量值：ADK文件夹的路径 在AndroidStudio中新建虚拟机即可。","categories":[{"name":"Android","slug":"Android","permalink":"https://cheeseburgerim.github.io/categories/Android/"}],"tags":[{"name":"Develop","slug":"Develop","permalink":"https://cheeseburgerim.github.io/tags/Develop/"},{"name":"Android","slug":"Android","permalink":"https://cheeseburgerim.github.io/tags/Android/"},{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Project","slug":"Project","permalink":"https://cheeseburgerim.github.io/tags/Project/"}]},{"title":"Java-Summary","slug":"Java/Java-Summary","date":"2021-05-04T14:17:54.000Z","updated":"2021-06-17T06:32:09.688Z","comments":false,"path":"2021/05/04/Java/Java-Summary/","link":"","permalink":"https://cheeseburgerim.github.io/2021/05/04/Java/Java-Summary/","excerpt":"","text":"Points 输出Java程序运行时间 1234long l=System.currentTimeMillis();//Java Statements//...System.out.println(System.currentTimeMillis()-l+&quot; ms&quot;); 按行读入文本文件 12345678910111213import java.io.*;try&#123; BufferedReader reader=new BufferedReader(new FileReader(filePath)); String line=reader.readLine(); while(line!=null)&#123; //statements line=reader.readLine(); &#125;&#125;catch(FileNotFoundException e)&#123; e.printStackTrace();&#125;catch(IOException e)&#123; e.printStackTrace();&#125; 修改文本文件中的内容 123456789101112131415161718192021222324252627282930313233343536import java.io.*;public class FileTool&#123; //修改homeDir中的txt文件，包括子目录下的txt文件，将orgStr改为targetStr public void replaceTxtFileContent(String homeDir,String orgStr,String targetStr) &#123; File file=new File(homeDir); if(file.isDirectory()) &#123; for(String str:file.list()) &#123; if(str.endsWith(&quot;.txt&quot;)) &#123; String filename=homeDir+str+&quot;/&quot;; File temp=new File(filename); try &#123; BufferedReader reader=new BufferedReader(new FileReader(filename)); String line=reader.readLine(); //不能直接对line进行修改，因为line是reader读出的数据，不能直接利用字符串修改 String newLine=line.replaceAll(orgStr, targetStr); //需要新建一个字符串，将orgStr替换为targetStr //新建文件输出流 FileOutputStream os=new FileOutputStream(temp); OutputStreamWriter writer=new OutputStreamWriter(os,&quot;UTF-8&quot;); writer.append(newLine);//向缓冲区写入修改后的字符串 writer.close();//关闭writer后，会将缓冲区的数据写入目标文件 &#125; catch (FileNotFoundException e) &#123; System.out.println(filename); e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; File temp=new File(homeDir+str+&quot;/&quot;); if(temp.isDirectory()) &#123; replaceTxtFileContent(homeDir+str+&quot;/&quot;,orgStr,targetStr); &#125; &#125; &#125; &#125;&#125; 查看文件大小 12File file=new File(filePath);long fileSize=file.length(); 等待一段时间后再执行程序 123456TimeUnit.DAYS.sleep(1);//天TimeUnit.HOURS.sleep(1);//小时TimeUnit.MINUTES.sleep(1);//分TimeUnit.SECONDS.sleep(1);//秒TimeUnit.MILLISECONDS.sleep(1000);//毫秒TimeUnit.MICROSECONDS.sleep(1000);//微妙TimeUnit.NANOSECONDS.sleep(1000);//纳秒 向文本文件中写入数据 1234567891011121314151617181920212223242526272829303132//写入数据的函数public void writeByBytes(byte[] bytes) &#123; File file=new File(Base.root+this.fileAddr); if(file.exists()==false) &#123; try &#123; file.createNewFile(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; OutputStream out; try &#123; out = new FileOutputStream(file, false); out.write(bytes); out.flush(); out.close(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;//调用函数按字节写入字符串public static void main(String[] args) &#123; String filePath=&quot;xxx/xxx/.../xxx.txt&quot;; File file=new File(filePath); String content=&quot;abc&quot;; file.writeByBytes(content.getBytes(&quot;UTF-8&quot;));&#125; 动态调用类/函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//创建类MyClassFactorypublic class MyClassFactory &#123; public MyClassFactory(String string) &#123; try &#123; //根据给定init文件初始化类 //Init类中Initialization函数为按行读入路径为string的文件 //并将参数放到map中,键为类的名字,值为为一个map //这个map的键为属性名,值为所读文件中所给的具体值 Init.Initialization(string); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //动态调用创建对象 public &lt;T&gt;T createInstance(Class&lt;T&gt; clazz) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException &#123; //得到类的名字 String className=clazz.getName(); //用泛型新建一个对象 T obj=clazz.newInstance(); //在类map中得到参数map Map&lt;String,Object&gt; parameter=Init.myClasses.get(className); //迭代调用setXXX函数赋值 //其中it为参数map的keySet Iterator&lt;String&gt; it=parameter.keySet().iterator(); while(it.hasNext()) &#123; //property为类的属性名 String property=it.next(); //value为该属性的具体值 Object value=parameter.get(property); //methodName为调用函数的名字,这里为setXXX String methodName=&quot;set&quot;+property.substring(0, 1).toUpperCase()+property.substring(1); //调用函数复制 Method method=obj.getClass().getMethod(methodName, value.getClass()); method.invoke(obj, value); &#125; //返回所建的对象 //即为动态调用创建对象 return obj; &#125;&#125;public class Init&#123; public static Map&lt;String,Map&lt;String,Object&gt;&gt; myClasses=new HashMap(); public static void Initialization(String filename) &#123; //... //按行读入文件 //将文件中所给参数存到myClasses中 &#125; &#125; 多线程解决问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//例如寻找一个大范围内所有的质数然后升序输出//首先创建PrimeUtil类,类中会调用继承Thread类的GetPrimeNum类线程public class PrimeUtil &#123; public long threadStart,threadEnd; public List&lt;Long&gt; primeList=new ArrayList&lt;&gt;(); public PrimeUtil(long ts, long te) &#123; this.threadStart=ts; this.threadEnd=te; &#125; public PrimeUtil() &#123; &#125; public List&lt;Long&gt; getPrimeList(long start, long end, int threadCount) &#123; GetPrimeNum threads[]=new GetPrimeNum[threadCount]; //找start到end之间的质数，运用多线程 //使用threadCount个线程分别计算某个区间 for(int i=0;i&lt;threadCount;i++) &#123; //计算每个区间的起始位置和结束位置 long threadStart=start+i*(end-start)/threadCount; long threadEnd=start+(i+1)*(end-start)/threadCount; threads[i]=new GetPrimeNum(threadStart,threadEnd); //线程开始运行，注意要用start()而不是run() threads[i].start(); &#125; //将每个线程的结果合并得到问题的总结果 for (int i = 0; i &lt; threads.length; i++) &#123; try &#123; threads[i].join(); List&lt;Long&gt; tmp = threads[i].getList(); primeList.addAll(tmp); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //保险起见，使用Collentions对找到的质数进行排序 Collections.sort(primeList); return primeList; &#125;&#125;//创建GetPrimeNum类继承Threadpublic class GetPrimeNum extends Thread&#123; public List&lt;Long&gt; tempList=new ArrayList&lt;&gt;(); public GetPrimeNum(long ts,long te) &#123; this.threadStart=ts; this.threadEnd=te; &#125; public long threadStart,threadEnd; //将线程需要执行的代码写在run()函数中 public void run() &#123; for(long i=this.threadStart;i&lt;this.threadEnd;i++) &#123; if(isPrime(i)) &#123; tempList.add(i); &#125; &#125; &#125; public boolean isPrime(long n) &#123; for(int i=2;i&lt;=Math.sqrt(n);i++) &#123; if(n%i==0) return false; &#125; return true; &#125; public List&lt;Long&gt; getList()&#123; return this.tempList; &#125;&#125; socket编程-服务端和客户端一对一交互 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//创建MyServer类继承Thread类public class MyServer extends Thread &#123; //服务器属性端口号 public int port; //监听函数 public void startListen(int port) &#123; this.port = port; Thread serverListenThread=new Thread(this); serverListenThread.start(); &#125; //线程run函数 public void run() &#123; Socket socket = null; PrintWriter out = null; BufferedReader in = null; try &#123; //新建ServerSocket ServerSocket myServer = new ServerSocket(port); //等待客户端与服务端连接 socket = myServer.accept(); //获得输入输出流 in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out = new PrintWriter(socket.getOutputStream()); String Line = in.readLine(); while (!&quot;bye&quot;.equals(Line)) &#123; out.write(Line + &quot;\\r\\n&quot;); out.flush(); Line = in.readLine(); &#125; in.close(); out.close(); socket.close(); &#125; catch (IOException e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; finally &#123; close(in); close(out); close(socket); &#125; &#125; public static void close(Closeable inout) &#123; if (inout != null) &#123; try &#123; inout.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;//新建Test类进行测试public class Test &#123; public static boolean testEcho(BufferedReader in, PrintWriter out, String line) throws IOException &#123; out.write(line + &quot;\\r\\n&quot;); out.flush(); String echoline = in.readLine(); if (line.equals(echoline)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub // 端口号测试的时候随机给 int port = 8088; // 要求完成MyServer类 new MyServer().startListen(port); Socket socket = null; PrintWriter out = null; BufferedReader in = null; try &#123; socket = new Socket(&quot;127.0.0.1&quot;, port); out = new java.io.PrintWriter(socket.getOutputStream()); // 获得输入流 in = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 随机测试向服务器端输入几句话，要求服务器端原封不动返回 if (testEcho(in, out, &quot;hellow&quot;)) &#123; System.out.println(&quot;ok 1&quot;); &#125; if (testEcho(in, out, &quot;haha&quot;)) &#123; System.out.println(&quot;ok 2&quot;); &#125; // 向服务器端输入bye，断开表示断开连接 out.write(&quot;bye&quot; + &quot;\\r\\n&quot;); out.close(); in.close(); socket.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(in); close(out); close(socket); &#125; &#125; public static void close(Closeable inout) &#123; if (inout != null) &#123; try &#123; inout.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; socket编程-服务端和客户端一对多交互 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//要求客户端发送一个数到服务端//服务端将这个数的两倍发送给客户端//新建MyServer类继承Thread类//监听函数即startListen()中使用while循环等待与客户端连接//如果在服务端开始监听后还需要执行startListen后面的代码,则需要使用线程来监听//否则MyServer无需继承Thread类public class MyServer extends Thread &#123; //服务器属性端口号 public String ip; public int port; public MyServer(String ip,int port) &#123; this.ip=ip; this.port=port; &#125; public MyServer() &#123;&#125; //监听函数 public void startListen() &#123; Thread serverListenThread=new Thread(this); serverListenThread.start(); &#125; //线程run函数 public void run() &#123; try&#123; ServerSocket server=new ServerSocket(this.port); int id=0; while(true) &#123; Socket socket=server.accept(); new Thread(new ServerThread(id,socket)).start(); id++; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;//新建ServerThread继承MyServer类public class ServerThread extends MyServer &#123; public int id; public Socket socket; public ServerThread(int id,Socket socket) &#123; this.id=id; this.socket=socket; &#125; public void run() &#123; try &#123; BufferedReader in = null; BufferedWriter out = null; in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); String line = in.readLine(); int value=2*Integer.valueOf(line); out.write(value); System.out.println(out.toString()); out.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;//新建Client类public class Client &#123; public String name; public String ip; public int port; Socket client = null; BufferedReader in = null; BufferedWriter out = null; public Client(String name,String ip,int port) &#123; this.name=name; this.ip=ip; this.port=port; &#125; private void close() &#123; // TODO Auto-generated method stub try &#123; this.in.close(); this.out.close(); this.client.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void sendMessage(String content) &#123; try &#123; client = new Socket(ip,port); out = new BufferedWriter(new OutputStreamWriter(client.getOutputStream())); out.write(this.name+&quot;:&quot;+content); out.flush(); in = new BufferedReader(new InputStreamReader(client.getInputStream())); System.out.println(in.readLine()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;//新建Test类测试public class Test &#123; public static void main(String[] args) &#123; String ip = &quot;127.0.0.1&quot;; int port = 9090; MyServer myServer; try&#123; myServer=new MyServer(ip,port); myServer.startListen(); Client A=new Client(&quot;A&quot;,ip,port); Client B=new Client(&quot;B&quot;,ip,port); Client C=new Client(&quot;C&quot;,ip,port); System.out.println(&quot;Here&quot;); A.sendMessage(&quot;2&quot;); &#125; finally &#123; &#125; &#125;&#125; 日期与字符串相互转换 1234567891011121314151617181920212223242526272829303132333435363738public class DateDemo &#123; public DateDemo() &#123; &#125; public static void main(String[] args) &#123; try &#123; System.out.println(new java.util.Date()); //日期转换为字符串 String str = dateToStr(new java.util.Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(str); //字符串转换为日期 Date date = strToDate(str, &quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(date); //毫秒转换为日期 long curMills=System.currentTimeMillis(); Date date2=new Date(curMills); System.out.println(date2); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; public static String dateToStr(java.util.Date date, String pattern) &#123; SimpleDateFormat df = new SimpleDateFormat(pattern); return df.format(date); &#125; public static Date strToDate(String date, String pattern) throws ParseException &#123; SimpleDateFormat formatter = new SimpleDateFormat(pattern); java.util.Date outDate = formatter.parse(date); return outDate; &#125;&#125; Codes 练习源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"Windows Tips","slug":"WindowsTips","date":"2021-05-01T06:09:57.000Z","updated":"2021-05-13T07:02:29.866Z","comments":false,"path":"2021/05/01/WindowsTips/","link":"","permalink":"https://cheeseburgerim.github.io/2021/05/01/WindowsTips/","excerpt":"","text":"Windows Tips 使用画图软件压缩图片 找到要压缩的图片，右键→打开方式→画图； 选择重新调整大小； 填写相应数值，CTRL+S保存查看大小，调整到符合要求即可。 获取网页图标favicon 原理 首先要知道在HTML中如何设置favicon 1234567891011121314151617&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;!--Method1--&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;/favicon.png&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;Images/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt; &lt;!--Method2--&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;Images/wangyi.ico&quot; type=&quot;image/x-icon&quot; /&gt; &lt;title&gt;favicon&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Page Content&lt;/body&gt;&lt;/html&gt;&lt;!--favicon of my blog--&gt;&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;https://gitee.com/CheeseburgerIM/imagehosting/raw/master/Image/Home/Web_icon.jpg&quot; /&gt; 在域名后加上herf中的内容回车即可得到网页图标 实例 以Clash官网来举例 打开这个网站 F12打开控制台 在head标签中找到与icon有关的link标签，获得网页图标的地址 /favicon-196x196.png 在域名后加上herf中回车 favicon 注意 并不是所有网站都可以用这个方法","categories":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/categories/Course/"}],"tags":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"Windows","slug":"Windows","permalink":"https://cheeseburgerim.github.io/tags/Windows/"},{"name":"Tips","slug":"Tips","permalink":"https://cheeseburgerim.github.io/tags/Tips/"}]},{"title":"数字逻辑与数字系统-Lab2","slug":"MLAMS/MLAMS-Lab2","date":"2021-04-24T16:04:04.000Z","updated":"2021-06-17T06:32:31.481Z","comments":false,"path":"2021/04/25/MLAMS/MLAMS-Lab2/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/25/MLAMS/MLAMS-Lab2/","excerpt":"","text":"实验二 算术逻辑单元的设计与实现 实验资料 实验源码 实验目的 掌握全加器和行波进位加法器的结构； 熟悉加减法运算及溢出的判断方法； 掌握算术逻辑单元（ALU）的结构； 熟练使用 SystemVerilog HDL 的行为建模和结构化建模方法对 ALU 进行 描述实现； 为“单周期 MIPS 处理器的设计与实现”奠定基础。 实验内容 基于 SystemVerilog HDL 设计并实现一个 4 位 ALU 单元。整个工程的顶层 模块如图 2-4 所示，输入/输出端口如表 2-2 所示。注意，顶层模块由两个子模 块组成，其中，一个是 ALU 单元，另一个是 7 段数码管动态显示扫描单元。同 学们只需要实现 ALU 单元即可，动态显示扫描单元在工程中直接提供。 完成上述 ALU 单元的设计，必需满足如下几点要求： 1. ALU 单元的输入 A 和 B 均是补码形式。 2. 实现加法和减法时，不能使用“+”和“-”两种运算符，且只能通过一个行波 进位加法器和其它必要的逻辑电路实现。 3. 可以使用“*”运算符实现乘法，但该运算符在只适用无符号数的乘法，有 符号数的乘法需要同学们考虑如何处理。 4. 实现算术右移时，可以使用运算符“&gt;&gt;&gt;”。 实验步骤 解压缩 ALU_4bits_stu.rar，打开教师提供的工程文件 ALU_4bits.xpr。目前工程中已经提供了 7 段数码管动态扫描电路的网表文件 （ xseg7_d.edif ） 和 端 口 声 明 文 件 （ xseg7_d_stub.sv ）， 以 及 顶 层 文 件 （ALU_4bits.sv）。前两个有关 7 段数码管的文件无需做任何修改。同学们只 需设计实现图 2-4 中的 ALU 单元； 在工程中，添加文件 fulladder.sv，实现全加器； 1234567891011`timescale 1ns / 1psmodule fulladder(input logic A,input logic B,input logic Cin,output logic S,output logic Cout ); assign S = A^B^Cin; assign Cout = A&amp;B|(Cin&amp;(A^B));endmodule 在工程中，添加文件 rca.sv，调用全加器，实现 4 位行波进位加法器； 123456789101112131415`timescale 1ns / 1psmodule rca(input logic [3:0]A,input logic [3:0]B,input logic Cin,output logic [3:0]S,output logic Cout ); logic [3:0]tempCout; fulladder fa1(A[0],B[0],Cin,S[0],tempCout[0]); fulladder fa2(A[1],B[1],tempCout[0],S[1],tempCout[1]); fulladder fa3(A[2],B[2],tempCout[1],S[2],tempCout[2]); fulladder fa4(A[3],B[3],tempCout[2],S[3],tempCout[3]); assign Cout=tempCout[3];endmodule 在工程中，添加文件 alu.sv，通过调用行波进位加法器和添加必要的逻辑电路实现实验指导书中表2-3所示的所有运算操作。根据顶层文件对 ALU 单元的调用形式； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687`timescale 1ns / 1psmodule alu(input logic [3:0]A,input logic [3:0]B,input logic [3:0]aluop,output logic [7:0]alures,output logic ZF,//isZerooutput logic OF//overflow ); logic Cout1; logic [3:0]re1; rca r1(A,B,0,re1,Cout1); logic Cout2; logic [3:0]re2; rca r2(A,~B+1,0,re2,Cout2); logic Cout3; logic [3:0]re3; rca r3(~A+1,B,0,re3,Cout3); logic Cout4; logic [3:0]re4; rca r4(~A+1,~B+1,0,re4,Cout4); always @(*) begin alures=0; ZF=0; OF=0; case (aluop) 4&#x27;b0000:alures=A&amp;B; 4&#x27;b0001:alures=A|B; 4&#x27;b0010:alures=A^B; 4&#x27;b0011:begin alures=~(A&amp;B); alures[7:4]=4&#x27;b0000; end 4&#x27;b0100:begin alures=~A; alures[7:4]=4&#x27;b0000; end 4&#x27;b0101:alures=A&lt;&lt;B[2:0]; 4&#x27;b0110:alures=A&gt;&gt;B[2:0]; 4&#x27;b0111:begin alures=$signed(A)&gt;&gt;&gt;B[2:0]; alures[7:4]=4&#x27;b0000; end 4&#x27;b1000:alures=A*B; 4&#x27;b1001:alures=$signed(A)*$signed(B); 4&#x27;b1010:begin if(A[3]==0) begin if(B[3]==0) alures=re1; else alures=re2; end else begin if(B[3]==0) alures=re3; else alures=re4; end // alures=~(alures-1); alures[7:4]=4&#x27;b0000; if(Cout1==1) OF=1; else OF=0; end 4&#x27;b1011:begin alures=re1; end 4&#x27;b1100:begin if(A[3]==0) begin if(B[3]==0) alures=re2; else alures=re1; end else begin if(B[3]==0) alures=re4; else alures=re3; end // alures=~(alures-1); alures[7:4]=4&#x27;b0000; if(Cout2==1) OF=1; else OF=0; end 4&#x27;b1101:begin alures=re2; end 4&#x27;b1110:alures=($signed(A)&lt;$signed(B))?1:0; 4&#x27;b1111:alures=(A&lt;B)?1:0; default: ; endcase if(alures==0) ZF=1; else ZF=0; endendmodule 在顶层文件 ALU_4bits.sv 通过结构化建模； 123456789101112131415161718192021222324252627282930313233343536373839`define SIMmodule ALU_4bits( input sys_clk, input sys_rst_n, input [3 : 0] A, input [3 : 0] B, input [3 : 0] aluop, output ov, output zero, output logic [3 : 0] an, output logic [7 : 0] a_to_g ); logic [7:0]alures; logic [3:0]alures0; logic [3:0]alures1; assign alures0=alures[3:0]; assign alures1=alures[7:4]; alu myALU( .A(A), .B(B), .aluop(aluop), .alures(alures), .ZF(zero), .OF(ov) ); x7seg_d U1( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .Y0 (alures0), .Y1 (alures1), .an (an), .a_to_g (a_to_g) ); endmodule 添加测试文件 ALU_4bits_tb.sv，对所实现的 ALU 单元进行行为仿真（注意： 仅对 alu.sv 进行仿真即可，不要仿真整个系统）。仿真过程中必须采用自动化 测试的方法（注：读取文件时，如果不使用绝对路径，请将存放测试向量的 文本文件拷贝到“工程路径/ALU_4bits.sim/sim_1/ behave/xsim”目录下，否则 读取文件将失败）； 1234567891011121314151617181920212223242526`timescale 1ns / 1psmodule alu_tb( ); logic [3 : 0] A; logic [3 : 0] B; logic [3 : 0] aluop; logic [7 : 0] alures; logic [7 : 0] aluresexpected; logic [21 : 0] stim[15:0]; logic OFexpected; logic ZFexpected; logic ZF; logic OF; integer i; alu DUT(.A(A),.B(B),.alures(alures),.aluop(aluop),.ZF(ZF),.OF(OF)); initial begin $readmemb(&quot;alu_test.txt&quot;,stim); for(i=0;i&lt;16;i=i+1)begin &#123;A,B,aluop,aluresexpected,OFexpected,ZFexpected&#125;=stim[i];#20; if(alures==aluresexpected) $display($time,&quot; Test A=%b, B=%b, aluop=%b, alures=%b, aluresecpected=%b, OF=%b, ZF=%b Pass!&quot;,A,B,aluop,alures,aluresexpected,OFexpected,ZFexpected); else $display($time,&quot; Test A=%b, B=%b, aluop=%b, alures=%b, aluresecpected=%b, OF=%b, ZF=%b Wrong!&quot;,A,B,aluop,alures,aluresexpected,OFexpected,ZFexpected); end end endmodule 如果第 6 步行为仿真通过，则对工程进行综合、实现、生成 bin 文件。注意， 约束文件已在工程中提供，不需要再添加； 登录远程 FPGA 硬件云平台，直接导入教师提供的验证平台文件（4 位算术逻 辑单元(ALU).epl），无需进行绘制，验证平台如图 2-6 所示。其中操作数 A、 B 以及操作类型控制信号 aluop 通过多位输入控件进行控制；使用 4 位七段 数码管显示 ALU 的运算结果（最低位数码管用于显示非乘法结果或乘法结果 module alu( input [3 : 0] A, input [3 : 0] B, input [3 : 0] aluop, output logic [7 : 0] alures, output logic ZF, output logic OF ); 的低 4 位，次低位数码管显示乘法结果的高 4 位，剩下两位数码管在本实验 中不被点亮）；使用 2 个 LED 灯显示溢出标志 ov 和零标志 zero。烧写所生成 的 bin 文件，然后运行实验，通过调整操作数 A、B 和 aluop 的值验证所设计 ALU 的正确性。 实验结果 仿真结果 波形图 FPGA 实验思考 画出实现加/减法运算的逻辑电路原理图，并说明为什么加/减法可以只 使用一个加法器进行实现？ 对于无符号数加法 上图为全加器的逻辑电路原理图，本实验的行波进位加法器由全加器构成，通过前一个全加器的Cout与后一个全加器的Cin进行连接。对于无符号数加法，就是将两个无符号数A,B输入即可得到结果。 对于无符号数减法 将-B变为+(-B)，所以在加法器的输入端输入A，~B+1即可。 对于有符号数加减法 与无符号数减法同理，只不过最高位变为符号位，计算方法相同。根据不同情况调整输入即可。 减法可以看成加上一个数的相反数，即A-B=A+(-B)，而-B的补码是B的补码取反加1，所以可以使用一个加法器实现。 给出有符号数加/减法溢出的判断规则？ 通过全加器的Cout来判断，当Cout为1时一定溢出，当Cout为0时不一定溢出，此时要判断这个0是否为原本为1的最高位再+1得来，如果是这种情况，则说明溢出，否则不溢出。","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"数据库原理-Lab1","slug":"DataBase/DataBasePrinciple-Lab1","date":"2021-04-23T09:21:28.000Z","updated":"2021-06-17T06:29:50.391Z","comments":false,"path":"2021/04/23/DataBase/DataBasePrinciple-Lab1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/23/DataBase/DataBasePrinciple-Lab1/","excerpt":"","text":"实验目的 通过上机练习巩固关系数据模型及其基本概念； 通过上机练习巩固关系数据库语言SQL； 通过上机练习巩固关系数据库设计方法。 实验原理 采用PostgreSQL数据库作为实验用DBMS； 用E/R图建立数据库的概念模型； 将E/R模型转换为关系模型； 用SQL创建数据库模式； 将数据批量装载到数据库中； 用SQL进行查询和更新操作。 实验内容 详情请查看实验指导书 实验步骤 建表 12345678910111213141516171819202122232425262728293031323334353637383940414243CREATE TABLE employees( emp_no INT, birth_date DATE, first_name VARCHAR, last_name VARCHAR, gender VARCHAR, hire_date DATE, CONSTRAINT pk_employees PRIMARY KEY(emp_no));CREATE TABLE titles( emp_no_IN_titles INT, title VARCHAR, from_date DATE, to_date DATE, CONSTRAINT fk_titles_employees FOREIGN KEY(emp_no_IN_titles) REFERENCES employees(emp_no) ON DELETE SET NULL ON UPDATE SET NULL);CREATE TABLE salaries( emp_no_IN_salaries INT, salary INT, from_date DATE, to_date DATE, CONSTRAINT fk_salaries_employees FOREIGN KEY(emp_no_IN_salaries) REFERENCES employees(emp_no));CREATE TABLE departments( dept_no VARCHAR, dept_name VARCHAR, CONSTRAINT pk_departments PRIMARY KEY(dept_no));CREATE TABLE dept_emp( emp_no_IN_dept_emp INT, dept_no_IN_dept_emp VARCHAR, from_date DATE, to_date DATE);CREATE TABLE dept_manager( dept_no_IN_dept_manager VARCHAR, salary INT, from_date DATE, to_date DATE, CONSTRAINT fk_dept_manager_departments FOREIGN KEY(dept_no_IN_dept_manager) REFERENCES departments(dept_no)); 导入数据 123456COPY employees FROM &#x27;/root/resources/data_employees.txt&#x27;delimiter &#x27;,&#x27;;COPY titles FROM &#x27;/root/resources/data_titles.txt&#x27;delimiter &#x27;,&#x27;;COPY salaries FROM &#x27;/root/resources/data_salaries.txt&#x27;delimiter &#x27;,&#x27;;COPY departments FROM &#x27;/root/resources/data_departments.txt&#x27;delimiter &#x27;,&#x27;;COPY dept_emp FROM &#x27;/root/resources/data_dept_emp.txt&#x27;delimiter &#x27;,&#x27;;COPY dept_manager FROM &#x27;/root/resources/data_dept_manager.txt&#x27;delimiter &#x27;,&#x27;; 查看是否导入成功 123456SELECT COUNT(*) FROM employees;--CorrectSELECT COUNT(*) FROM titles;--CorrectSELECT COUNT(*) FROM salaries;--CorrectSELECT COUNT(*) FROM departments;--CorrectSELECT COUNT(*) FROM dept_emp;--CorrectSELECT COUNT(*) FROM dept_manager;--Correct 按要求查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123-- 1-- 返回前10行员工数据。-- （提示：用LIMIT关键字，具体用法查文档）SELECT *FROM employeesLIMIT 10;-- 2-- 查询first_name为Peternela且last_name为Anick的员工的编号、出生日期、性别和入职日期。SELECT emp_no,birth_date,gender,hire_dateFROM employeesWHERE first_name=&#x27;Petermela&#x27; AND last_name=&#x27;Anick&#x27;;-- 3-- 查询出生日期在1961-7-15（包括）到1961-7-20（包括）之间的员工的编号、姓名和出生日期。SELECT emp_no,CONCAT(last_name,first_name) AS emp_name,birth_dateFROM employeesWHERE birth_date&gt;=&#x27;1961-7-15&#x27; AND birth_date&lt;=&#x27;1961-7-20&#x27;;-- 4-- 查询所有first_name中含有前缀Peter或last_name中含有前缀Peter的员工数据（返回所有列）。SELECT *FROM employeesWHERE first_name LIKE &#x27;Peter%&#x27; OR last_name LIKE &#x27;Peter%&#x27;;-- 5-- 查询工资数额的最大值，并将查询结果的列名命名为max_salary。SELECT MAX(salary) AS max_salaryFROM salaries;-- 6-- 查询部门编号及相应部门的员工人数，并按照部门编号由小到大的顺序排序（将员工人数列命名为dept_emp_count）。SELECT dept_no_IN_dept_emp,COUNT(emp_no_IN_dept_emp) AS dept_emp_countFROM dept_empGROUP BY dept_no_IN_dept_empORDER BY dept_no_IN_dept_emp ASC;-- 7-- 查询员工“Peternela Anick”的员工编号、所在部门编号和在该部门的工作起始时间。SELECT emp_no,dept_no_IN_dept_emp,from_dateFROM employees,dept_empWHERE CONCAT(first_name,&#x27; &#x27;,last_name)=&#x27;Peternela Anick&#x27;;-- 8-- 查询姓名相同的员工x和员工y的编号和姓名（只列出前10行结果）。SELECT CONCAT(emp1.first_name,&#x27; &#x27;,emp1.last_name),emp1.emp_no,emp2.emp_noFROM employees emp1,employees emp2WHERE emp1.emp_no&lt;&gt;emp2.emp_no AND emp1.last_name=emp2.last_name AND emp1.first_name=emp2.first_name;-- 9 -- 查询姓名为“Margo Anily”的员工编号和出生日期为“1959-10-30”且入职日期为“1989-09-12”的员工编号的并集。SELECT emp_noFROM employeesWHERE (first_name=&#x27;Margo&#x27; AND last_name=&#x27;Anily&#x27;) OR (hire_date=&#x27;1989-09-12&#x27; AND birth_date=&#x27;1959-10-30&#x27;);-- 10-- 查询员工“Margo Anily”所在的部门的名称（要求用子查询实现）。SELECT dept_nameFROM departmentsWHERE dept_no IN (SELECT dept_no_IN_dept_empFROM departments,employees,dept_emp WHERE emp_no=emp_no_IN_dept_emp AND first_name=&#x27;Margo&#x27; AND last_name=&#x27;Anily&#x27;);-- 11-- 要求用JOIN…ON连接语法实现查询10。SELECT dept_nameFROM dept_emp JOIN departmentsON dept_emp.dept_no_IN_dept_emp=departments.dept_noWHERE emp_no_IN_dept_emp IN (SELECT emp_noFROM employeesWHERE first_name=&#x27;Margo&#x27; AND last_name=&#x27;Anily&#x27;);-- 12-- 查询在全部部门中工作过的员工的编号和姓名（提示：用NOT EXISTS连接的子查询）。SELECT COUNT(*) AS dept_count FROM departments;--number of deptsSELECT COUNT(*) AS emp_dept_count FROM dept_emp GROUP BY emp_no_IN_dept_emp;--number of depts each emp works inSELECT list2.emp_no_IN_dept_empFROM(SELECT COUNT(*) AS dept_count FROM departments) list1,(SELECT COUNT(*) AS emp_dept_count,emp_no_IN_dept_emp FROM dept_emp GROUP BY emp_no_IN_dept_emp) list2WHERE list1.dept_count=list2.emp_dept_count; -- 13-- 查询员工人数大于等于50000的部门编号、部门名称和部门员工人数，按照部门编号由小到大的顺序排序（将部门员工人数列命名为dept_emp_count）。SELECT dept_no,dept_name,dept_emp_countFROM departments,(SELECT dept_no_IN_dept_emp,COUNT(emp_no_IN_dept_emp) AS dept_emp_countFROM dept_empGROUP BY dept_no_IN_dept_empHAVING COUNT(*)&gt;50000ORDER BY dept_no_IN_dept_emp ASC) listWHERE dept_no=list.dept_no_IN_dept_emp;-- listSELECT dept_no_IN_dept_emp,COUNT(emp_no_IN_dept_emp) AS dept_emp_countFROM dept_empGROUP BY dept_no_IN_dept_empHAVING COUNT(*)&gt;50000ORDER BY dept_no_IN_dept_emp ASC;-- 14-- 在员工表中添加一行记录：-- (10000, 1981-10-1, Jimmy, Lin, M, 2011-12-8)INSERT INTO employees VALUES(10000,&#x27;1981-10-1&#x27;,&#x27;Jimmy&#x27;,&#x27;Lin&#x27;,&#x27;M&#x27;,&#x27;2011-12-8&#x27;);-- 15-- 将14添加的员工记录的first_name属性值修改为Jim。UPDATE employeesSET first_name=&#x27;Jim&#x27;WHERE emp_no=10000;-- 16-- 删除14添加的员工记录。DELETE FROM employeesWHERE emp_no=10000;-- 17-- 在员工表中添加一行记录：-- (10001, 1981-10-1, Jimmy, Lin, M, 2011-12-8)，观察执行输出结果。INSERT INTO employees VALUES(10001,&#x27;1981-10-1&#x27;,&#x27;Jimmy&#x27;,&#x27;Lin&#x27;,&#x27;M&#x27;,&#x27;2011-12-8&#x27;);-- 18-- 删除编号为10001的员工，观察执行输出结果。DELETE FROM employeesWHERE emp_no=10001; 实验总结 通过实验一的建表语句，查询语句等，体会到了主键与外键的作用。首先说主键，在一个表中主键一定是唯一的，而且主键一定可以决定唯一一条记录，就像由一个人的身份证号可以得到他的姓名，出生年月等信息。而外键指的其实就是另一个表中的主键，且外键可以不唯一。可以根据使用的的意图设定主键与外键。此外，通过定义主键和外键可以维护数据库的完整性。在实验过程中，由于是第一次引入大量数据，处理表的定义以及各表之间的关系时很容易出错，需要删了重新建表(我使用的是DROP TABLE语句)，再重新引入数据。这让我想到如果是在一个企业或者一个项目中，数据库是非常重要的一部分，不应该有任何的纰漏和瑕疵，即使是在有备份的情况下，也要谨慎的建表，主键以及外键。在实验第五部分中，我认为不同的查询语句可能得到相同的结果，但性能不完全相同，一个好的技术人员应该懂得如何既简单又快速的查询到需要的信息。以上是我实验一的实验总结。","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/tags/DataBase/"},{"name":"DataBasePrinciple","slug":"DataBasePrinciple","permalink":"https://cheeseburgerim.github.io/tags/DataBasePrinciple/"}]},{"title":"数字逻辑与数字系统-Lab1","slug":"MLAMS/MLAMS-Lab1","date":"2021-04-22T10:24:31.000Z","updated":"2021-06-17T06:32:23.965Z","comments":false,"path":"2021/04/22/MLAMS/MLAMS-Lab1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/22/MLAMS/MLAMS-Lab1/","excerpt":"","text":"实验一 多数表决器的设计与实现 实验资料 实验源码 Phase1(基于集成电路模块) 实验要求 采用 SystemVerilog HDL 的行为建模方法，完成 74LS138 和 74LS139 两种译码器的设计。 基于 SystemVerilog HDL 的结构化建模方法，调用 74LS138 和 74LS139 两种译码器，以及若干基本逻辑门，完成 5 输入多数表 决器电路的设计（类似搭积木），并基于 Vivado 完成行为仿真、综合、实现、 生成比特流文件等操作，最终在远程 FPGA 硬件云平台上完成功能验证。 实验思路 5输入多路表决器由1个2-4译码器和4个3-8译码器组成。5路输入的其中两路首先连到2-4译码器上，使能端始终为0，即2-4译码器输出均为有效输出。2-4译码器共有4个输出，每个输出为一位2进制数，每个输出均连接到一个3-8译码器的其中一个使能端，将另外两个使能端设置为有效值。5输入多数表决器应有2的5次方即32种结果，2-4译码器的输出有4种结果，3-8译码器的输出有8种结果，将每个2-4译码器的一个输出连接到3-8译码器使能端时，刚好4×8=32种输出。 实验步骤 打开 Vivado 2018.2 集成开发环境，创建一个名字为“voter_ic”的新工程； 添加第 1 个 SystemVerilog 设计源文件“dec_74LS138.sv”。根据表 1-1(在实验指导书中)， 采用行为建模方法，完成 3:8 译码器 74LS138 的设计； 12345678910111213141516171819`timescale 1ns / 1psmodule dec_74LS138(input [2:0]D,input G,input G2A,input G2B,output logic [7:0]Y ); logic valid; assign valid=G&amp;(~G2A)&amp;(~G2B); assign Y[0]=~(valid&amp;~D[2]&amp;~D[1]&amp;~D[0]); assign Y[1]=~(valid&amp;~D[2]&amp;~D[1]&amp;D[0]); assign Y[2]=~(valid&amp;~D[2]&amp;D[1]&amp;~D[0]); assign Y[3]=~(valid&amp;~D[2]&amp;D[1]&amp;D[0]); assign Y[4]=~(valid&amp;D[2]&amp;~D[1]&amp;~D[0]); assign Y[5]=~(valid&amp;D[2]&amp;~D[1]&amp;D[0]); assign Y[6]=~(valid&amp;D[2]&amp;D[1]&amp;~D[0]); assign Y[7]=~(valid&amp;D[2]&amp;D[1]&amp;D[0]);endmodule 添加第 2 个 SystemVerilog 设计源文件“dec_74LS139.sv”。根据表 1-2(在实验指导书中)， 采用行为建模方法，完成 2:4 译码器 74LS139 的设计； 1234567891011`timescale 1ns / 1psmodule dec_74LS139(input S,input [1:0]D,output logic [3:0]Y ); assign Y[0]=~(~S&amp;~D[1]&amp;~D[0]); assign Y[1]=~(~S&amp;~D[1]&amp;D[0]); assign Y[2]=~(~S&amp;D[1]&amp;~D[0]); assign Y[3]=~(~S&amp;D[1]&amp;D[0]);endmodule 根据表 1-4(在实验指导书中)，采用 4 个 74LS138 模块、1 个 74LS139 模块和基本逻辑门 电路实现 5 输入多数表决器（这步不是在 Vivado 中完成，而是给出设计方案）； 继续在工程 voter_ic 中添加第3 个 SystemVerilog 设计源文件“voter5.sv”。 然后，根据第(4)步的设计方案，采用结构化建模方法，通过实例化 74LS138 模 块、74LS139 模块以及基本逻辑门完成 5 输入多数表决器的设计； 123456789101112131415161718192021`timescale 1ns / 1psmodule voter5(input [4:0]l,output logic led ); logic [3:0]lt; dec_74LS139 lastTwo(0,l[1:0],lt); logic [7:0]ft1; logic [7:0]ft2; logic [7:0]ft3; logic [7:0]ft4; dec_74LS138 firstThree1(l[4:2],1,lt[0],0,ft1);//0 00 dec_74LS138 firstThree2(l[4:2],1,lt[1],0,ft2);//1 01 dec_74LS138 firstThree3(l[4:2],1,lt[2],0,ft3);//1 10 dec_74LS138 firstThree4(l[4:2],1,lt[3],0,ft4);//2 11 assign led=(~ft1[7]) ||(~ft2[3])||(~ft2[5])||(~ft2[6])||(~ft2[7]) ||(~ft3[3])||(~ft3[5])||(~ft3[6])||(~ft3[7]) ||(~ft4[1])||(~ft4[2])||(~ft4[3])||(~ft4[4])||(~ft4[5])||(~ft4[6])||(~ft4[7]); // &amp;&amp;(ft4[0]);endmodule 编写测试程序“voter5_tb.sv”，对 5 输入多数表决器进行行为仿真，验证 其逻辑功能是否正确； 12345678910111213141516171819202122232425`timescale 1ns / 1psmodule voter5_tb( ); logic [4:0] I; logic led; voter5 dut(.l(I),.led(led)); initial begin I=5&#x27;b00000;#20; I=5&#x27;b00001;#20; I=5&#x27;b00010;#20; I=5&#x27;b10010;#20; I=5&#x27;b11000;#20; I=5&#x27;b11100;#20; I=5&#x27;b10110;#20; I=5&#x27;b10011;#20; I=5&#x27;b11110;#20; I=5&#x27;b11111;#20; I=5&#x27;b11011;#20; I=5&#x27;b01010;#20; $finish; end initial begin $monitor($time,&quot;I=%b,led=%b&quot;,I,led); endendmodule 如果仿真通过，则继续完成添加约束文件、综合、实现和生成比特流等 设计流程； 1234567891011#Constraints of input ports lset_property -dict &#123;PACKAGE_PIN B9 IOSTANDARD LVCMOS33&#125; [get_ports &#123;l[0]&#125;];set_property -dict &#123;PACKAGE_PIN D11 IOSTANDARD LVCMOS33&#125; [get_ports &#123;l[1]&#125;];set_property -dict &#123;PACKAGE_PIN B11 IOSTANDARD LVCMOS33&#125; [get_ports &#123;l[2]&#125;];set_property -dict &#123;PACKAGE_PIN B12 IOSTANDARD LVCMOS33&#125; [get_ports &#123;l[3]&#125;];set_property -dict &#123;PACKAGE_PIN A10 IOSTANDARD LVCMOS33&#125; [get_ports &#123;l[4]&#125;];#Constraints of output ports ledset_property -dict &#123;PACKAGE_PIN K13 IOSTANDARD LVCMOS33&#125; [get_ports &#123;led&#125;];set_property BITSTREAM GENERAL.COMPRESS TRUE [current_design] 登录远程 FPGA 硬件云平台，参照“基于 Vivado 和远程硬件平台的数字 逻辑电路设计流程”一文，按照如图 1-4 (在实验指导书中)所示，在实验画纸搭建验证平台，然后， 将所生成的 bin 文件下载到远程 FPGA 之上完成功能验证。 实验结果 仿真结果 波形图 FPGA测试 Phase2(基于行为建模) 实验要求 不使用 74LS138 和 74LS139 芯片，直接使用行为建模的方法完成 5 输入多数 表决器电路的设计，并基于 Vivado 完成电路的行为仿真、综合、实现、生成 比特流文件等操作，最终在远程 FPGA 硬件云平台上完成功能验证。 实验步骤 打开 Vivado 2018.2 集成开发环境，创建一个名为“voter_beh”的新工程； 添加一个 SystemVerilog 设计源文件“voter5.sv”，采用行为建模的方式 完成 5 输入多数表决器电路的建模； 12345678910111213141516`timescale 1ns / 1psmodule voter5( input [4:0]l, output logic led ); assign led=(l[0]&amp;&amp;l[1]&amp;&amp;l[2]) ||(l[0]&amp;&amp;l[1]&amp;&amp;l[3]) ||(l[0]&amp;&amp;l[1]&amp;&amp;l[4]) ||(l[0]&amp;&amp;l[2]&amp;&amp;l[3]) ||(l[0]&amp;&amp;l[2]&amp;&amp;l[4]) ||(l[0]&amp;&amp;l[3]&amp;&amp;l[4]) ||(l[1]&amp;&amp;l[2]&amp;&amp;l[3]) ||(l[1]&amp;&amp;l[2]&amp;&amp;l[4]) ||(l[1]&amp;&amp;l[3]&amp;&amp;l[4]) ||(l[2]&amp;&amp;l[3]&amp;&amp;l[4]);endmodule 编写测试程序“voter5_tb.sv”，对 5 输入多数表决器进行行为仿真，验证 其逻辑功能是否正确； 12345678910111213141516171819202122232425`timescale 1ns / 1psmodule voter5_tb( ); logic [4:0] I; logic led; voter5 dut(.l(I),.led(led)); initial begin I=5&#x27;b11111;#20; I=5&#x27;b11110;#20; I=5&#x27;b11101;#20; I=5&#x27;b01101;#20; I=5&#x27;b00111;#20; I=5&#x27;b00011;#20; I=5&#x27;b01001;#20; I=5&#x27;b01100;#20; I=5&#x27;b00001;#20; I=5&#x27;b00000;#20; I=5&#x27;b00100;#20; I=5&#x27;b10101;#20; $finish; end initial begin $monitor($time,&quot;I=%b,led=%b&quot;,I,led); endendmodule 如果仿真通过，则继续完成添加约束文件、综合、实现和生成比特流等 设计流程； 1234567891011#Constraints of input ports lset_property -dict &#123;PACKAGE_PIN B9 IOSTANDARD LVCMOS33&#125; [get_ports &#123;l[0]&#125;];set_property -dict &#123;PACKAGE_PIN D11 IOSTANDARD LVCMOS33&#125; [get_ports &#123;l[1]&#125;];set_property -dict &#123;PACKAGE_PIN B11 IOSTANDARD LVCMOS33&#125; [get_ports &#123;l[2]&#125;];set_property -dict &#123;PACKAGE_PIN B12 IOSTANDARD LVCMOS33&#125; [get_ports &#123;l[3]&#125;];set_property -dict &#123;PACKAGE_PIN A10 IOSTANDARD LVCMOS33&#125; [get_ports &#123;l[4]&#125;];#Constraints of output ports ledset_property -dict &#123;PACKAGE_PIN K13 IOSTANDARD LVCMOS33&#125; [get_ports &#123;led&#125;];set_property BITSTREAM GENERAL.COMPRESS TRUE [current_design] 参照阶段 1，在远程 FPGA 硬件云平台上完成功能验证。 实验结果 仿真结果 波形图 FPGA测试 附加题 只采用74LS138译码器和一些基本逻辑门，是否也可以完成5输入多数表决器的设计？如果可以，请画出原理图。 74LS139也就是2-4译码器，可以由一些基本逻辑门组成。所以只要三、实验原理与步骤中的原理图中的2-4译码器换成下图即可只采用74LS138译码器和一些基本逻辑门就可完成5输入多路表决器的设计。 番外话 ​ 在本次实验中，我们学习了组合逻辑电路的设计方法，包括行为建模、结构 化建模。特别是我们讲解了基于集成电路模块的数字逻辑电路设计。在实际工程 设计中，搭建一个复杂的数字系统并不需要完全从零开始进行设计。通常采用的 方法就是选取一些已有的（开源或付费）、已经经过验证的集成电路模块，对其 进行集成从而完成最终设计。这种设计方法称为可重用设计方法学，而这些集成 电路模块称为 IP 核。 ​ 在现代数字集成电路设计中，可重用设计方法学至关重要，也就是说某个模 块会被多个数字系统重复使用。支持可重用设计方法学的基础就是 IP 核，即知 识产权核（Intellectual Property），它是指某一方提供的、预先设计好的并已经经 过验证的、具有某种确定功能的可重用逻辑模块。设计人员常以 IP 核为基础进 行数字系统设计，可以大大缩短设计所需的周期，也降低了设计难度。因此，现 代数字系统的设计人员更多关注的并非模块的设计，而是模块（IP 核）的集成。 IP 核主要分为两大类，软核和硬核。 ⚫ 软核：与具体工艺无关的、可综合的 HDL 代码，其优点是灵活性高、可移植 性强，允许用户自配置；缺点是对模块的预测性较低，在后续设计中存在发 生错误的可能性，有一定的设计风险。软核是 IP 核应用最广泛的形式。本实 验中所设计的 74LS138 和 74LS139 模块就是一种软核。 ⚫ 硬核：与具体工艺相关的、经过了布局布线和验证的网表文件，设计人员不 能对其进行修改。其优点是模块具有稳定的性能、正确性得以最大的保障、 设计风险几乎为零；缺点是灵活性差、不能修改、使用范围窄。 ​ Vivado 集成开发环境提倡的是积木式的设计，设计者将功能性模块做成一 个一个的 IP 核，然后组装起来成为产品。Vivado 本身也提供了很多 IP 核供设计 者使用，例如算术运算（乘法、除法、浮点运算等）、信号处理（FFT、DFT）、图 像处理、各类存储器等（在 Vivado 的流程导航栏中选择 PROJECT Manager → IP Catalog 即可调出 Vivado 的 IP 库，查看其所提供的所有 IP 核）。另外，设计 者也可以使用第三方 IP 核来加快设计。当然设计者也可以开发自己的 IP 核，然 后在各个工程中调用或提供给第三方使用。","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"数字逻辑与数字系统-Part4","slug":"MLAMS/MLAMS-Part4","date":"2021-04-21T10:47:28.000Z","updated":"2021-06-17T06:33:25.037Z","comments":false,"path":"2021/04/21/MLAMS/MLAMS-Part4/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/21/MLAMS/MLAMS-Part4/","excerpt":"","text":"Chapter4 引言 时序逻辑电路定义 时序逻辑电路的输出由当前时刻的输入和之前时刻的输入共同决定； 时序逻辑电路内部具有记忆； 一些基本概念 状态：用于解释电路未来行为所需的信息； 锁存器与触发器：用于存储1比特状态的模块； 同步时序逻辑电路：一类由组合逻辑和一组表示电路状态的触发器所构成的电路。 时序逻辑电路特征 按照一定的输入输出时序实现功能； 电路内部具有短期记忆； 在输出与输入之间具有反馈回路。 锁存器和触发器 电路中的状态 电路中的状态会影响电路未来的行为； 一些常见的电路状态存储模块 双稳态电路； SR锁存器； D锁存器； D触发器。 双稳态电路 定义 双稳态电路是其他存储模块的基础； 下图两个电路具有以下特点： 对称性； 有两个输出：Q和Q； 没有输入。 分析 由以上分析可以看到，电路存在两种状态，用0和1表示，可以用这两种状态存储1比特二进制状态； 但该电路中没有输入端，无法控制电路中状态的存储。 SR锁存器(Latch) 定义 SR锁存器 两个输入端(激励信号)； 两个输出端(状态)。 考虑以下四种输入情况 S=1，R=0； S=0，R=1； S=0，R=0； S=1，R=1。 分析 总结 SR锁存器是一个存储1比特状态的双稳态模块 SR分别表示置位(Set)和复位(Reset) 通过控制S、R信号的输入，控制锁存器的状态 Set置位，使Q=1(S=1，R=0)； Reset复位，使Q=0(S=0，R=1)； 保持，使Qn+1=Qn(S=0，R=0)； 禁止输入，S=R=1。 D锁存器 定义 包含两个输入端：CLK，D CLK：控制锁存器状态发生改变的时间； D：数据输入，控制下一个状态的值。 功能 当CLK=1时，Qn=D，Q跟随D进行变化，D锁存器是透明的； 当CLK=0时，Qn+1=Qn，Q保持原先的状态，D锁存器是不透明的。 D锁存器避免了SR锁存器中S和R信号同时有效而造成的奇怪情况。 实现 D触发器(Flip-flop) 定义 包含两个输入端：CLK，D 功能 在CLK的上升沿对D进行采样 当CLK的信号从0到1的瞬间，Q被修改为当前时刻D的值； 在其他时刻，Q处于保持状态。 Q的值只会在CLK的上升沿时刻发生改变 这种工作模式被称为边沿触发。 主从式D触发器的实现 由两个顺序连接的D锁存器构成(L1,L2)； 由一组相反的时钟信号所控制。 当CLK=0时 主锁存器L1是透明的； 从锁存器L2是不透明的； 主锁存器的状态(N1)跟随D变化。 当CLK=1时 主锁存器L1是不透明的； 从锁存器L2是透明的； 从锁存器的状态跟随N1变化。 因此在时钟的上升沿时刻(CLK 0→1) Q被赋值为D。 带使能端的D触发器 三个输入端：CLK，D，EN EN为使能端：用来控制D是否能被触发器存储 功能(EN信号高电平有效) EN=1：在时钟上升沿时，Q被更新为当前时刻的D值； EN=0：触发器处于保持状态。 带复位功能的D触发器 三个输入端：CLK，D，Reset 功能(Reset信号高电平有效) Reset=1：Q被强制设置为0； Reset=0：触发器正常工作。 同步复位 只在CLK上升沿进行复位。 异步复位 只要Reset信号有效即可复位。 带置位功能的D触发器 三个输入端：CLK，D，Set 功能(Set信号高电平有效) Set=1：Q被强制设置为1； Set=0：触发器正常工作。 D锁存器与D触发器 寄存器(Register) 一个N位寄存器由一个共享的CLK输入和N个D触发器组成； 寄存器的所有位同时被更新； 是大多数时序电路中的关键组件。 同步逻辑设计 时序逻辑电路 时序逻辑电路：所有不是组合逻辑的电路 电路的输出不能简单地通过观察当前输入来决定。 一个有问题的电路 没有输入； 有1-3个输出。 非稳态电路 电路特征 非稳态电路； 输出结果周期性地翻转； 电路中具有回路，输出端反馈至输入端。 环形振荡器 同步时序电路 定义 在信号传播路径中插入寄存器以断开电路中环路 使电路转变成组合逻辑电路和寄存器的集合。 寄存器包含系统的状态； 状态仅在始终边沿(上升沿或下降沿)到达时发生改变 即状态同步与时钟信号。 如果时钟足够慢，使得在下一个时钟沿到达之前，输入寄存器的信号都可以稳定下来，则所有的冒险将被消除； 一个时序电路包含一组有限的离散状态(S0,S1,S2…Sk-1)； 同步时序电路有一个时钟输入； 上升沿表示电路状态转变发生的时间 当前状态(现态)：当前系统的状态； 下一个状态(次态)：下一个时钟沿后系统将进入的状态。 功能规范： 描述当前状态和输入的各种组合所对应的下一个状态和输出。 时序规范： 建立时间、保持时间。 组成规则 组成规则： 电路中的模块或者是寄存器或者是组合逻辑电路； 模块中至少包含一个寄存器； 所有的寄存器都共用一个时钟信号； 电路的每个环路至少包含一个寄存器。 两类常见的同步时序逻辑电路 有限状态机(FSM)； 流水线。 一个简单的同步时序电路实例 一个D触发器是一个最简单的同步时序电路 包含一个输入D； 一个时钟CLK； 一个输出Q； 两个状态(0,1)。 D触发器功能规范 下一个状态是D； 输出Q是当前状态。 思考：下列那些电路是同步时序电路？ F，模块可以是组合逻辑电路，但模块中必须包含一个寄存器； T，电路中的模块或者是寄存器或者是组合逻辑电路，寄存器又是由触发器组成； F，图中为锁存器； T，电路的每个环路至少包含一个寄存器； T； F，电路的每个环路至少包含一个寄存器； 如果三个CLK相同，T，所有的寄存器都共用一个时钟信号； 反之，F。 异步时序电路 非同步的时序电路称为异步时序电路； 理论上，异步时序电路设计比同步时序电路更通用 系统的时序不由时钟控制的寄存器所约束。 实际上，几乎所有的系统本质上都是同步的 同步时序电路比异步时序电路更容易设计。 有限状态机 有限状态机结构 由以下模块组成 状态寄存器 存储当前时刻的状态； 状态在下一个有效时钟沿发生改变。 组合逻辑 计算下一个状态； 计算电路的输出。 Moore和Mealy型有限状态机 次态由现态和当前输入共同决定； 根据输出逻辑的不同，可以将有限状态机分为两类 Moore型：输出仅由当前时刻状态所决定； Mealy型：输出由当前时刻状态和输入共同决定。 例：交通灯控制器 设计 输入：两个交通传感器TA和TB 当路上有人出现时，传感器返回TRUE； 否则返回FALSE。 输出：两个交通灯LA和LB 红色、黄色和绿色。 周期为5s的时钟，在每一个时钟沿到达时，灯根据交通传感器来改变； 一个复位按键，可以使交通灯控制器回到初始状态。 有限状态机黑盒视图 输入：CLK，Reset，TA，TB； 输出：LA，LB。 状态转换图 图中的每一个圆圈代表一个状态； 图中的每一个圆弧代表两个状态之间的转换； 圆弧上的项表示实现状态转换所需要的输入； 状态转换发生在时钟有效沿产生的时刻； Moore型状态机：输出信息标在状态(圆圈)中。 状态转换表 对状态进行编码 输出表 原理图：寄存器 原理图：次态逻辑 原理图：输出逻辑 时序图 Moore型有限状态机设计方法 根据问题进行抽象，确定输入输出以及对应的逻辑含义； 画出状态转换图； 列出状态转换表； 对状态进行编码，并列出次态方程； 列出输出表； 对输出进行编码，并列出输出方程； 绘制原理图。 状态编码 定义 不同的状态编码和输出编码会产生不同的电路； 进行合理的编码，使之能产生一个逻辑门数最少且传播延迟最短的电路； 目前没有一种简单的办法可以找到； 可以通过计算机辅助设计(CAD)工具来解决； 常见的状态编码有两种 二进制编码(Binary encoding)； 独热编码(One-hot encoding)； 可以理解为译码器的输入与输出端的形式。 二进制编码 例如：4种状态，对应的编码为：00，01，10，11。 独热编码 状态的每一位(1 bit)表示一种状态； 任何时候只能有一位是“热的”(TRUE或1)； 例如：4种状态，对应的编码为：0001，0010，0100，1000； 需要使用更多的触发器； 相比于二进制编码，次态逻辑和输出逻辑实现起来更加的简单。 Moore型状态机 VS Mealy状态机 实例 状态转换图 Moore型状态机的状态转换表 Moore型状态机的输出表 Mealy型状态机状态转换表和输出表 Moore型状态机原理图 Mealy型状态机原理图 Moore型和Mealy型状态机时序图 Mealy型有限状态机设计方法 根据问题进行抽象，确定输入输出以及对应的逻辑含义； 画出状态转换图； 列出状态转换表和输出表(可同时列出)； 对状态和输出进行编码，并列出次态方程和输出方程； 绘制原理图。 Moore型状态机与Mealy型状态机的总结 Moore型状态机：输出只和现态有关 在状态转换图中，输出标记在圆圈内； 输入后，需要等待状态的变化才能得到输出； 相同情况下需要使用更多的状态。 Mealy型状态机：输出与现态和输入都有关 在状态转换图中，输出标记在圆弧上； 输出可以直接响应输入； 相同情况下需要使用更少的状态。 状态机的分解 目标 将复杂的有限状态机分解成多个简单的状态机 其中一些状态机的输出是另一些状态机的输入； 层次化、模块化。 实例 为交通灯控制器增加“游行”模式 增加两个输入端：P，R； 当P=1时，进入“游行”模式，保证Bravado Blvd.大道的交通灯一直为绿色； 当R=1时，退出“游行”模式。 “游行”模式状态机设计 未分解的状态转换图 分解后的状态转换图 有限状态机设计小结 确定输入和输出； 画状态转换图； 对于Moore型状态机 写出状态转换表； 写出输出表。 对于Mealy型状态机 写出组合的状态转换表和输出表。 选择状态编码； 写出次态方程和输出方程； 绘制电路原理图。 由电路图导出状态机 主要步骤 电路分析：在给定电路原理图的情况下推断电路的逻辑功能，是电路设计的逆过程 当承担一个没有完整文档的项目； 开展基于其他人系统的逆向工程。 主要步骤 检查电路，表明输入输出和状态位； 写出次态方程和输出方程； 列出状态表和输出表； 删除不可达状态以简化状态表； 给每个有效状态编码指定状态名称； 用状态名称重写状态表和输出表； 画出状态转换图； 使用文字描述有限状态机的功能。 实例：键盘锁电路分析 下图是一个键盘锁电路，包含两个输入和一个输出，当输出为1时表示开锁成功。试分析，如何进行输入才能使电路产生开锁信号。 步骤 时序逻辑中的时序问题 时序 D触发器在时钟有效边沿(上升沿/下降沿)对输入D采样，并复制给Q； 在采样的时刻，D必须处在一个稳定的状态，为0或为1； 这个过程如同照相一样 只有当被拍摄物体静止不动时才能获得清晰的图像。 如果在采样时刻，D未处于稳定的状态，则会产生亚稳态。 输入时序约束 建立时间(Setup time)：tsetup=在时钟有效边沿到来前输入信号所需要的稳定时间； 保持时间(Hold time)：thold=在时钟有效边沿到来后输入信号所保持稳定的时间； 孔径时间(Aperture time)：ta=在时钟边沿附近输入信号需要保持稳定的总时间； ta=tsetup+thold 输出时序约束 传播延迟(Propagation delay)：tpcq=时钟有效边沿到达后到Q最终稳定所需的最长时间； 最小延迟(Contamination delay)：tccq=时钟有效边沿到达后到Q开始改变所需的最短时间。 动态约束 同步时序电路中，输入必须在时钟有效边沿附近的孔径时间内保持稳定； 输入信号必须稳定 在时钟有效边沿到达前，至少稳定tsetup； 在时钟有效边沿到达后，至少稳定thold。 系统时序 时钟周期Tc是两个时钟上升沿(或下降沿)之间的间隔； fc=1/Tc，表示时钟频率； 提高时钟频率可以增加数字系统在单位时间内完成的工作量，但频率不能无限制的增加。 如上图所示，两个寄存器间的延迟具有最小和最大延迟； 这些延迟是由其中的电路元件的延迟所决定。 建立时间约束 建立时间约束由路径R1至R2间的最大延迟所决定 寄存器的传播延迟tpcq； 组合逻辑电路的传播延迟tpd。 寄存器R2的输入信号必须在下一个时钟上升沿的tsetup时间前稳定。 tpd≤Tc-(tpcq+tsetup) 上式被称为建立时间约束或最大延迟约束； 限制了通过组合逻辑的最大延迟； 在商业设计中 Tc由研发总监和市场部提出，以确保产品的竞争性； 制造商确定触发器的传播延迟tpcq和建立时间tpcq； tpcq+tpcq被称为时序开销，由芯片的生产工艺所决定； 通常，只有tpd是设计人员能够控制的变量。 保持时间约束 保持时间约束由路径R1至R2间的最短延迟所决定 寄存器的最小延迟tccq； 组合逻辑电路的最小延迟tcd。 寄存器R2的输入信号必须在时钟上升沿后至少稳定thold时间。 tcd≥thold-tccq 上式被称为保持时间约束或最小延迟约束； 限制了通过组合逻辑的最小延迟。 在实际应用中，经常将触发器设计成thold=0，以保证保持时间约束在各种情况下都可以满足； 保持时间约束非常重要，如果一旦违反则必须重新设计电路； 与建立时间约束不同，不能通过调整时钟周期来改正。 因此一旦违反保持时间约束会产生非常严重的后果。 时序分析 时序逻辑模块 基于SystemVerilog HDL的时序逻辑设计 SystemVerilog使用一些特殊的编码风格(idioms)描述锁存器、触发器和状态机； 其他的编码风格虽然可以正确的进行仿真，但是综合后会产生错误的电路。 always过程快的时序逻辑建模 always过程块分为三种类型： always_comb(描述组合逻辑)，always_latch，always_ff(后两者用于描述时序逻辑)。 always过程块结构如下： 12always @(sensitivity list) statements; sensitivity list是敏感事件列表，当列表中的事件产生时，过程快中的语句开始工作。 寄存器建模 123456module flop(input logic clk, input logic [3:0]d, output logic [3:0]q); always_ff @(posedge clk) q&lt;=d;endmodule 使用正边沿D触发器实现； always_ff用来表示触发器； posedge clk表示clk信号上升沿； &lt;=是非阻塞赋值，暂时可以把它看做是普通的赋值语句。 带复位端的寄存器建模 同步复位功能 12345678module flopr(input logic clk, input logic reset, input logic [3:0]d, output logic [3:0]q); always_ff @(posedge clk) if(reset) q&lt;=4&#x27;b0000; else q&lt;=d;endmodule 异步复位功能 12345678module flopr(input logic clk, input logic reset, input logic [3:0]d, output logic [3:0]q); always_ff @(posedge clk,posedge reset) if(reset) q&lt;=4&#x27;b0000; else q&lt;=d;endmodule 带使能端的寄存器建模 123456789module flopren(input logic clk, input logic reset, input logic en, input logic [3:0]d, output logic [3:0]q); always_ff @(posedge clk,posedge reset) if(reset) q&lt;=4&#x27;b0000; else if(en) q&lt;=d;endmodule 锁存器 123456module latch(input logic clk, input logic [3:0]d, output logic [3:0]q); always_latch if(clk) q&lt;=d;endmodule 不是所有的综合工具都能很好地支持锁存器； 除非你明确地知道工具支持锁存器，或者你有理由使用锁存器； 最好不要使用锁存器而是使用边沿触发器； 此外还要防止HDL代码意外生成锁存器。 阻塞赋值 VS 非阻塞赋值 &lt;=是非阻塞赋值 与其他的语句同时工作 =是阻塞赋值 按照语句在代码中的顺序依次工作 赋值语句使用规则 同步时序逻辑电路中使用always_ff @(posedge clk)和非阻塞赋值&lt;= 12always_ff @(posedge clk) q&lt;=d; 简单的组合逻辑电路中使用持续赋值语句assign 1assign y=a&amp;b; 使用always_comb和阻塞赋值语句=描述复杂组合逻辑 123456always_comb begin p=a^b; g=a&amp;b; s=p^cin; cout=g|(p&amp;cin);end 不要再多余1个always语句块或者连续赋值语句中对同一个信号赋值。 计数器 定义 N位二进制计数器 输入：时钟、复位信号； 输出：N位计数结果。 功能：时钟上升沿到达时将结果加1并输出； 能够实现循环计数 例如：000,001,010,011,100,101,110,111,000,001… 典型应用 数字时钟、程序计数器(PC)。 建模 12345678module counter #(parameter N=8) (input logic clk, input logic reset, output logic [N-1:0]q); always_ff @(posedge clk,posedge reset) if(reset) q&lt;=0; else q&lt;=q+1;endmodule 移位寄存器 移位寄存器 输入：时钟、串行输入Sin； 输出：串行输出Sout、N位并行输出QN-1:0。 功能：在时钟的每一个上升沿，从Sin移入一个新的位，寄存器中所有内容都向前移动一位，最前面的位移入Sout； 可以看做是一个串行到并行的转换器，每个周期从Sin输入一位，N个周期后可以通过QN-1:0直接访问N位输入； 实现：N个D触发器串联。 带并行加载的移位寄存器 定义 带并行加载的移位寄存器 输入：在移位寄存器基础上增加了加载(Load)信号和并行输入信号D1:0。 功能： Load=1，并行加载位； Load=0，移位寄存器。 可以实现 串行转并行(Sin到QN-1:0)； 并行转串行(DN-1:0到Sout)。 建模 12345678910111213module shiftreg #(parameter N=8) (input logic clk, input logic reset,load, input logic sin, input logic [N-1:0]q, output logic [N-1:0]q, output logic sout); always_ff @(posedge clk,posedge reset) if(reset) q&lt;=0; else if(load) q&lt;=d; else q&lt;=&#123;q[N-2:0],sin&#125;; assign sout=q[N-1];endmodule 有限状态机建模 定义 有限状态机主要包含三个模块： 状态寄存器 存储当前时刻的状态； 状态在下一个有效时钟沿发生改变。 组合逻辑 计算下一个状态(次态逻辑)； 计算电路的输出(输出逻辑)。 在状态机建模时也应包含三个对应的语句块。 实例：3分频计数器 3分频计数器 一个时钟输入； 一个输出； 每三个时钟周期后输出产生一个周期的高电平； 输出是时钟的三分频。 1234567891011121314151617181920module divideby3FSM(input logic clk, input logic reset, output logic q); typedef enum logic [1:0]&#123;S0,S1,S2&#125; statetype; statetype [1:0] state, nextstate; //寄存器 always_ff @(posedge clk,posedge reset) if(reset) state&lt;=S0; else state&lt;=nextstate; //次态逻辑 always_comb case(state) S0:nextstate=S1; S1:nextstate=S2; S2:nextstate=S0; default:nextstate=S0; endcase //输出逻辑 assign q=(state==S0);endmodule 存储器阵列 一种有效的存储大量数据的模块； 每个N位地址都可以读出或写出M位的数据 数据：存储的内容； 地址：数据的索引。 存储器由一个二维存储单元阵列构成； 每个位单元存储1位数据； 一个N位地址M位数据的阵列： 有2N行和M列； 深度(Depth)：阵列的行数； 宽度(Width)：阵列的列数； 阵列的总大小(Array Size)：宽度×深度=2N×M； 字(Word)：每行数据都称为一个字。 位单元 存储器阵列由位单元(bit cell)阵列组成； 每个位单元存储1位数据； 每一个位单元与一个字线(wordline)和一个位线(bitline)相连。 存储器的结构 字线 与使能端相似； 用于控制阵列中一行数据的读/写； 对应着唯一的地址； 同一时刻至多有一个字线为高电平。 存储器的类型 两种主要的类型 随机访问存储器(Random Access Memory)：易失的(volatile) 动态随机访问存储器(DRAM)：计算机的主存； 静态随机访问存储器(SRAM)：CPU中的高速缓存。 只读存储器(Read Only Memory)：非易失的(non-volatile) RAM和ROM的命名是由于历史的原因 ROM也可以是随机访问的，大多数现代ROM也是可读写的。 DRAM VS SRAM 几种存储器的比较 存储器类型 每个位单元的晶体管数 成本 延迟 触发器 ≈20 高 低 SRAM 6 中等 中等 DRAM 1 低 高 ROM：读速度快，写速度较慢 存储器端口 寄存器文件 寄存器文件(Register files)通常是一个小型多端口SRAM阵列； 上图是一个32寄存器×32位的3端口寄存器文件； 由两个读端口A1/RD1和A2/RD2； 一个写端口A3/WD3； 地址线均为5位，可寻址25=32个寄存器； 可以同时读两个寄存器和写一个寄存器。 RAM建模 12345678910module ram #(parameter N=6,M=32) (input logic clk,we, input logic [N-1:0]adr, input logic [M-1:0]din, output logic [M-1:0]dout); logic [M-1:0] mem[2**N-1:0];//**位幂运算,即2的N次方-1 always_ff @(posedge clk) if(we) mem[adr]&lt;=din; assign dout=mem[adr];endmodule ROM建模 12345678910module rom(input logic [1:0]adr, output logic [2:0]dout); always_comb case(adr) 2&#x27;b00:dout&lt;=3&#x27;b011; 2&#x27;b01:dout&lt;=3&#x27;b110; 2&#x27;b10:dout&lt;=3&#x27;b100; 2&#x27;b11:dout&lt;=3&#x27;b010; endcaseendmodule","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"Java-Part9","slug":"Java/Java-Part9","date":"2021-04-17T02:30:08.000Z","updated":"2021-06-17T06:32:02.976Z","comments":false,"path":"2021/04/17/Java/Java-Part9/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/17/Java/Java-Part9/","excerpt":"","text":"反射及国际化问题 Java中的反射-reflect 反射：java.lang.reflect 如何动态的创建一个类？ 如何动态的调用一个方法？ 如何知道一个类所有的方法？ 动态的构造一个类 Method1 不传递任何构造参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344//ch11.DynamicCreate01package ch11;/** * 本例子演示了如何动态构建 */public class DynamicCreate01 &#123; public static void main(String[] args) &#123; try &#123; //要动态创建的类的全名 String className = &quot;ch11.Student&quot;; Class clazz = Class.forName(className); //实例化，本例子要求&quot;ch11.Student&quot;必须有无参数的构造方法。 Object obj = clazz.newInstance(); Student student = (Student) obj; System.out.println(&quot;obj.class=&quot; + obj.getClass().toString()); System.out.println(&quot;student.class=&quot; + student.getClass().toString()); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; &#125;&#125;//ch11.DynamicCreat02package ch11;import java.lang.reflect.InvocationTargetException;/** * 本例子演示了如何动态构建 */public class DynamicCreate02 &#123; public static void main(String[] args) &#123; try &#123; String className = &quot;ch11.Student&quot;; Class clazz = Class.forName(className); //动态构造的另外一种方法，这种方法和DynamicCreate01类似 Object obj = clazz.getConstructor(new Class[0]).newInstance(); Student student = (Student) obj; System.out.println(&quot;obj.class=&quot; + obj.getClass().toString()); System.out.println(&quot;student.class=&quot; + student.getClass().toString()); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; &#125;&#125; Method2 调用带有参数的构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//ch11.DynamicCreate03package ch11;import java.lang.reflect.InvocationTargetException;/** * 本例子演示了如何动态构建 */public class DynamicCreate03 &#123; public static void main(String[] args) &#123; try &#123; String className = &quot;ch11.Student&quot;; Class clazz = Class.forName(className); Class[] classes = new Class[2]; classes[0] = String.class; classes[1] = Integer.class; // clazz.getConstructor(classes) 寻找Student的带有参数的构造函数 // 且构造函数的第一个是参数String,第二个是Integer。 // .newInstance(&quot;tom&quot;, 123)： 用&quot;tom&quot;, 123 实例化 Object obj = clazz.getConstructor(classes).newInstance(&quot;tom&quot;, 123); Student student = (Student) obj; System.out.println(&quot;obj.class=&quot; + obj.getClass().toString()); System.out.println(&quot;student.class=&quot; + student.getClass().toString()); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; &#125;&#125;//ch11.DynamicCreate04package ch11;import java.lang.reflect.InvocationTargetException;/** * 本例子演示了如何动态构建 */public class DynamicCreate04 &#123; public static void main(String[] args) &#123; try &#123; String className = &quot;ch11.Student&quot;; //用变长参数调用 Object obj = createObject4(className, &quot;aaa&quot;, 456); Student student = (Student) obj; System.out.println(&quot;obj.class=&quot; + obj.getClass().toString()); System.out.println(&quot;student.class=&quot; + student.getClass().toString()); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; &#125; public static Object createObject4(String className, Object... values) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123; Class clazz = Class.forName(className); Class[] classes = new Class[values.length]; for (int i = 0; i &lt; classes.length; i++) &#123; classes[i] = values[i].getClass(); &#125; Object obj = clazz.getConstructor(classes).newInstance(values); return obj; &#125;&#125;//ch11.DynamicCreate04package ch11;import java.lang.reflect.InvocationTargetException;/** * 本例子演示了如何动态构建 */public class DynamicCreate04 &#123; public static void main(String[] args) &#123; try &#123; String className = &quot;ch11.Student&quot;; //用变长参数调用 Object obj = createObject4(className, &quot;aaa&quot;, 456); Student student = (Student) obj; System.out.println(&quot;obj.class=&quot; + obj.getClass().toString()); System.out.println(&quot;student.class=&quot; + student.getClass().toString()); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; &#125; public static Object createObject4(String className, Object... values) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123; Class clazz = Class.forName(className); Class[] classes = new Class[values.length]; for (int i = 0; i &lt; classes.length; i++) &#123; classes[i] = values[i].getClass(); &#125; Object obj = clazz.getConstructor(classes).newInstance(values); return obj; &#125;&#125; 动态的调用一个方法 Method1 调用无参数方法 12345678910111213141516171819202122232425//ch11.DynamicInvoke01package ch11;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * 这个例子展示了如何动态的调用一个带有参数的方法 */public class DynamicInvoke01 &#123; public static void main(String[] args) &#123; Student student = new Student(&quot;jack&quot;, 123); try &#123; System.out.println(dynamicInvokeMethod(student,&quot;getName&quot;)); Object result=dynamicInvokeMethod(student, &quot;getName&quot;); System.out.println(result); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; &#125; public static Object dynamicInvokeMethod(Object obj, String methodName) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException, SecurityException &#123; Method method = obj.getClass().getMethod(methodName); return method.invoke(obj); &#125;&#125; Method2 调用有参数方法 1234567891011121314151617181920212223242526272829//ch11.DynamicInvoke02package ch11;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * 这个例子展示了如何动态的调用一个带有参数的方法 */public class DynamicInvoke02 &#123; public static void main(String[] args) &#123; Student student = new Student(&quot;jack&quot;, 123); try &#123; dynamicInvokeMethod (student, &quot;setName&quot;, &quot;tom&quot;); System.out.println(student.getName()); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; &#125; public static Object dynamicInvokeMethod (Object obj, String methodName, Object... values) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException, ClassNotFoundException &#123; Class[] classes = new Class[values.length]; for (int i = 0; i &lt; values.length; i++) &#123; classes[i] = values[i].getClass(); &#125; Method method = obj.getClass().getMethod(methodName, classes); return method.invoke(obj, values); &#125;&#125; Method3 包含原始数据类型的方法动态调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//ch11.DynamicInvoke03package ch11;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * 这个例子展示了如何动态调用带有原始数据类型的函数 */public class DynamicInvoke03 &#123; public static void main(String[] args) &#123; StudentPrime student = new StudentPrime(&quot;jack&quot;, 123); try &#123; dynamicInvokeMethod1(student, &quot;setAge&quot;, 20); dynamicInvokeMethod2(student, &quot;setAge&quot;, 20); System.out.println(student.getAge()); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; &#125; /** * 这个方法是错误的，无法调用原始数据类型的方法 * @param obj * @param methodName * @param values * @return * @throws IllegalAccessException * @throws IllegalArgumentException * @throws InvocationTargetException * @throws NoSuchMethodException * @throws SecurityException * @throws ClassNotFoundException */ public static Object dynamicInvokeMethod1(Object obj, String methodName, Object... values) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException, ClassNotFoundException &#123; Class[] classes = new Class[values.length]; for (int i = 0; i &lt; values.length; i++) &#123; classes[i] = values[i].getClass(); &#125; Method method = obj.getClass().getMethod(methodName, classes); return method.invoke(obj, values); &#125; /** * 这个方法可以调用包含int参数的方法 * @param obj * @param methodName * @param values * @return * @throws IllegalAccessException * @throws IllegalArgumentException * @throws InvocationTargetException * @throws NoSuchMethodException * @throws SecurityException * @throws ClassNotFoundException */ public static Object dynamicInvokeMethod2(Object obj, String methodName, Object... values) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException, ClassNotFoundException &#123; Class[] classes = new Class[values.length]; for (int i = 0; i &lt; values.length; i++) &#123; if (values[i] instanceof Integer) &#123; classes[i] = Integer.TYPE; classes[i] = int.class; &#125; else &#123; classes[i] = values[i].getClass(); &#125; &#125; Method method = obj.getClass().getMethod(methodName, classes); return method.invoke(obj, values); &#125;&#125;//class StudentPrimepackage ch11;public class StudentPrime &#123; private String name; private String school; private int age; private int id; public StudentPrime(String name, Integer id) &#123; super(); this.name = name; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSchool() &#123; return school; &#125; public void setSchool(String school) &#123; this.school = school; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125; 动态调用属性 1234567891011121314151617181920212223//ch11.DynamicField.javapackage ch11;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;public class DynamicField &#123; public static void main(String[] args) &#123; Object obj = new StudentPublic(&quot;jack&quot;, 123); try &#123; dynamicField(obj, &quot;name&quot;, &quot;tom&quot;); System.out.println(((StudentPublic) obj).getName()); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; &#125; public static void dynamicField(Object obj, String fieldName, Object value) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException, NoSuchFieldException &#123; //取得所有public类型的属性 Field field = obj.getClass().getField(fieldName); //直接设置属性值 field.set(obj, value); &#125;&#125; Java中的乱码问题 Java乱码的根源 同样的byte[]在不同的编码方式下表示不同的字符 char→byte[]同样存在上述问题 Java内部采用Unicode 字符集 定义 字符的集合 常见字符集 ASCII：美国信息交换标准码，共128个(0~127) iso8859-1：西欧语言，包含多种语言，兼容ASCII gb2312/GBK： 《信息交换用汉字编码字符集——基本集》 由中国国家标准总局发布，与1981年5月实施 GBK字符集兼容bg2312 Unicode 统一码、万国码、单一码 Unicode用数字0~0x10FFFF来映射这些字符最多可以容纳1114112个字符，或者说有1114112个码位 目前Unicode分为17个平面(plane)，每平面拥有65536个码点，最初的65536个字符在0号平面 字符编码方案 字符编码方案是从一个或多个编码字符集到一个或多个固定宽度代码单元序列的映射 gb2312/GBK 将区位码直接保存在2个字节中 例如：啊 - B0A0 Unicode UTF-32 UTF-16 UTF-8 1~4个字节变长编码 实例 “汽车”在不同编码下的结果 二进制[C6 FB]表示什么 解决乱码方法 charsetName一致 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//ch11.CharSetDemoString.getByte(String charsetName);new String(byte[] data,String charsetName);InputStreamReader inReader=new InputStreamReader(InputStream in,String charsetName);//package ch11;import java.io.Closeable;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.UnsupportedEncodingException;/** * 这个例子演示了java乱码及解决的原理 */public class CharSetDemo &#123; public CharSetDemo() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; readStrFromFile(&quot;D:/course/course/code_demo/src/ch11/char1.txt&quot;); readStrFromFile(&quot;D:/course/course/code_demo/src/ch11/char2.txt&quot;); byteToStr(); &#125; public static void byteToStr() &#123; String str = &quot;你好&quot;; String str2 = &quot;&quot;; System.out.println(str2); try &#123; //char-&gt;byte byte-char 使用了不同的编码 可能会导致混乱 str2 = new String(str.getBytes(&quot;gbk&quot;), &quot;utf-8&quot;); System.out.println(str2); str2 = new String(str.getBytes(&quot;gbk&quot;), &quot;gbk&quot;); System.out.println(str2); str2 = new String(str.getBytes(&quot;utf-8&quot;), &quot;utf-8&quot;); System.out.println(str2); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; /** * 从文本文件中读取内容 * @param filename */ public static void readStrFromFile(String filename) &#123; try &#123; //读取byte byte[] data = readBytes(filename); //以utf-8方式构造字符串 String str = new String(data, &quot;utf-8&quot;); System.out.println(str); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; &#125; public static byte[] readBytes(String filename) throws FileNotFoundException, IOException &#123; File src = null; int totalReaded = 0; int readed = 0; FileInputStream reader = null; byte data[]; try &#123; src = new File(filename); Long len = src.length(); data = new byte[len.intValue()]; for (reader = new FileInputStream(filename); reader.available() &gt; 0;) &#123; readed = reader.read(data, totalReaded, (len.intValue() - totalReaded)); totalReaded += readed; &#125; &#125; finally &#123; close(reader); &#125; return data; &#125; /** * 关闭一个输入 输出流 * @param inout */ public static void close(Closeable inout) &#123; if (inout != null) &#123; try &#123; inout.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; Java中的国际化问题 Points Java中的不定长参数 12345678910111213141516public class VariantParams&#123; public static void main(String[] args)&#123; List&lt;String&gt; list=asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); for(String str:list)&#123; System.out.println(str); &#125; &#125; public static &lt;T&gt; list&lt;T&gt; asList(T... a)&#123; //不定长参数a是一个数组 java.util.ArrayList&lt;T&gt; list=new ArrayList&lt;t&gt;(); for(int i=0;i&lt;a.length;i++)&#123; list.add(a[i]); &#125; return list; &#125;&#125; asList 文章源码 文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"Java-Part8","slug":"Java/Java-Part8","date":"2021-04-16T01:38:02.000Z","updated":"2021-06-17T06:31:55.950Z","comments":false,"path":"2021/04/16/Java/Java-Part8/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/16/Java/Java-Part8/","excerpt":"","text":"Java网络编程 网络编程的底层基础-Socket通信 Socket通信的一般步骤 在客户方和服务器方创建Socket/ServerSocket实例； 打开连接到Socket的输入/输出流； 利用输入/输出流，按照一定的协议对Socket进行读/写操作； 关闭输入/输出流。 Socket通信-客户端 java.net.Socket类 Socket构造方法 12public Socket(String host,int port)&#123;&#125;public Socket(InetAddress address,int port)&#123;&#125; 从Socket中获得输入输出流 12public InputStream getInputStream()public OutputStream getOutputStream() 向输出流写，从输入流读 关闭 1public void close() Socket通信-客户端例子 端口扫描 12345678910111213141516171819202122232425262728293031323334353637//ch10.SocketScan//尝试和远程每一个端口连接package ch10;import java.io.IOException;import java.net.Socket;public class SocketScan &#123; public SocketScan() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; //远程的地址，可以是IP 地址，也可以是域名 String address = &quot;www.163.com&quot;; for (int port = 80; port &lt; 10000; port++) &#123; Socket socket =null; try &#123; System.out.println(&quot;scan &quot;+address +&quot;:&quot; + port); socket = new Socket(address, port); //远程主机名 System.out.println(&quot;hostname=&quot; + socket.getInetAddress().getHostName()); //远程地址 System.out.println(&quot;ip=&quot; + socket.getInetAddress().getHostAddress()); System.out.println(address + &quot; listen on port:&quot; + port); &#125; catch (IOException e) &#123; System.out.println(address + &quot; port=&quot; + port + &quot; connect error:&quot; + e); &#125;finally &#123; if(socket!=null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; Socket通信-类Socket Socket通信-类ServerSocket Client-Server通讯例子 面向byte 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//ch10.MyClientSocketV1package ch10;import java.io.OutputStream;import java.net.Socket;/** * 本例子和 演示了 ch10.MyServerSocketV1配合，演示了如何使用socket 获得 OutputStream, * 需要在命令行模式下，将当前目录切换到 bin目录下 执行 java ch10.MyServerSocketV1 再打开一个命令行模式，将当前目录切换到 * bin目录下 执行 java ch10.MyClientV1 */public class MyClientSocketV1 &#123; public MyClientSocketV1() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; Socket client = null; OutputStream out = null; try &#123; // 构建远程连接 client = new Socket(&quot;127.0.0.1&quot;, Config.PORT); System.out.println(&quot;connection &quot; + client.getInetAddress().toString() + &quot; port=&quot; + Config.PORT + &quot; ok!&quot;); // 获得输出流 out = client.getOutputStream(); for (int i = 0; i &lt; 10; i++) &#123; Thread.sleep(1000); String line = &quot;I say &quot; + i; System.out.println(&quot;From client:&quot; + line); // 向输出流中写 out.write(line.getBytes()); out.flush(); &#125; out.write(Config.BYE.getBytes()); out.close(); client.close(); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; finally &#123; MyUtil.close(out); MyUtil.close(client); &#125; &#125;&#125;//ch10.MyServerSocketV1package ch10;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;/** * 本例子演示了如何使用socket 获得 InputStream, * 需要在命令行模式下，将当前目录切换到 bin目录下 执行 java ch10.MyServerSocketV1 * 再打开一个命令行模式，将当前目录切换到 bin目录下 执行 java ch10.MyClientV1 */public class MyServerSocketV1 &#123; public static void main(String[] args) &#123; ServerSocket server=null; Socket socket=null; InputStream in =null; try &#123; server = new ServerSocket(Config.PORT); System.out.println(&quot;server listen on port:&quot; + Config.PORT + &quot; ok!&quot;); socket = server.accept(); // 等待客户端连接，只能和一个客户端连接 //构造输入流的方式，注意和MyServerSocketV2区别 in = socket.getInputStream(); byte[] data = new byte[Config.MAX_LEN]; int readed = in.read(data); String line = new String(data, 0, readed); while (!Config.BYE.equals(line)) &#123; System.out.println(&quot;From server received: &quot; + line); readed = in.read(data); line = new String(data, 0, readed); &#125; in.close(); socket.close(); server.close(); &#125; catch (IOException e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125;finally &#123; MyUtil.close(in); MyUtil.close(socket); MyUtil.close(server); &#125; &#125;&#125;//服务器端:ServerSocket server=new ServerSocket(Config.PORT);Socket socket=server.accept();InputStream in=socket.getInputStream();//客户端:Socket client=new Socket(&quot;127.0.0.1&quot;,config.PORT);OutputStream out=client.getOutputStream(); 面向char 1234567//ch10.MyClientSocketV2//ch10.MyServerSocketV2//服务器端:BufferedReader in=new BufferedReader(new InputStreamReader(socket.getInputStream()));String line=in.readLine();//客户端:PrintWriter out=new java.io.PrintWriter(client.getOutputStream()); 支持输入、输出、多客户端 1234567//ch10.MyClientSocketV3//ch10.MyServerSocketV3while(true)&#123; Socket socket=server.accept();//等待客户端连接 System.out.println(&quot;client&quot;+socket.getInetAddress()+&quot; connect ok!&quot;); new ServerThread(socket).start();&#125; 网络编程 做一个自己的简易浏览器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//ch10.http.HTTPClientpackage ch10;import java.net.*;import java.io.*;import java.util.*;/** * 实现一个最简陋的浏览器 */public class HTTPClient &#123; public static void main(String args[]) &#123; Socket socket = null; String host = &quot;www.tju.edu.cn&quot;; int port = 80; try &#123; socket = new Socket(host, port); // 与HTTPServer建立 连接 /* 创建HTTP请求 */ StringBuffer sb = new StringBuffer(&quot;GET http://www.tju.edu.cn/index.htm HTTP/1.1\\r\\n&quot;); sb.append(&quot;Accept: */*\\r\\n&quot;); sb.append(&quot;Accept-Language: zh-cn\\r\\n&quot;); // sb.append(&quot;Accept-Encoding: gzip, deflate\\r\\n&quot;); sb.append(&quot;User-Agent: HTTPClient\\r\\n&quot;); // sb.append(&quot;Host: localhost:8080\\r\\n&quot;); sb.append(&quot;Host: www.tju.edu.cn:80 \\r\\n&quot;); sb.append(&quot;Connection: Keep-Alive\\r\\n\\r\\n&quot;); /* 发送HTTP请求 */ OutputStream socketOut = socket.getOutputStream(); // 获得输出流 socketOut.write(sb.toString().getBytes()); Thread.sleep(2000); // 睡眠2秒，等待响应结果 /* 接收响应结果 */ InputStream socketIn = socket.getInputStream(); // 获得输入流 int size = socketIn.available(); byte[] buffer = new byte[size]; socketIn.read(buffer); System.out.println(new String(buffer, &quot;UTF-8&quot;)); // 打印响应结果 System.out.println(&quot;ok&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 做一个自己的简易WebServer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//ch10.http.HTTPServerpackage ch10;import java.io.*;import java.net.*;/** * 一个 HTTPServer的例子 */public class HTTPServer &#123; public static void main(String args[]) &#123; int port; ServerSocket serverSocket; try &#123; port = Integer.parseInt(args[0]); &#125; catch (Exception e) &#123; System.out.println(&quot;port = 8080 (默认)&quot;); port = 8080; //默认端口为8080 &#125; try &#123; serverSocket = new ServerSocket(port); System.out.println(&quot;服务器正在监听端口：&quot; + serverSocket.getLocalPort()); while (true) &#123; //服务器在一个无限循环中不断接收来自客户的TCP连接请求 try &#123; //等待客户的TCP连接请求 final Socket socket = serverSocket.accept(); System.out.println(&quot;建立了与客户的一个新的TCP连接，该客户的地址为：&quot; + socket.getInetAddress() + &quot;:&quot; + socket.getPort()); service(socket); //响应客户请求 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //#while &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** 响应客户的HTTP请求 */ public static void service(Socket socket) throws Exception &#123; /*读取HTTP请求信息*/ InputStream socketIn = socket.getInputStream(); //获得输入流 Thread.sleep(500); //睡眠500毫秒，等待HTTP请求 int size = socketIn.available(); byte[] requestBuffer = new byte[size]; socketIn.read(requestBuffer); String request = new String(requestBuffer); System.out.println(request); //打印HTTP请求数据 //String contentType = &quot;text/html&quot;; String contentType = &quot;application/zip&quot;; /*创建HTTP响应结果 */ //HTTP响应的第一行 String responseFirstLine = &quot;HTTP/1.1 200 OK\\r\\n&quot;; //String responseFirstLine = &quot;HTTP/1.1 403 Not Found \\r\\n&quot;; //HTTP响应头 String responseHeader = &quot;Content-Type:&quot; + contentType + &quot;\\r\\n\\r\\n&quot;; //获得读取响应正文数据的输入流 /*发送HTTP响应结果 */ OutputStream socketOut = socket.getOutputStream(); //获得输出流 //发送HTTP响应的第一行 socketOut.write(responseFirstLine.getBytes()); //发送HTTP响应的头 socketOut.write(responseHeader.getBytes()); //发送HTTP响应的正文 String content=&quot;hellow &quot;+new java.util.Date().toString(); byte[] buffer = content.getBytes(); socketOut.write(buffer, 0, buffer.length); Thread.sleep(1000); //睡眠1秒，等待客户接收HTTP响应结果 socket.close(); //关闭TCP连接 &#125;&#125; 文章源码 文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"蝴蝶主题修改为其他主体","slug":"CTFB","date":"2021-04-14T11:17:00.000Z","updated":"2021-04-29T06:07:00.101Z","comments":false,"path":"2021/04/14/CTFB/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/14/CTFB/","excerpt":"","text":"VolantisShokaThemes 3 Volantis Github改动 在博客仓库创建一个新的分支volantis； 并在设置中，改为将volantis分支部署为页面。 本地博客文件夹改动 创建一个新文件夹； git bash→hexo init； 克隆volantis主题源码到themes文件夹下； 修改站点配置文件，在提交中设置提交至git分支volantis； 将原butterfly主题博客文件夹下的文章复制到现在volantis主题博客文件夹下； 用vscode或其他编译器，进入到source/_post/文件夹下，搜索所有的&quot;cover:&quot;，均改为&quot;layout:&quot;(这里是因为front-matter中属性cover在butterfly主题和volantis主题中起不同作用)； 一键三连，可以开始使用volantis主题了。 代码 站点配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: CheeseburgerIMsubtitle: &#x27;IM灬Tony Pan&#x27;description: &#x27;I d like a cheeseburger^_^&#x27;keywords: &#x27;CheeseburerIM&#x27;author: Tony Panlanguage: entimezone: &#x27;&#x27;# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://CheeseburgerIM.github.io/permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: enable: true # Open external links in new tab field: site # Apply to the whole site exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: &#x27;&#x27; wrap: true hljs: falseprismjs: enable: false preprocess: true line_number: true tab_replace: &#x27;&#x27;# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#x27;&#x27; per_page: 10 order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;updated_option: &#x27;mtime&#x27;# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: volantis# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: - type: git repository: git@github.com:CheeseburgerIM/CheeseburgerIM.github.io.git branch: volantis - type: git repository: git@gitee.com:CheeseburgerIM/CheeseburgerIM.git branch: volantis# 网站图标，更多尺寸等图标请使用import方式批量导入favicon: https://gitee.com/CheeseburgerIM/imagehosting/raw/master/Image/Home/Web_icon.jpg# favicon: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico 主题配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938############################### Volantis ################################ use_cdn: /source/js/* 中的JS文件(JS Only)使用jsdelivr的min版本加速# 默认使用 https://cdn.jsdelivr.net/npm/hexo-theme-volantis@&lt;%- theme.info.theme_version %&gt;/source/js/*.min.js 的CDN压缩版本(min.js)，注意版本号对应关系！！可以通过修改以下配置项覆盖# 开发者注意 use_cdn 设置为 falseuse_cdn: falseinfo: theme_name: Volantis # This is theme&#x27;s name. theme_version: &#x27;4.3.1&#x27; # This is theme&#x27;s version. theme_docs: https://volantis.js.org/ # This is theme&#x27;s URL. theme_repo: https://github.com/volantis-x/hexo-theme-volantis cdn: js: # https://cdn.jsdelivr.net/npm/hexo-theme-volantis@&lt;%- theme.info.theme_version %&gt;/source/js/app.min.js # 注意版本!!! css: first: # /css/first.css (需自行替换CDN 首屏样式 cover navbar search ) style: # /css/style.css (需自行替换CDN 异步加载 Others... )####################################################################################################### Navigation Bar ############################### &gt; start# 注意事项：建议规范全站路径 URL 最后带一个 &quot;/&quot; 例如 &quot;about/&quot;navbar: visiable: always # always, auto logo: # choose [img] or [icon + title] img: https://gitee.com/CheeseburgerIM/imagehosting/raw/master/Image/Page/About/icon.png icon: title: menu: - name: 博客 icon: fas fa-rss url: / - name: 分类 icon: fas fa-folder-open url: categories/ - name: 标签 icon: fas fa-tags url: tags/ - name: 归档 icon: fas fa-archive url: archives/ - name: 账户 icon: fas fa-user-circle url: Accounts/ - name: 友链 icon: fas fa-link url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ search: Search... # Search bar placeholder############################### Navigation Bar ############################### &gt; end############################### Cover ############################### &gt; startcover: height_scheme: full # full, half layout_scheme: focus # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点) display: home: true archive: true others: false # can be written in front-matter &#x27;cover: true&#x27; background: https://gitee.com/CheeseburgerIM/imagehosting/raw/master/Image/Home/HomePage_Background.jpg # background: https://bing.ioliu.cn/v1/rand?w=1920&amp;h=1200 logo: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png title: &#x27;CheeseburgerIM&#x27; subtitle: &#x27;IM灬Tony Pan&#x27; search: A Wonderful Theme for Hexo # search bar placeholder features: - name: 博客 icon: # img: https://gitee.com/CheeseburgerIM/imagehosting/raw/master/Image/Home/Menu_UnderTitle/home.png url: / - name: 分类 icon: # img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg url: categories/ - name: 标签 icon: # img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg url: tags/ # - name: 示例 # icon: # # img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f396.svg # url: /examples/ # - name: 社区 # icon: # # img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f389.svg # url: /contributors/ - name: 归档 icon: # img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg url: /archives/ - name: 关于 icon: # img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f497.svg url: about/ # - name: 源码 # icon: # # img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f9ec.svg # url: https://github.com/volantis-x/hexo-theme-volantis/############################### Cover ############################### &gt; endpages: # 友链页面配置 friends: layout_scheme: traditional # simple: 简单布局, traditional: 传统布局, sites: 网站卡片布局############################### Article Layout ############################### &gt; start# 文章布局article: # 文章列表页面的文章卡片布局方案 preview: scheme: landscape # landscape # pin icon for post pin_icon: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg # auto generate title if not exist auto_title: true # false, true # auto generate excerpt if not exist auto_excerpt: true # false, true # show split line or not line_style: solid # hidden, solid, dashed, dotted # show author author: false # true, false # show readmore button readmore: auto # auto, always # 文章详情页面的文章卡片本体布局方案 body: # 文章顶部信息 # 从 meta_library 中取 top_meta: [author, category, date, counter] #启用评论数量需在此添加 # ---------------- # 文章页脚组件 footer_widget: # ---------------- # 参考资料、相关资料等 (for layout: post/docs) references: title: 参考资料 icon: fas fa-quote-left # 在 front-matter 中: # references: # - title: 某篇文章 # url: https:// # 即可显示此组件。 # ---------------- # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: false title: 相关文章 icon: fas fa-bookmark max_count: 5 # 设为空则不使用文章头图 placeholder_img: https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture # ---------------- # 版权声明组件 (for layout: post) copyright: enable: true permalink: &#x27;本文永久链接是：&#x27; content: - &#x27;博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议&#x27; - permalink # ---------------- # 打赏组件 (for layout: post) donate: enable: false images: - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # 文章底部信息 # 从 meta_library 中取 bottom_meta: [updated, tags, share] # meta library meta_library: # 默认文章作者（可在 _data/author.yaml 中增加其他作者，并在 front-matter 中设置） # https://volantis.js.org/advanced-settings/#多人协同 author: avatar: https://gitee.com/CheeseburgerIM/imagehosting/raw/master/Image/Home/Web_icon.jpg name: Tony Pan url: # 文章创建日期 date: icon: fas fa-calendar-alt title: &#x27;发布于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章更新日期 updated: icon: fas fa-edit title: &#x27;更新于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章分类 category: icon: fas fa-folder-open # 文章浏览计数 counter: icon: fas fa-eye unit: &#x27;次浏览&#x27; # 文章评论数量：支持 valine和waline valinecount: icon: fas fa-comment-dots desc: &#x27;&#x27; # 条评论 walinecount: icon: fas fa-comment-dots desc: &#x27;&#x27; # 条评论 # 文章字数和阅读时长 wordcount: icon_wordcount: fas fa-keyboard icon_duration: fas fa-hourglass-half # 文章标签 tags: icon: fas fa-hashtag # 分享 share: - id: qq img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png - id: qzone img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png - id: weibo img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png - id: # qrcode # 当id为qrcode时需要安装插件 npm i hexo-helper-qrcode img: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/wechat.png - id: # telegram img: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/telegram.png############################### Article Layout ############################### &gt; end############################### Comments ############################### &gt; startcomments: title: &lt;i class=&#x27;fas fa-comments&#x27;&gt;&lt;/i&gt; 评论 subtitle: service: valine # valine, twikoo, waline, minivaline, disqus, disqusjs, gitalk, vssue, livere, isso, hashover # Valine # https://valine.js.org/ valine: # js: https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js path: # 全局评论地址 目前设置全局评论地址后visitor失效,这是valine的问题 placeholder: 快来评论吧~ # 评论占位提示 # 其他配置项按照yml格式继续填写即可 除了 [el path placeholder emojiCDN emojiMaps] 选项 appId: # your appId appKey: # your appKey meta: [nick,mail,link] # valine comment header info requiredFields: [nick,mail] enableQQ: true # Unstable avatar link recordIP: false # Record commenter IP avatar: robohash # gravatar style https://valine.js.org/avatar pageSize: 10 # comment list page size lang: zh-cn highlight: true mathJax: false # MiniValine # https://github.com/MiniValine/MiniValine minivaline: js: https://cdn.jsdelivr.net/npm/minivaline@latest path: # 全局评论地址 placeholder: 快来评论吧~ # 全局评论占位提示 # 更多选项 https://minivaline.js.org/docs/cn/#/Options 按照yml格式继续填写即可 （除了 [el path placeholder] 选项） # emoticonUrl 等列表选项 可参考 https://github.com/MiniValine/hexo-next-minivaline # 下面是一个例子： backend: waline serverURL: https://waline.vercel.app # Disqus # https://disqus.com disqus: shortname: # optional autoload: false path: # 全局评论地址 # DisqusJS # https://github.com/SukkaW/DisqusJS disqusjs: path: # 全局评论地址 # 配置项按照yml格式继续填写即可 除了 [siteName url identifier] 选项 #shortname: #api: #apikey: #admin: #nesting: # Gitalk # https://gitalk.github.io/ gitalk: # 配置项按照yml格式继续填写即可 除了 [id distractionFreeMode] 选项 clientID: clientSecret: repo: owner: admin: # [] path: # 全局评论地址 # Vssue 暂不支持Pjax # https://vssue.js.org/zh/ vssue: owner: repo: clientId: clientSecret: # LiveRe 暂不支持Pjax # https://www.livere.com livere: uid: # Isso 暂不支持Pjax # https://posativ.org/isso/ isso: url: https://example.com/(path/) src: https://example.com/(path/)js/embed.min.js # HashOver 暂不支持Pjax # https://www.barkdull.org/software/hashover hashover: src: https://example.com/(path/)comments.php # Twikoo # https://twikoo.js.org/ twikoo: js: https://cdn.jsdelivr.net/npm/twikoo@latest # 建议锁定版本 path: # 全局评论地址 # 其他配置项按照yml格式继续填写即可 除了 [el path] 选项 envId: covercovercover # 腾讯云环境id # Waline # https://waline.js.org/ waline: js: https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js path: # 全局评论地址 目前设置全局评论地址后visitor失效,这是waline的问题 placeholder: 快来评论吧~ # 评论占位提示 imageHosting: https://7bu.top/api/upload # 图床api（默认使用去不图床） # 其他配置项按照yml格式继续填写即可 除了 [el path placeholder uploadImage] 选项 meta: [nick,mail,link] # waline comment header info requiredFields: [nick,mail] serverURL: covercovercover # Waline 的服务端地址（必填） 测试用地址: https://waline-ruddy.vercel.app avatar: robohash # gravatar style https://waline.js.org/client/basic.html#avatar pageSize: 10 # 评论每页显示数量 lang: zh-CN############################### Comments ############################### &gt; end############################### Sidebar ############################### &gt; startsidebar: # 主页、分类、归档等独立页面 for_page: [blogger, category, tagcloud, donate] # layout: docs/post 这类文章页面 for_post: [blogger,toc] # 侧边栏组件库 widget_library: # --------------------------------------- # blogger info widget blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: https://gitee.com/CheeseburgerIM/imagehosting/raw/master/Image/Home/Avatar.jpg shape: circle # circle, rectangle url: /about/ title: Tony Pan subtitle: IMF,I&#x27;ve got a lot to learn. jinrishici: true # Poetry Today. You can set a string, and it will be displayed when loading fails. social: - icon: fas fa-rss url: /atom.xml - icon: fas fa-envelope url: mailto:me@xxx.com - icon: fab fa-github url: https://github.com/volantis-x/ - icon: fas fa-headphones-alt url: / # --------------------------------------- # toc widget (valid only in articles) toc: class: toc display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 # --------------------------------------- # category widget category: class: category display: [desktop] # [desktop, mobile] header: icon: fas fa-folder-open title: 文章分类 url: /blog/categories/ # --------------------------------------- # tagcloud widget tagcloud: class: tagcloud display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-tags title: 热门标签 url: /blog/tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; # --------------------------------------- # qrcode widget donate: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # --------------------------------------- # webinfo widget webinfo: class: webinfo display: [desktop] header: icon: fas fa-award title: 站点信息 type: article: enable: true text: &#x27;文章数目：&#x27; unit: &#x27;篇&#x27; runtime: enable: true data: &#x27;2020/01/01&#x27; # 填写建站日期 text: &#x27;已运行时间：&#x27; unit: &#x27;天&#x27; wordcount: enable: true text: &#x27;本站总字数：&#x27; # 需要启用 wordcount unit: &#x27;字&#x27; visitcounter: service: leancloud # busuanzi, leancloud siteuv: enable: true text: &#x27;本站访客数：&#x27; unit: &#x27;人&#x27; sitepv: enable: true text: &#x27;本站总访问量：&#x27; unit: &#x27;次&#x27; lastupd: enable: true friendlyShow: true # 更友好的时间显示 text: &#x27;最后活动时间：&#x27; unit: &#x27;日&#x27;############################### Sidebar ############################### &gt; end############################### Tag Plugins ############################### &gt; start# 内置标签插件的配置tag_plugins: # &#123;% note text %&#125; note: # style for default note: icon: &#x27;\\f054&#x27; color: &#x27;&#x27; iconfont: &#x27;Font Awesome 5 Free&#x27; # &#123;% checkbox %&#125; checkbox: interactive: false # enable interactive for user color: &#x27;&#x27; # color for default checkbox # &#123;% link title, url, img %&#125; link: placeholder: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png############################### Tag Plugins ############################### &gt; end############################### Site Footer ############################### &gt; startsite_footer: # layout of footer: [aplayer, social, license, info, copyright] layout: [aplayer, social, license, analytics, info, copyright] social: - icon: #fas fa-rss url: # or - img: url: # or - avatar: url: # site source source: https://github.com/volantis-x/volantis-docs/ # analytics using leancloud analytics: &gt; &lt;span id=&quot;lc-sv&quot;&gt;本站总访问量为 &lt;span id=&#x27;number&#x27;&gt;&lt;i class=&quot;fas fa-circle-notch fa-spin fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; 次&lt;/span&gt; &lt;span id=&quot;lc-uv&quot;&gt;访客数为 &lt;span id=&#x27;number&#x27;&gt;&lt;i class=&quot;fas fa-circle-notch fa-spin fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; 人&lt;/span&gt; # site copyright copyright: &#x27;[Copyright © 2017-2020 XXX](/)&#x27; # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27;############################### Site Footer ############################### &gt; end############################### Plugins ############################### &gt; startplugins: ################ required plugins ################ # jquery jquery: https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js # fontawesome fontawesome: https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css ################ optional plugins ################ ######## Plugins to improve loading speed: # 预加载 preload: enable: true service: flying_pages # instant_page, flying_pages instant_page: https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/instant_page.js flying_pages: https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js # 图片懒加载 # https://www.npmjs.com/package/vanilla-lazyload lazyload: enable: true js: https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js onlypost: false loadingImg: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg blurIn: true # 模糊加载效果 （loadingImg为空时有效） ######## Plugins to optimize the experience: # highlight.js highlightjs: enable: #true # Please set hexo.config.highlight.enable = false !!! js: https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10/build/highlight.min.js css: https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10/build/styles/solarized-light.min.css # more: https://www.jsdelivr.com/package/npm/highlight.js?path=styles # https://scrollrevealjs.org/api/reveal.html scrollreveal: enable: #true js: https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js distance: 32px duration: 800 # ms interval: 20 # ms scale: 1 # 0.1~1 # Codeblock Copy Button clipboard: enable: #true js: https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js ######## Plugins for SEO: # npm i hexo-wordcount wordcount: enable: #true ######## Plugins for ... # Button Ripple Effect nodewaves: enable: #true css: https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css js: https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js # fontawesome animation fontawesome_animation: enable: #true css: https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css # Typing Effects comment_typing: enable: #true js: https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/comment_typing.js # Slide Background backstretch: enable: #true js: https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js position: cover # cover: sticky on the cover. fixed: Fixed as background for the site. shuffle: true # shuffle playlist duration: 10000 # Duration (ms) fade: 1500 # fade duration (ms) (Not more than 1500) images: # For personal use only. At your own risk if used for commercial purposes !!! - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.jpg - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg # APlayer is only available in mainland China. # APlayer config: https://github.com/metowolf/MetingJS aplayer: enable: true js: aplayer: https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js meting: https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js # Required server: netease # netease, tencent, kugou, xiami, baidu type: playlist # song, playlist, album, search, artist id: 5401143802 # song id / playlist id / album id / search keyword # Optional fixed: false # enable fixed mode theme: &#x27;#1BCDFC&#x27; # main color autoplay: true # audio autoplay order: list # player play order, values: &#x27;list&#x27;, &#x27;random&#x27; loop: all # player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27; volume: 0.7 # default volume, notice that player will remember user setting, default volume will not work after user set volume themselves list_max_height: 320px # list max height list_folded: true pjax: enable: true cover: true # 封面是否pjax处理 false：每次切换页面封面都重载，适合封面较少的情况 true：封面经过Pjax处理，适合封面较多的情况 timeout: 5000 # The timeout in milliseconds for the XHR requests. Set to 0 to disable the timeout. cacheBust: false # When set to true, Pjax appends a timestamp to skip the browser cache. animation: false # false, nprogress, circle banUrl: # 被屏蔽的 url 地址将不启用 pjax 跳转，可以在控制台下使用 window.location.pathname 获取 # - &#x27;/artitalk/&#x27; # artitalk 不支持 pjax # - &#x27;/bb/&#x27; # bbtalk 不支持 pjax # 从 issues 加载动态数据 # &#123;% issues sites/timeline/friends | api=xxx | group=key:a,b,c %&#125; # 例如： # &#123;% issues sites | api=https://api.github.com/repos/volantis-x/examples/issues?sort=updated&amp;state=open&amp;page=1&amp;per_page=100 | group=version:latest,v6,v5,v4,v3,v2,v1,v0 %&#125; # 暗黑模式 darkmode # 样式：source/css/_plugins/dark.styl # 开关按钮：在 navbar.menu 中添加： # - name: 暗黑模式 # 可自定义 # icon: fas fa-moon # 可自定义 # toggle: darkmode darkmodejs: enable: true # 旧版 Internet Explorer 淘汰行动 # https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support # 本主题不支持Internet Explorer的任何版本!!! killOldVersionsOfIE: enable: true # 禁用JavaScript提示 # 本页面需要浏览器支持（启用）JavaScript # 主题中的某些插件必须启用JavaScript才能正常工作，例如开启scrollreveal如果禁用JavaScript会导致卡片消失 killNoScript: enable: true # Artitalk https://artitalk.js.org # 配置过程请参考：https://artitalk.js.org/doc.html # 使用过旧版本的请修改Leancloud shuoshuo class部分列名：https://artitalk.js.org/release.html # 除appID和appKEY外均为选填项 artitalk: # Set `layout: artitalk` to enable in page # 配置项按照yml格式继续填写即可 appId: ogP8qj3veMh0LFpFWMPOyF0X-MdYXbMMI # your appID appKey: nHXLd3N3Jgh460t2iRQKWAtr # your appKEY # serverURL: #leancloud绑定的安全域名，使用国际版的话不需要填写 # lang: # 语言设置，zh为汉语，en为英语，es为西班牙语。默认为汉语 # pageSize: #每页说说的显示数量 # shuoPla: #在编辑说说的输入框中的占位符 # avatarPla: #自定义头像url的输入框的占位符 # motion: #加载动画的开关，1为开，0为关，默认为开 # bgImg: #说说输入框背景图片url # color1: #说说背景颜色1&amp;按钮颜色1 # color2: #说说背景颜色2&amp;按钮颜色2 # color3: #说说字体颜色 # cssUrl: #自定义css接口 # BBtalk https://bb.js.org bbtalk: js: https://cdn.jsdelivr.net/npm/bbtalk@0.1.5/dist/bbtalk.min.js # BBtalk.js appId: 0KzOX4vC7Jsk6vzUGNeEiUaI-gzGzoHsz # your appID appKey: HwCiWuxfpvKiLm4teCUgTIba # your appKEY serverURLs: https://bbapi.heson10.com # Request Api 域名 # Tidio聊天功能 # https://www.tidio.com/ tidio: enable: #true id: covercovercovercovercovercoverxx############################### Plugins ############################### &gt; end############################### Rightmenu ############################### &gt; start# 自定义右键菜单rightmenu: enable: true # hr: 分割线, music: 音乐控制器 layout: [home, help, examples, contributors, hr, source_docs, source_theme, hr, print, hr, dark_mode, hr, music] # 可选功能项 print: name: 打印页面 icon: fa fa-print onclick: document.execCommand(&#x27;print&#x27;) # 自定义菜单的格式如下 help: name: 常见问题 icon: fa fa-question url: https://volantis.js.org/faqs/ examples: name: 示例博客 icon: fa fa-rss url: https://volantis.js.org/examples/ contributors: name: 加入社区 icon: fa fa-fan fa-spin url: https://volantis.js.org/contributors/ source_docs: name: 本站源码 icon: fa fa-code-branch url: https://github.com/volantis-x/volantis-docs/ source_theme: name: 主题源码 icon: fa fa-code-branch url: https://github.com/volantis-x/hexo-theme-volantis/ dark_mode: name: Dark mode icon: fas fa-moon toggle: darkmode############################### Rightmenu ############################### &gt; end############################### Search ############################### &gt; start# To use hexo search, you need to install the following plugins:# npm i hexo-generator-search hexo-generator-json-contentsearch: enable: true service: hexo # hexo, google, algolia, azure, baidu js: google: apiKey: engineId: algolia: applicationID: apiKey: indexName: azure: serviceName: indexName: queryKey: baidu: apiId:############################### Search ############################### &gt; end############################### Color Scheme ############################### &gt; startcolor_scheme: # ------------ # 通用颜色 common: # 主题色 theme: &#x27;#44D7B6&#x27; # 链接色 link: &#x27;#2196f3&#x27; # 按钮色 button: &#x27;#44D7B6&#x27; # 鼠标放到交互元素上时的色 hover: &#x27;#ff5722&#x27; # 主题色块内部的文字颜色 inner: &#x27;#fff&#x27; # 选中区域文字的背景颜色 selection: &#x27;alpha(#2196f3, 0.2)&#x27; # ------------ # 亮色主题（默认） light: # 网站背景色 site_bg: &#x27;#f4f4f4&#x27; # 网站背景上的文字 site_inner: &#x27;#fff&#x27; # 网站页脚文字 site_footer: &#x27;#666&#x27; # 卡片背景色 card: &#x27;#fff&#x27; # 卡片上的普通文字 text: &#x27;#444&#x27; # 区块和代码块背景色 block: &#x27;#f6f6f6&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#FFF7EA&#x27; # 行内代码颜色 inlinecode: &#x27;#c74f00&#x27; # 文章部分 h1: &#x27;#3a3a3a&#x27; h2: &#x27;#3a3a3a&#x27; h3: &#x27;#333&#x27; h4: &#x27;#444&#x27; h5: &#x27;#555&#x27; h6: &#x27;#666&#x27; p: &#x27;#444&#x27; # 列表文字 list: &#x27;#666&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #000, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # ------------ # 暗色主题 dark: # 网站背景色 site_bg: &#x27;#222&#x27; # 网站背景上的文字 site_inner: &#x27;#eee&#x27; # 网站页脚文字 site_footer: &#x27;#aaa&#x27; # 卡片背景色 card: &#x27;#333&#x27; # 卡片上的普通文字 text: &#x27;#eee&#x27; # 区块和代码块背景色 block: &#x27;#3a3a3a&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#343a3c&#x27; # 行内代码颜色 inlinecode: &#x27;#D56D28&#x27; # 文章部分 h1: &#x27;#eee&#x27; h2: &#x27;#eee&#x27; h3: &#x27;#ddd&#x27; h4: &#x27;#ddd&#x27; h5: &#x27;#ddd&#x27; h6: &#x27;#ddd&#x27; p: &#x27;#bbb&#x27; # 列表文字 list: &#x27;#aaa&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #fff, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # 夜间图片亮度 brightness: 70%############################### Color Scheme ############################### &gt; end############################### Custom css ############################### &gt; startcustom_css: toc_smooth: true # TOC 目录平滑滚动效果 cursor: enable: #true text: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/text.png pointer: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/pointer.png default: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/left_ptr.png not-allowed: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/circle.png zoom-out: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/zoom-out.png zoom-in: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/zoom-in.png grab: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/openhand.png font_smoothing: true # font-smoothing for webkit max_width: 1080px # Sum of body width and sidebar width (This limit will be exceeded when the device width is greater than 2000px, reaching 75% of the total width) scrollbar: size: 4px border: 2px navbar: height: 64px width: auto # auto, max effect: [shadow, blur] # [shadow, floatable, blur] sidebar: effect: [shadow] # [shadow, floatable, blur] body: effect: [shadow] # [shadow, floatable, blur] highlight: language: true # show language of codeblock copy_btn: true grayscale: false # Enable grayscale effect text_align: # left, right, justify, center h1: left h2: left h3: left h4: left p: justify gap: h2: 48px # Spacing above H2 (only px unit) h3: 24px # Spacing above H3 (only px unit) h4: 16px # Spacing above H4 (only px unit) p: 1em # Paragraph spacing between paragraphs line_height: 1.6 # normal, 1.5, 1.75, 2 ... border_radius: card: 8px codeblock: 4px searchbar: 8px button: 4px fontsize: root: 16px h1: 1.5rem # 不推荐用在文章中 h2: 1.5rem h3: 1.25rem h4: 1.125rem h5: 1rem h6: 1rem list: .9375rem meta: .875rem code: .8125rem footnote: .78125rem fontfamily: logofont: fontfamily: &#x27;&quot;Varela Round&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;Varela Round&#x27; url: https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/VarelaRound/VarelaRound-Regular.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;UbuntuMono, &quot;Varela Round&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;UbuntuMono&#x27; url: https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/UbuntuMono/UbuntuMono-Regular.ttf weight: normal style: normal codefont: fontfamily: &#x27;Menlo, UbuntuMono, Monaco&#x27; # name: &#x27;Monaco&#x27; # url: https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/Monaco/Monaco.ttf # weight: normal # style: normal############################### Custom css ############################### &gt; end############################### Analytics ############################### &gt; startanalytics: busuanzi: #https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js leancloud: # 请使用自己的 id &amp; key 以防止数据丢失 app_id: u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI app_key: jfHtEKVE24j0IVCGHbvuFClp custom_api_server: # 国际版一般不需要写，除非自定义了 API Server############################### Analytics ############################### &gt; end############################### SEO ############################### &gt; startseo: # When there are no keywords in the article&#x27;s front-matter, use tags as keywords. use_tags_as_keywords: true # When there is no description in the article&#x27;s front-matter, use excerpt as the description. use_excerpt_as_description: true robots: home_first_page: index,follow home_other_pages: noindex,follow archive: noindex,follow category: noindex,follow tag: noindex,follow # robots can be written in front-matter############################### SEO ############################### &gt; end Shoka 虚位以待","categories":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/categories/Course/"}],"tags":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"Hexo","slug":"Hexo","permalink":"https://cheeseburgerim.github.io/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://cheeseburgerim.github.io/tags/Blog/"},{"name":"Theme","slug":"Theme","permalink":"https://cheeseburgerim.github.io/tags/Theme/"},{"name":"PersonalPage","slug":"PersonalPage","permalink":"https://cheeseburgerim.github.io/tags/PersonalPage/"},{"name":"ChangeTheme","slug":"ChangeTheme","permalink":"https://cheeseburgerim.github.io/tags/ChangeTheme/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://cheeseburgerim.github.io/tags/Butterfly/"}]},{"title":"New Computer","slug":"WTDWIBANC","date":"2021-04-12T15:26:41.000Z","updated":"2021-06-10T02:54:13.297Z","comments":false,"path":"2021/04/12/WTDWIBANC/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/12/WTDWIBANC/","excerpt":"","text":"本文主要针对Windows系统 用Hexo续写博客 安装Git 安装Node.js 安装Hexo 获取SSHkey SSHkey一般在C盘用户下的个人用户文件夹中 进入相应路径找到.ssh文件夹，如果没有此文件夹则新建一个.ssh文件夹 删除问价夹中所有的文件 win+R输入cmd打开命令窗 12ssh-keygen -t rsa -C &quot;your email address&quot;//要绑定Github或Gitee,则邮箱地址应为Github或Gitee的绑定邮箱 三次回车生成SSHkey id_rsa.pub为下面步骤所用到的SSHkey 登录Github或Gitee，在设置中新建SSHkey，title无所谓，将所得到的SSHkey添加到账户中 下载在之前电脑上备份的压缩包(目前一周备份一次)，解压 可以继续写博客了 Vscode配置C++环境 安装Vscode 一键三连 可以运行C++程序了 推荐的Vscode插件 Office Viewer Eclipse配置Java环境 下载JDK 安装JDK，目录不要有中文，不要有空格。假设安装目录为C:\\JAVA\\JDK 配置环境变量 安装Eclipse 选择工作空间后启动，新建Java项目，选中src，右键打开properties，resource，选择UTF-8 可以运行Java程序","categories":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/categories/Course/"}],"tags":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/tags/New/"},{"name":"NewBeginning","slug":"NewBeginning","permalink":"https://cheeseburgerim.github.io/tags/NewBeginning/"},{"name":"NewComputer","slug":"NewComputer","permalink":"https://cheeseburgerim.github.io/tags/NewComputer/"}]},{"title":"Java-Part7","slug":"Java/Java-Part7","date":"2021-04-07T13:06:34.000Z","updated":"2021-06-17T06:31:49.311Z","comments":false,"path":"2021/04/07/Java/Java-Part7/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/07/Java/Java-Part7/","excerpt":"","text":"Java中的多线程 线程定义 目前Java程序都是串行执行的，也就是每个语句依次执行； 有时候需要程序并行执行： 有时系统有多个工作要同时完成：例如一边打字、一边听歌；一边开视频会议、一边看网页； 利用CPU多线程的特性。 一个进程可以有多个线程在执行。 创建线程的方法 Method1 通过继承Thread类创建线程 注意启动线程用start()方法而不能用run()方法 1234567891011121314151617181920212223242526272829303132//ch09.TestThread1package ch09;/** * 多线程的例子，注意运行程序时候的输出 */public class TestThread1 &#123; public static void main(String args[]) &#123; Thread t = new MyThread1(100); t.start(); System.out.println(&quot;Main thead end!&quot;); &#125;&#125;class MyThread1 extends Thread &#123; private int n; public MyThread1(int n) &#123; this.n = n; &#125; public void run() &#123; for (int i = 0; i &lt; n; i++) &#123; System.out.print(&quot; &quot; + i); if ((i + 1) % 20 == 0) &#123; System.out.println(&quot;&quot;); &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; Method2 通过向Thread()构造方法传递Runnable对象来创建线程 注意启动线程用start()方法而不能用run()方法 1234567891011121314151617181920212223242526272829303132//ch09.TestThread2package ch09;/** * 多线程的例子 */public class TestThread2 &#123; public static void main(String args[]) &#123; MyThread2 mytask = new MyThread2(100); Thread t = new Thread(mytask); t.start(); &#125;&#125;class MyThread2 implements Runnable &#123; private int n; public MyThread2(int n) &#123; this.n = n; &#125; public void run() &#123; for (int i = 0; i &lt; n; i++) &#123; System.out.print(&quot; &quot; + i); if ((i + 1) % 20 == 0) &#123; System.out.println(&quot;&quot;); &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 两种方法比较 使用Runnable接口； 直接继承Thread类； 无论使用哪种方法，注意启动线程用start()方法而不能用run()方法。 多线程的实例 Example1 1234567891011121314151617181920212223242526272829//ch09.sync.sum.SumMain.javapackage ch09.sync.sum;public class SumMain &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int threadCount = 100; double sum = 0; long mill=System.currentTimeMillis(); SumThread[] threads = new SumThread[threadCount]; long start = 0; long end = 1000000000L; for (int i = 0; i &lt; threads.length; i++) &#123; long threadStart = start + (end - start) / threadCount * i; long threadEnd = start + (end - start) / threadCount * (i + 1); threads[i] = new SumThread(threadStart, threadEnd); threads[i].start(); &#125; for (int i = 0; i &lt; threads.length; i++) &#123; try &#123; threads[i].join(); sum = sum + threads[i].getSum(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;System.out.println((System.currentTimeMillis()-mill)+&quot; ms cost!&quot;); System.out.println(&quot;sum=&quot; + sum); &#125;&#125; thread.join()，等待这个线程结束； 多线程可以显著提升系统性能； 比较SumMain中1/2/3/4/5个线程时消耗的时间。 Example2(ridiculous!) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//ch09.join.MySort.javapackage ch09.join;import java.util.ArrayList;import java.util.List;/** * 一种奇葩的排序算法 */public class MySort extends Thread &#123; private List&lt;Integer&gt; list; private int value; public MySort(List&lt;Integer&gt; list, int value) &#123; this.list = list; this.value = value; &#125; @Override public void run() &#123; try &#123; this.sleep(value); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; list.add(value); &#125; public static void main(String[] args) &#123; int[] arrays = &#123; 1230, 571, 340, 454, 1, 30, 60, 300, 89, 1999, 765 &#125;; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); MySort[] threads = new MySort[arrays.length]; for (int i = 0; i &lt; arrays.length; i++) &#123; threads[i] = new MySort(list, arrays[i]); &#125; for (int i = 0; i &lt; arrays.length; i++) &#123; threads[i].start(); &#125; for (int i = 0; i &lt; arrays.length; i++) &#123; try &#123; threads[i].join(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; System.out.print(list.get(i)+&quot;,&quot;); &#125; &#125;&#125; Daemon线程和非Daemon线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445//ch09.TestThreadDaemon.javapackage ch09;/** * Daemon线程和非Daemon线程的区别 */public class TestThreadDaemon &#123; public static void main(String args[]) &#123; Thread t1 = new MyThread(); // 尝试一下false t1.setDaemon(true); t1.start(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;main thread end&quot;); &#125;&#125;class MyThread extends Thread &#123; static int id = 0; MyThread() &#123; id++; &#125; public void run() &#123; System.out.println(&quot;Start&quot;); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; &#125; // yield(); &#125; &#125;&#125;/* * 9.2.4 Daemon线程 * 线程有两种，一类是Daemon线程，一类是非Daemon线程。在Java程序中，若还有非Demon线程，则整个程序就不会结束；而Daemon线程， * 可以在整个程序结束后继续运行，所以Demon线程可以用于后台服务程序。 * 通过调用isDaemon()，可检查一个线程是不是一个Daemon；用setDaemon (boolean * flg)方法可以将一个线程设为Daemon线程。在一个Daemon线程中创建的子线程，也自动是Daemon线程。 * */ Thread.setDaemon(true/false)； Deamon线程→主程序终止，线程终止； 非Deamon线程→主程序终止，线程不终止。 多线程访问的冲突问题 解决方法 因为多线程的原因，同一个对象，同一个时刻可能有多个线程访问，进而导致冲突 解决方式：使用synchronized 可加在方法、对象、类上 12//ch09.counter0.SyncCounter0.java//ch09.sync.stack0.MyStackUserThread 解决了多线程访问冲突之后的例子 12//ch09.counter1.SyncCounter1.java//ch09.sync.stack1.MyStackUserThread synchronized带来的死锁问题 12345678910111213141516171819202122232425262728293031323334353637383940//ch09.lock.DeadLockTestpackage ch09.lock;/** * 死锁的例子 */public class DeadLockTest &#123; public static void main(String args[]) &#123; Operator o1 = new Operator(); Operator o2 = new Operator(); o1.anotherOperator = o2; o2.anotherOperator = o1; Thread t1 = new Thread(o1); Thread t2 = new Thread(o2); t1.start(); t2.start(); &#125;&#125;//ch09.lock.Operator.javapackage ch09.lock;/** */public class Operator implements Runnable &#123; Operator anotherOperator; synchronized public void methodA(int depth) &#123; System.out.println(Thread.currentThread().getName() + &quot;:begin methodA&quot;); if(depth&lt;=0) &#123; return; &#125; try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; &#125; System.out.println(Thread.currentThread().getName() + &quot;:call another methodA&quot;); anotherOperator.methodA(--depth); System.out.println(Thread.currentThread().getName() + &quot;:end methodA&quot;); &#125; public void run() &#123; methodA(1); &#125;&#125; 由于Operator中定义的methodA方法有synchronized修饰，所以当o1i调用方法的同时需要o2也调用该方法，但是o2在等待o1，造成了相互等待的情况，即死锁。反之亦然 死锁 定义 当一个线程等待由另一个线程持有的锁，而后者正在等待已被第一个线程持有的锁时，就会发生死锁； Java不监测也不视图避免这种情况。因而保证不发生死锁就成了程序员的责任。 实例 1//ch09.lock.DeadLockTest 避免死锁 控制锁的范围； 按序分配资源。 程序的状态与生命周期 在一个线程的生命周期中，它总处于某一种状态中； 线程的状态表示了线程正在进行的活动以及在这段时间内线程能完成的任务。 多线程的控制 生产者·消费者问题 不断使用某类资源的线程称为消费者； 不断产生或释放同类资源的线程称为生产者； 通过协调生产者和消费者的关系，保证生产的东西及时消费掉，也保证消费者总能够有资源可使用。 12345678910111213//ch09.producer_consumer.ProducerConsumerDemo.javapackage ch09.producer_consumer;/** * 一个生产者、消费者模型的例子 */public class ProducerConsumerDemo &#123; public static void main(String args[]) &#123; Stack stack = new Stack(&quot;stack1&quot;); new Producer(stack, &quot;producer1&quot;).start(); new Consumer(stack, &quot;consumer1&quot;).start(); &#125; &#125;//producer和consumer的定义在同一个包下 线程中常用方法 notify()/notifyAll() notify()：用来选择并唤醒等候进入监视器的线程； notifyAll()：唤醒所有等待的线程； 只有获得锁以后，才有权力调用notify()/notifyAll()方法。 wait()方法 wait()方法使当前线程处于等待状态，直到别的线程调用notify()方法来通知/唤醒它 如何终止线程 当线程执行完run()方法，它将自然终止运行； Thread有一个stop()方法，可以强制结束线程，但这种方法是不安全的。因此，目前stop()方法已经被废弃； 实际编程中，一般是定义一个标志变量，然后通过程序来改变标志变量的值，从而控制线程从run()方法中自然退出。 123456789101112131415161718192021222324252627282930313233//ch09.ThreadTerminateByFlag.javapackage ch09;import java.util.*;public class ThreadTerminateByFlag &#123; public static void main(String args[]) &#123; Timer timer = new Timer(); Thread thread = new Thread( timer ); thread.setName( &quot;Timer&quot; ); thread.start(); for( int i=0; i&lt;100; i++ )&#123; System.out.print(&quot;\\r&quot; + i ); try&#123; Thread.sleep(100); &#125;catch( InterruptedException e )&#123;&#125; &#125; timer.stopRun(); &#125;&#125;class Timer implements Runnable &#123; boolean flg = true; public void run() &#123; while(flg)&#123; System.out.print( &quot;\\r\\t&quot; + new Date() + &quot;...&quot; ); try&#123; Thread.sleep(1000); &#125;catch( InterruptedException e )&#123;&#125; &#125; System.out.println( &quot;\\n&quot; + Thread.currentThread().getName() + &quot; Stop&quot; ); &#125; public void stopRun()&#123; flg = false; &#125;&#125; 定时器：Timer&amp;TimerTask 1234567891011121314151617181920212223242526//ch09.TimerTaskDemopackage ch09;import java.util.Timer;import java.util.TimerTask;/** * timertask例子 */public class TimerTaskDemo &#123; public TimerTaskDemo() &#123; // TODO Auto-generated constructor stub &#125; // public static void main(String[] args) &#123; // Timer timer = new Timer(); // timer.schedule(new MyTimerTask(), 0, 1000L); // &#125; public static void main(String[] args) &#123; Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; int i = 0; public void run() &#123; System.out.println(i++); &#125; &#125;, 0, 1000L); &#125;&#125;//ch09.TimerTaskDemo2 进程的优先级 Thread.setPriority(Thread.MAX_PRIORITY/NORM_PRIORITY/MIN_PRIORITY); 123456789101112131415161718192021222324252627282930313233343536373839//ch09.TestThreadPriority.javapackage ch09;/** * 本例子显示了不同的优先级对线程的影响 */public class TestThreadPriority &#123; public static void main(String args[]) &#123; Thread[] threads = new Thread[10]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(new MyRunner(i)); if (i % 3 == 0) &#123; threads[i].setPriority(Thread.MAX_PRIORITY); &#125; else if (i % 3 == 1) &#123; threads[i].setPriority(Thread.NORM_PRIORITY); &#125; else &#123; threads[i].setPriority(Thread.MIN_PRIORITY); &#125; &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].start(); &#125; &#125;&#125;class MyRunner implements Runnable &#123; int id; MyRunner(int id) &#123; this.id = id; &#125; public void run() &#123; double t = 0; for (int j = 0; j &lt; 100000000; j++) &#123; t = t + j; // if (j % 100 == 0) &#123; // Thread.currentThread().yield(); // &#125; &#125; System.out.println(id + &quot; finished!&quot;); &#125;&#125; ThreadLocal 如何在不传递参数的情况下，让一个线程实用程序外的一个变量？ ThreadLocal是一个线程内部的存储类； 线程间互不干扰。 12345678910111213141516171819202122232425//ch09.thread_local.MyThreadLocal.javapackage ch09.thread_local;/** * ThreadLocal 变量 */public class MyThreadLocal extends Thread &#123; public void run() &#123; for(int i=0;i&lt;5;i++)&#123; try &#123; Thread.currentThread().getName(); String value=this.getName()+&quot; &quot;+i; MyValue.getSession().set(value); Thread.sleep(1000); MyFunction.print(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 2; i++) &#123; new MyThreadLocal().start(); &#125; &#125; &#125; 文章源码 文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"Java-Part6","slug":"Java/Java-Part6","date":"2021-04-05T07:53:40.000Z","updated":"2021-06-17T06:31:41.662Z","comments":false,"path":"2021/04/05/Java/Java-Part6/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/05/Java/Java-Part6/","excerpt":"","text":"输入、输出流及文件管理 文件及目录 File类 File类提供了若干处理文件、目录和获取它们基本信息的方法； java中目录也是文件(File)，java中没有Directory类； 1234567//File类的构造方法有三个//1File(String pathname);//2File(String parent,String child);//3File(File parent,String child); 文件类例子 在Java中，将目录也当作文件处理 1234567File f;f=new File(&quot;Test.java&quot;);//f=new File(&quot;E:\\\\ex\\\\&quot;,&quot;Test.java&quot;);//File path=new File(&quot;E:\\\\ex\\\\&quot;);File f=new File(path,&quot;Test.java&quot;); File类方法介绍 File类的作用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//创建目录//ch08.UseFile.main()//递归列目录//ch08.UseFile.listDir()//递归删目录//ch08.UseFile.deleteDir()//ch08.UseFile.javapackage ch08;import java.io.File;import java.io.IOException;import java.util.Date;public class UseFile &#123; public static void main(String args[]) throws Exception &#123; // 创建目录 File dir1 = new File(&quot;D:/dir1&quot;); if (!dir1.exists()) &#123; dir1.mkdir(); &#125; // 在某个目录下 创建目录 File dir2 = new File(dir1, &quot;dir2&quot;); if (!dir2.exists()) &#123; dir2.mkdirs(); &#125; // 在某个目录下 创建多层目录 File dir4 = new File(dir1, &quot;dir3\\\\dir4&quot;); if (!dir4.exists()) dir4.mkdirs(); // 在某个目录下 创建文件 File file = new File(dir2, &quot;test.txt&quot;); if (!file.exists()) &#123; file.createNewFile(); &#125; file = new File(&quot;D:/dir1/mytest.txt&quot;); if (!file.exists()) &#123; file.createNewFile(); &#125; listDir(dir1); deleteDir(dir1); &#125; /** * 察看目录信息 */ public static void listDir(File dir) throws IOException &#123; if (dir.isFile()) &#123; System.out.println( &quot;文件:&quot; + dir.getCanonicalPath() + &quot; 修改日期:&quot; + new Date(dir.lastModified()) + &quot; 大小:&quot; + dir.length()); return; &#125; File[] lists = dir.listFiles(); // 打印当前目录下包含的所有子目录和文件的详细信息 for (int i = 0; i &lt; lists.length; i++) &#123; File f = lists[i]; // 如果为目录，就递归调用listDir()方法 System.out.println(&quot;目录:&quot; + f.getCanonicalPath() + &quot; 修改日期:&quot; + new Date(f.lastModified())); listDir(f); &#125; &#125; /** 删除目录或文件，如果参数file代表目录，会删除当前目录以及目录下的所有内容 */ public static void deleteDir(File file) &#123; // 如果file代表文件，就删除该文件 if (file.isFile()) &#123; file.delete(); return; &#125; // 如果file代表目录，先删除目录下的所有子目录和文件 File[] lists = file.listFiles(); for (int i = 0; i &lt; lists.length; i++) &#123; deleteDir(lists[i]); // 递归删除当前目录下的所有子目录和文件 &#125; // 最后删除当前目录 file.delete(); &#125;&#125;//递归列目录//ch08.ListAllFiles.javapackage ch08;import java.io.*;/** * 使用递归的方式，列出一个目录下面所有的子目录和文件 */public class ListAllFiles &#123; public static void main(String[] args) &#123; ListFiles(new File(&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\&quot;)); &#125; public static void ListFiles(File dir) &#123; if (!dir.exists() || !dir.isDirectory()) &#123; return; &#125; String[] files = dir.list(); for (int i = 0; i &lt; files.length; i++) &#123; File file = new File(dir, files[i]); if (file.isFile()) &#123; System.out.println(dir + &quot;\\\\&quot; + file.getName() + &quot;\\t size=&quot; + file.length()); &#125; else &#123; System.out.println(dir + &quot;\\\\&quot; + file.getName() + &quot;\\t&lt;dir&gt;&quot;); ListFiles(file); // 对于子目录,进行递归调用 &#125; &#125; &#125;&#125; 输入流/输出流 定义 大部分程序都需要输入/输出处理，比如从键盘读取数据、向屏幕中输出数据、从文件中读或者向文件中写数据、在一个网络连接上进行读写操作等。在Java中，把这些不同类型的输入、输出源抽象为流Stream； 按流的方向，可分为输入流与输出流。 字节流与字符流 字节流(byte) 字符流(char) 输入 InputStream Reader 输出 OutputStream Writer InputStream类 InputStream类最重要的方法是读数据的read()方法。read()方法功能是逐字节地以二进制的原始方式读取数据 1234567//read()读取数据有三种形式//1public int read();//2public int read(byte b[]);//3public int read(byte[] b,int off,int len); OutputStream类 OutputStream类的重要方法是write()，它的功能是将字节写入流中，write()方法有三种形式 1234567891011121314//1public void write(int b);//将参数b的低位字节写入到输出流//2public void write(byte b[]);//将字节数组b[]中的全部字节顺序写入到输出流//3public void write(byte[] b,int off,int len);//将字节数组b[]中从off开始的len个字节写入到流中//Others functionspublic void flush();//强制输出缓冲区中的数据public void close();//关闭流 Reader类 Reader类与InputStream类相似，都是输入流，但差别在于Reader类读取的字符(char)，而不是字节； Reader的重要方法是read()，共有三种形式： 123public int read();public int read(char b[]);public int read(char[] b,int off,int len); Writer类 Writer类与OutputStream类相似，都是输出流，但差别在于Writer类写入的字符(char)，而不是字节 123456789101112public void write(int b);//将参数b的低两字节写入到输出流public void write(char b[]);//将字符数组b[]中的全部字节顺序写入到输出流public void write(char[] b,int off,int len);//将字节数组b[]中从off开始的len个字符写入到流中public void write(String s);//将字符串写入流中public void write(String s,int off,int len);//将字符串中从off开始的len个字符写入到流中public void flush();//刷新流public void close();//关闭流 节点流和处理流 按照流是否直接与特定的地方(如磁盘、内存、设备等)相连，分为节点流与处理流两类 节点流(Node Stream) 可以从或向一个特定的地方(节点)读写数据。如文件流FileReader 处理流(Processing Stream) 是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读、写功能。处理流又称为过滤流，如缓冲处理流BufferedReader 节点流与处理流的关系 其关系如上图所示； 节点流直接与节点(如文件)相连，而处理流对节点流或其他处理流进一步进行处理(如缓冲、组装成对象等等)。 123456//处理流的构造方法总是要带一个其他的流对象作为参数//For example:BufferedReader in=new BufferedReader(new FileReader(file));BufferedReader in2=new BufferedReader( new InputstReamreader( new FileInputStream(file))); 一个流对象经过其他流的多次包装，称为流的链接 常用的节点流 节点类型 字节流 字符流 File文件 FileInputStreamFileOutputStream FileReaderFileWriter Memory Array内存数组 ByteArrayInputStreamByteArrayOutputStream CharArrayReaderCharArrayWriter Memory String StringReaderStringWriter Pipe管道 PipedInputStreamPipedOutputStream PipedReaderPipedWriter 常用的处理流 处理类型 字节流 字符流 Buffering缓冲 BufferedInputStreamBufferedOutputStream BufferedReaderBufferedWriter Filtering过滤 FilterInputStreamFilterOutputStream FilterReaderFilterWriter Converting between bytes and character字节流转为字符流 InputStreamReaderOutputStreamWriter Object Serialization对象序列化 ObjectInputStreamObjectOutputStream Data conversion基本数据类型转化 DataInputStreamDataOutputStream Counting行号处理 LineNumberInputStream LineNumberReader Peeking ahead可回退流 PushbackInputStream PushbackReader Pinting可显示处理 PrintStream PrintWriter 输入输出流例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177//ch08.ReadWriteFileByteDemo.java//InputStream/OutputStreampackage ch08;import java.io.Closeable;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * 本例子演示了如何用面向byte的方式 读取、写入文件 */public class ReadWriteFileByteDemo &#123; public static int CHUNK_SIZE = 4096; public ReadWriteFileByteDemo() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; copyFile(&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\ch08\\\\src.txt&quot;,&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\ch08\\\\target.txt&quot;); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; /** * 复制IO流 * @throws IOException */ public static void copyIO(InputStream in, OutputStream out) throws IOException &#123; byte[] buf = new byte[CHUNK_SIZE]; /** * 从输入流读取内容并写入到另外一个流的典型方法 */ int len = in.read(buf); while (len != -1) &#123; out.write(buf, 0, len); len = in.read(buf); &#125; &#125; /** * 复制文件 * @throws IOException */ public static void copyFile(String fsrc, String fdest) throws IOException &#123; InputStream in = null; OutputStream out = null; try &#123; in = new FileInputStream(fsrc); out = new FileOutputStream(fdest, true); copyIO(in, out); &#125; finally &#123; close(in); close(out); &#125; &#125; /** * 关闭一个输入 输出流 */ public static void close(Closeable inout) &#123; if (inout != null) &#123; try &#123; inout.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;//ch08.ReadWriteFileCharDemo.java//Reader/Writerpackage ch08;import java.io.Closeable;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileReader;import java.io.IOException;import java.io.LineNumberReader;import java.io.OutputStream;import java.io.Reader;import java.util.ArrayList;import java.util.List;/** * 本例子演示了如何使用char的方式 读取、写入文件 */public class ReadWriteFileCharDemo &#123; public static int CHUNK_SIZE = 4096; public ReadWriteFileCharDemo() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; String s = &quot;&quot;; try &#123; s = readFile(&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\ch08\\\\src.txt&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(s); try &#123; writeFile(&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\ch08\\\\target.txt&quot;, s); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; /** * 注意readFile和readFile2等效 * @throws IOException */ public static String readFile(String fsrc) throws IOException &#123; //这句话是否可以写成Reader reader ;为什么？ Reader reader = null; try &#123; reader = new FileReader(fsrc); StringBuffer buf = new StringBuffer(); char[] chars = new char[CHUNK_SIZE]; int readed = reader.read(chars); // 从一个流里面读取内容的经典写法 while (readed != -1) &#123; // 文件是size不能被CHUNK_SIZE整除，所以要记录每次读到的长度readed // 写入到buf的时候，不是用的 buf.append(chars); // 而是用buf.append(chars, 0, readed); buf.append(chars, 0, readed); readed = reader.read(chars); &#125; return buf.toString(); &#125; finally &#123; //reader!=null的判断是否可以取消，为什么？ if (reader != null) &#123; reader.close(); &#125; &#125; &#125; /** * 从一个文件中读取字符串 * @throws IOException */ public static String readFile2(String fsrc) throws IOException &#123; try (Reader reader = new FileReader(fsrc);) &#123; StringBuffer buf = new StringBuffer(); char[] chars = new char[CHUNK_SIZE]; int readed = reader.read(chars); // 从一个流里面读取内容的经典写法 while (readed != -1) &#123; buf.append(chars, 0, readed); readed = reader.read(chars); &#125; return buf.toString(); &#125; &#125; /** * 把字符串写到文件中 * @throws IOException */ public static void writeFile(String fileName, String content) throws IOException &#123; try (OutputStream out = new FileOutputStream(fileName, false)) &#123; out.write(content.getBytes()); out.flush(); &#125; &#125; /** * 关闭输入输入流 */ public static void close(Closeable inout) &#123; if (inout != null) &#123; try &#123; inout.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 再谈节点流和处理流 使用处理流的例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//ch08.ReadFileByProcessingStream.javapackage ch08;import java.io.Closeable;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileReader;import java.io.IOException;import java.io.LineNumberReader;import java.io.OutputStream;import java.io.Reader;import java.util.ArrayList;import java.util.List;/** * 本例子演示了如何使用char的方式 读取、写入文件 */public class ReadFileByProcessingStream &#123; public static int CHUNK_SIZE = 4096; public ReadFileByProcessingStream() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; try &#123; List&lt;String&gt; lines = readLines(&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\ch08\\\\XiaoHe.ini&quot;); for (String line : lines) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; /** * 从一个文本文件中，一次读取一行，放到list中 * @throws IOException */ public static List&lt;String&gt; readLines(String fsrc) throws IOException &#123; try (Reader reader = new FileReader(fsrc); //LineNumberReader 必须在其他流基础上构建 LineNumberReader lineReader = new LineNumberReader(reader);) &#123; String line = &quot;&quot;; List&lt;String&gt; lines = new ArrayList&lt;String&gt;(); while (line != null) &#123; lines.add(line); //每次读取一行 line = lineReader.readLine(); &#125; return lines; &#125; &#125;&#125; System中的标准输入和标准输出 System.out提供向&quot;标准输出&quot;写出数据的功能 System.out为PrintStream类型； System.in提供从&quot;标准输入&quot;读入数据的功能 System.in为InputStream类型； System.err提供向&quot;标准错误输出&quot;写出数据的功能 System.err为PrintStream类型。 向标准输出写出数据 System.out/System.err的println/print方法 println方法可将方法参数输出并换行； print方法将方法参数输出但不换行； print和prinln方法针对多数数据类型进行了重写(boolean, char, int, long, float, double, char[], Object, String)； print(Object)和println(Object)方法中调用了参数的toString()方法，再将生成的字符串输出。 从标准输入读取数据 为了使用方便，经常将System.in用各种处理流进行封装处理 1234//For example:BufferedReader br=new BufferedReader( new InputStreamReader(System.in));br.readLine(); 文件的随机访问RandomAccessFile类 基于文本应用的几个问题 命令行参数 在启动Java应用程序时可以一次性地向应用程序中传递0~多个参数——命令行参数； 命令函参数使用格式： 1java ClassName lisa &quot;bily&quot; &quot;Mr Brown&quot; 命令行参数被系统以String数组的方式传递给应用程序中的main方法，由参数args接收 1public static void main(String[] args)&#123;&#125; 12345678910111213//ch08.TestCommandLinepackage ch08;/** * 演示了命令行的作用 */public class TestCommandLine &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; args.length; i++) &#123; // 运行时，使用java TestCommandLine lisa &quot;bily&quot; &quot;Mr Brown&quot; System.out.println(&quot;args[&quot; + i + &quot;] = &quot; + args[i]); &#125; &#125;&#125; 命令行参数用法举例 系统属性(System Properties) 在Java中，系统属性起到替代环境变量的作用(环境变量是平台相关的)； 可使用System.getProperties()方法获得一个Properties类的对象，其中包含了所有可用的系统属性信息； 可使用System.getProperties(String name)方法获得特定系统属性的属性值； 在命令行运行Java程序时可使用-D选项添加新的系统属性。 123456789101112131415161718//ch08.TestProperties.javapackage ch08;import java.util.Iterator;import java.util.Properties;/** * 本例子演示了如何取得System.properties */public class TestProperties &#123; public static void main(String[] args) &#123; Properties ps = System.getProperties(); Iterator&lt;Object&gt; it = ps.keySet().iterator(); while (it.hasNext()) &#123; String pName = (String) it.next(); String pValue = ps.getProperty(pName); System.out.println(pName + &quot;=&quot; + pValue); &#125; &#125;&#125; 正则表达式 定义 正则表达式是文本处理中常用的工具，它实际上是用来匹配字符串的一种模式。在Java中有一个正则表达式引擎(在java.util.regex包中)，可以用正则表达式来验证和处理文本字符 基本元素 123456789101112131415161718192021222324252627282930313233343536373839//ch08.RegExpDemopackage ch08;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 本例子演示了正则表达式的用法 */public class RegExpDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub findEmail( ); testTels(); splitContent(); &#125; public static void testTels( ) &#123; testTel(&quot;13820477575&quot;); testTel(&quot;123456&quot;); &#125; private static void testTel(String content) &#123; boolean match=content.matches(&quot;[0-9]&#123;11&#125;&quot;); System.out.println(content +(match?&quot; &quot;:&quot; 不&quot;)+&quot;是合法的电话号码&quot;); &#125; public static void findEmail( ) &#123; String content = &quot;天外天技术支持：cs@tju.edu.cn 联系我们：1234567890@qq.com 地址：天津市南开区&quot;; String telReg = &quot;\\\\w+@\\\\w+.[\\\\w+]+&quot;; Pattern telPattern = Pattern.compile(telReg); Matcher m = telPattern.matcher(content); while (m.find()) &#123; System.out.println(m.group(0)); &#125; &#125; public static void splitContent() &#123; String content=&quot; 第一回 甄士隐梦幻识通灵 贾雨村风尘怀闺秀 ... 第二回 贾夫人仙逝扬州城 冷子兴演说荣国府 ... 第三回 托内兄如海酬训教 接外孙贾母惜孤女 ....&quot;; String contents[] = content.split(&quot;第[一,二,三,四,五,六,七,八,九,十,零]&#123;1,3&#125;回 &quot;); for(String title:contents) &#123; System.out.println(title); &#125; &#125;&#125; Points try{}final{}中如果有impments Closable的对象要申请并关闭的时候，ch08.ReadWriteFileCharDemo中两种写法等效 reader必须impments Closable； 必须在try{}里面申请。 12//From ch08.ReadWriteFileCharDemo//readFile &amp; readFile2 修改文本文件中内容 123456789101112131415161718192021222324252627282930313233343536import java.io.*;public class FileTool&#123; //修改homeDir中的txt文件，包括子目录下的txt文件，将orgStr改为targetStr public void replaceTxtFileContent(String homeDir,String orgStr,String targetStr) &#123; File file=new File(homeDir); if(file.isDirectory()) &#123; for(String str:file.list()) &#123; if(str.endsWith(&quot;.txt&quot;)) &#123; String filename=homeDir+str+&quot;/&quot;; File temp=new File(filename); try &#123; BufferedReader reader=new BufferedReader(new FileReader(filename)); String line=reader.readLine(); //不能直接对line进行修改，因为line是reader读出的数据，不能直接利用字符串修改 String newLine=line.replaceAll(orgStr, targetStr); //需要新建一个字符串，将orgStr替换为targetStr //新建文件输出流 FileOutputStream os=new FileOutputStream(temp); OutputStreamWriter writer=new OutputStreamWriter(os,&quot;UTF-8&quot;); writer.append(newLine);//向缓冲区写入修改后的字符串 writer.close();//关闭writer后，会将缓冲区的数据写入目标文件 &#125; catch (FileNotFoundException e) &#123; System.out.println(filename); e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; File temp=new File(homeDir+str+&quot;/&quot;); if(temp.isDirectory()) &#123; replaceTxtFileContent(homeDir+str+&quot;/&quot;,orgStr,targetStr); &#125; &#125; &#125; &#125;&#125; 查看文件大小 12File file=new File(filePath);long fileSize=file.length(); 文章源码 文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"CodeExercise-2021/4","slug":"CodeExercise/CE-2021-4","date":"2021-04-01T01:55:42.000Z","updated":"2021-04-01T01:59:01.544Z","comments":false,"path":"2021/04/01/CodeExercise/CE-2021-4/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/01/CodeExercise/CE-2021-4/","excerpt":"","text":"","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"CodeExercise","slug":"CodeExercise","permalink":"https://cheeseburgerim.github.io/tags/CodeExercise/"},{"name":"Exercise","slug":"Exercise","permalink":"https://cheeseburgerim.github.io/tags/Exercise/"},{"name":"Practice","slug":"Practice","permalink":"https://cheeseburgerim.github.io/tags/Practice/"}]},{"title":"数值计算方法与Matlab","slug":"NCMAM","date":"2021-03-31T13:25:48.000Z","updated":"2021-06-17T06:35:53.858Z","comments":false,"path":"2021/03/31/NCMAM/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/31/NCMAM/","excerpt":"","text":"数值计算方法与 MATLAB 复习提纲 误差的基本知识，数值算法的稳定性和收敛性； GAUSS 消去法（顺序消去法、列主元素法和全主元素法）的基本思想，GAUSS 消去法与矩阵 三角分解的关系； 直接三角分解法的基本思想，会应用追赶法解题； 线性空间、内积空间、赋范线性空间、内积、范数、谱半径等基本概念。掌握内积、范数和谱 半径计算； 条件数及其与线性方程组的性态的关系，方程组直接解法的误差分析的主要思想与结论； 线性方程组的三个迭代法和收敛性分析, 会应用收敛性定理； 插值问题的基本思想，相关概念和几何意义； Lagrange 与 Newton 插值公式和余项及其应用，相关基本性质、概念； Hermit 插值，分段插值，三次（m 次）样条插值的基本概念及其基本思想； 正交函数和正交多项式，Legendre 正交多项式（记住：P0 、P1 、P2 和 P3），切比雪夫(Chebyshev) 正交多项式。会应用正交的性质解题； 最佳平方逼近的基本思想及其应用（相关定义、定理及几何意义）； 曲线拟合的最小二乘法的基本思想及其应用； 数值积分的相关基本概念，如：代数精度、插值型公式的含义等； Newton-Cotes 公式和余项（梯形公式、Simpson 公式）及其应用； 复化求积法的基本概念与思想，复化梯形公式、Simpson 公式和余项及其应用； 变步长求积法的基本思想和变步长的梯形公式及其应用。Richardson 外推算法的基本思想及其应 用：Romberg 算法及其应用； Gauss 求积公式的基本概念与思想，两点、三点 Gauss-Legendre 公式及其应用； 插值型数值微分公式的基本思想，余项及其应用（一阶，二阶，两点、三点公式）； 常微分方程初值问题数值解法的三种计算格式的思想、截断误差等相关概念。（各种）Euler 公式、 梯形公式、改进的 Euler 公式及与应用； Runge-Kutta 方法的基本思想。四阶经典 R-K 方法及其应用； 一阶常微分方程组和高阶方程的初值问题数值解法。（各种）Euler 公式、梯形公式、改进的 Euler 公式及四阶经典 R-K 公式及其应用。","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"NCMAM","slug":"NCMAM","permalink":"https://cheeseburgerim.github.io/tags/NCMAM/"},{"name":"Math","slug":"Math","permalink":"https://cheeseburgerim.github.io/tags/Math/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"}]},{"title":"Java-Part5","slug":"Java/Java-Part5","date":"2021-03-30T14:20:21.000Z","updated":"2021-06-17T06:31:33.917Z","comments":false,"path":"2021/03/30/Java/Java-Part5/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/30/Java/Java-Part5/","excerpt":"","text":"工具类及常用算法 一 Java基础类库 java.lang.Object类 Object类是Java程序中所有类的直接或间接父类 equals() 用来比较两个对象是否相同，如果相同，则返回true；否则返回false； 它比较的是两个对象状态和功能上的相同，而不是引用上的相同； Object.equals默认实现 123public boolean equals(Object obj)&#123; return (this==obj);&#125; Integer.equals实现 123456public boolean equals(Object obj)&#123; if(obj instanceof Integer)&#123; return value==((Integer)obj).intValue(); &#125; return false;&#125; String.equals实现 1234567891011121314151617181920212223//ch07.eq.TestEqualsString//ch07.eq.TestEqualsObjectpublic boolean equals(Object anObject)&#123; if(this==anObject)&#123; return true; &#125; if(anObject instanceof String)&#123; String anotherString=(String)anObject; int n=value.length; if(n==anotherString.value.length)&#123; char v1[]=value; char v2=another.value; int i=0; while(n--!=0)&#123; if(v1[i]!=v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 在强调一次，equals()比较的是两个对象状态和功能上的相同，而不是引用上的相同 123456Integer one=new Integer(1);Integer anotherOne=new Integer(1);if(one.equals(anotherOne))&#123; System.out.println(&quot;Objects are equal&quot;);&#125;//例中，equals方法返回true，因为对象One和anotherOne包含相同的数值1 getClass() getClass()方法是final方法，它不能被重载； 它返回一个对象在运行时所对应的类的表示，从而可以得到相应的信息。 下面的方法得到并显示对象的类名： 123void PrintClassName(Object obj)&#123; System.out.println(&quot;The object&#x27;s class is&quot;+obj.getClass().getName());&#125; toString() toString()方法用来返回对象的字符串表示，可以用来显示一个对象； 通过重载toString()方法可以适当地显示对象的信息以进行调试。 finalize() 用于在垃圾收集前清楚对象。 基本数据类型的包装类 double转成String的几种方法 String转成double的几种方法 Math类 System类 1//ch07.SystemDemo 字符串 程序中需要用到的字符串可以分为两大类，一类是创建之后不会再做修改和变动的字符串常量；另一类是创建之后允许再做更改和变化的字符串。前者是String类，后者是StringBuffer/StringBuilder类。 Character：这个类的实例可以容纳单一的字符数值。该类还定义了一些简洁的方法来操作或者检查单一字符数据； String：这个类用于处理由多个字符组成的不可变数据； StringBuffer：这个类用于存储和操作由多个字符组成的可变数据； StringBuilder：基本同StringBuffer。 集合类 Java集合类框图 Set：无序，唯一； List：有序，不唯一； Map：key→value。 Set(集) 定义 Set是最简单的集合，集合中的对象不按照特定的方式排序，并且没有重复地对象； Set接口主要有两个实现类： HashSet； TreeSet。 一般用法 1234567891011121314151617181920212223242526//ch07.set.SetDemopackage ch07.set;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class SetDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Set set = new HashSet(); String str = &quot;我是天津大学一名学生&quot;; char[] chars = str.toCharArray(); for (int i = 0; i&lt;chars.length; i++) &#123; set.add(chars[i]); &#125; System.out.println(&quot;不同字符数量： &quot; + set.size()); printSet(set); &#125; public static void printSet(Set set) &#123; // 遍历一个set的方法 Iterator it = set.iterator(); while (it.hasNext()) &#123; System.out.print(it.next()); &#125; &#125;&#125;//ch07.set.SetDemo2 Set集合中存放的是对象，并且没有重复对象； Java中实现Set接口的类很多，例如 1Set set=new HashSet(); 这样就创建了一个集合对象，我们把它当作抽象接口看待； 使用接口的好处在于，实现类将来可以被替换，而程序不用做很多改动。 HashSet类 HashSet类按照哈希算法来存取集合中的对象，具有很好的存取和查找性能； 当向集合中加入一个对象时，HashSet会调用对象的hashCode()方法来获得哈希码，然后根据哈希码进一步计算出对象在集合中的位置。 散列技术的原理 把对象的哈希码直接用一个固定的公式计算，得出存储位置的方法； 优点是：可以快速命中搜索的目标。 HashSet正常工作的前提 两个你认为相同的对象其hashCode()必须相同且两个对象用equals()方法比较的结果为true 1//ch07.set.SetHashCodeEqDemo TreeSet类 TreeSet采用树结构来存储数据，数据打印出来是有序的； 当向集合中加入一个对象时，会把它插入到有序的对象集合中； TreeSet支持两种排序方式： 自然排序； 自定义排序。 默认情况下采用自然排序。 自然排序 要求被排序的对象实现了Comparable接口的compareTo(Object o)方法 1234x.compareTo(y)x==y return 0;x&gt;y return +;x&lt;y return -; 在JDK类库中已经实现Comparable接口的一些类 12345678910111213141516171819202122232425262728//TreeSet的自然排序//ch07.set.TreeSetDemopackage ch07.set;import java.util.HashSet;import java.util.Hashtable;import java.util.Set;import java.util.SortedSet;import java.util.TreeSet;import ch07.Student;import ch07.bak.Dog;public class TreeSetDemo &#123; public TreeSetDemo() &#123; // TODO Auto-generated constructor stub &#125; public static void main (String[] args) &#123; // TODO Auto-generated method stub Set set = new TreeSet(); set.add(0); set.add(5); set.add(2); set.add(01); Object[] ds = set.toArray( ); for (int i = 0; i &lt; ds.length; i++) &#123; System.out.println(ds[i]); &#125; &#125;&#125;//ch07.set.TreeSetDemo2 自定义排序 遍历Set Method1 1234567Set set=new TreeSet();set.add(new Integer(0));......int sum=0;Integer[] list=(Integer[])set.toArray(new Integer[0]);for(int i=0;i&lt;list.length;i++)&#123; sum=sum+list[i];&#125; Method2 1234567Set set=new TreeSet();set.add(new Integer(0));......int sum=0;Object[] list=set.toArray();for(int i=0;i&lt;list.length;i++)&#123; sum=sum+(Integer)list[i];&#125; Method3 1234567Set set=new TreeSet();set.add(new Integer(0));......int sum=0;Iterator it=set.iterator();while(it.hasNext())&#123; sum=sum+(Integer)it.next();&#125; Set用途 1234567891011121314151617181920212223//ch07.set.TreeSetUsagepackage ch07.set;import java.util.Iterator;import java.util.Set;import java.util.TreeSet;public class TreeSetUsage &#123; public TreeSetUsage() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; Set set = new TreeSet(); String content = &quot;China will strengthen international cooperation on novel coronavirus epidemic control and continue to provide assistance within its ability to countries affected by the epidemic, Xi Jinping, general secretary of the Communist Party of China Central Committee, said on Wednesday.&quot;; String[] words = content.split(&quot; &quot;); for (int i = 0; i &lt; words.length; i++) &#123; String word = words[i]; set.add(words[i]); &#125; Iterator it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; 保存/统计不重复的对象 判断一个文本有多少不同字符； 判断一个文本有多少不同字符单词、汉字； 判断一个对象是否已经存在了； … 使用TreeSet还可以快速排序 List(列表) 定义 List的主要特征是按照元素以先行方式存储，允许集合中存放重复对象； List接口的主要实现包括： ArrayList； LinkedList。 ArrayList：代表长度可以变化的数组。允许对元素进行快速的随机访问，但是向ArrayList中插入与删除元素速度较慢； LinkedList：双向链表。向LinkedList中插入和删除元素的速度较快，随机访问的速度较慢 1234567//它单独具有以下方法addFirst()addLast()getFirst()getLast()removeFirst()removeLast() 访问List中的元素 List中的对象按照索引位置排序，程序可以按照对象在集合中的索引位置来检索对象。 List特性 保持原来加入时候的顺序； List中可以有重复元素； List本身不带有排序的功能； Collections类是对Java集合类库中的辅助类，它提供操纵集合的各种静态方法 1234567891011121314151617181920212223//对List中对象进行自然排序Collections.sort(List list);//ch07.list.SortListpackage ch07.list;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class SortList &#123; public SortList() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub List list=new ArrayList (); list.add(12); list.add(34); list.add(11); Collections.sort(list); for(int i=0;i&lt;list.size();i++) &#123; System.out.println(list.get(i)); &#125; &#125;&#125; 通途 按顺序存放元素，比数组更方便。 Vector Vector类可以实现动态的对象数组。几乎与ArrayList相同； 由于Vector在各个方面都没有突出的性能，所以现在已经不提倡使用。 Map(映射) 定义 Map：集合中的每一个元素包含一对键对象和值对象，集合中没有重复的键对象，值对象可以重复； 向Map集合中加入元素时，必须提供一对键对象和值对象； Map的两个主要实现类： HashMap； TreeMap。 Map最基本的用法，就是提供类似字典的能力； 在Map中检索元素时，只要给出键对象，就会返回值对象。 Map的遍历 Method1 12345678910111213141516171819202122232425262728293031323334353637//通过Set.keySet()返回键的集合来遍历//ch07.map.MapIteratorpackage ch07.map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class MapIterator &#123; public static void main(String[] args) &#123; String str = &quot;China will strengthen international cooperation on novel coronavirus epidemic control and continue to provide assistance within its ability to countries affected by the epidemic, Xi Jinping, general secretary of the Communist Party of China Central Committee, said on Wednesday.&quot;; String freq = getFrequentWord(str); System.out.println(freq); &#125; public static String getFrequentWord(String content) &#123; Map map = new HashMap(); String[] words=content.split(&quot; &quot;); for(int i=0;i&lt;words.length;i++) &#123; String word = words[i]; int count = 0; if (map.containsKey(word)) &#123; count = (Integer) map.get(word); &#125; map.put(word, count + 1); &#125; Iterator it = map.keySet().iterator(); int maxCount = 0; String maxKey = &quot;&quot;; while (it.hasNext()) &#123; String key = (String) it.next(); if ((Integer) map.get(key) &gt; maxCount) &#123; maxKey = key; maxCount = (Integer) map.get(key); &#125; &#125; System.out.println(maxKey+&quot;=&quot;+maxCount); return maxKey; &#125;&#125; Method2 1234567891011121314151617181920212223242526272829303132333435363738394041//通过Set.entrySet()返回&quot;键值对&quot;的集合来遍历//Map.Entry的对象代表一个&quot;词条&quot;，就是一个键值对//可以从中取值getValue()或键getKey()//ch07.map.MapIterator2package ch07.map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;public class MapIterator2 &#123; public static void main(String[] args) &#123; String str = &quot;China will strengthen international cooperation on novel coronavirus epidemic control and continue to provide assistance within its ability to countries affected by the epidemic, Xi Jinping, general secretary of the Communist Party of China Central Committee, said on Wednesday.&quot;; String freq = getFrequentWord(str); System.out.println(freq); &#125; public static String getFrequentWord(String content) &#123; Map map = new HashMap(); String[] words=content.split(&quot; &quot;); for(int i=0;i&lt;words.length;i++) &#123; String word = words[i]; int count = 0; if (map.containsKey(word)) &#123; count = (Integer) map.get(word); &#125; map.put(word, count + 1); &#125; Iterator it = map.entrySet().iterator(); int maxCount = 0; String maxKey = &quot;&quot;; while (it.hasNext()) &#123; Entry entry=(Entry)it.next(); String key = (String) entry.getKey() ; if ((Integer) entry.getValue() &gt; maxCount) &#123; maxKey = key; maxCount = (Integer) map.get(key); &#125; &#125; System.out.println(maxKey+&quot;=&quot;+maxCount); return maxKey; &#125;&#125; Map两个最重要实现 HashMap按照哈希算法来存取键值对象； TreeMap按照排序规则对keySet进行排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//Map的遍历不保证顺序//但是TreeMap遍历使用Key排序//ch07.map.HashMapTreeMappackage ch07.map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;import java.util.TreeMap;/** * 本例子演示了TreeMap和HashMap区别 */public class HashMapTreeMap &#123; Comparable c; public static void main(String[] args) &#123; testMap(new HashMap()); System.out.println(&quot;=====================&quot;); testMap(new TreeMap()); &#125; public static void testMap(Map map) &#123; map.put(&quot;zhang&quot;, 10); map.put(&quot;li&quot;, 20); map.put(&quot;wan&quot;, 30); map.put(&quot;an&quot;, 40); Iterator it = map.keySet().iterator(); while (it.hasNext()) &#123; Object key = it.next(); Object value = map.get(key); System.out.println(key + &quot; &quot; + value); &#125; &#125;&#125;//Output/*wan 30zhang 10li 20an 40=====================an 40li 20wan 30zhang 10*/ Points JDK API文档可以从far fa-hand-point-right下载，安装后，打开index.html即可； 点击获取Java文档 Java最权威的教材 Iterator 12345678910//不考虑泛型的Iterator定义public interface Iterator&#123; boolean hasNext(); Object next(); void remove();&#125;public interface Collection extends Iterable;public interface Iterable&#123; Iterator iterator();&#125; Collection和Iterator接口 在Collection接口中声明了适用于Java集合(只包括Set和List)的通用方法。因此Set和List对象可以调用以上方法，Map对象不可以； Iterator接口隐藏了底层集合的数据结构，向客户程序提供了遍历各种数据集合的统一接口； 如果集合中的元素没有排序，Iterator遍历集合中元素的顺序也是无序的。 使用Iterator遍历Set/List 123456789101112131415161718192021222324252627282930313233343536//ch07.it.IteratorDemopackage ch07.it;/** * 本例子演示了Iterator的用法 */import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;public class IteratorDemo &#123; public IteratorDemo() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub List list=new ArrayList(); addObject(list); itColleciton(list); Set set=new HashSet(); addObject(set); //留意 itColleciton(set) 和 itColleciton(list) 区别 itColleciton(set); &#125; public static void addObject(Collection collection) &#123; collection.add(&quot;天津&quot;); collection.add(&quot;大学&quot;); &#125; public static void itColleciton(Collection collection) &#123; Iterator it=collection.iterator(); while(it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; 文章源码 文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"Java-Part4","slug":"Java/Java-Part4","date":"2021-03-27T12:03:10.000Z","updated":"2021-06-17T06:31:24.806Z","comments":false,"path":"2021/03/27/Java/Java-Part4/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/27/Java/Java-Part4/","excerpt":"","text":"异常 异常 常见的一些潜在风险 用户不存在？ 用户名口令错误？ 余额不足？ 网络不通？ 磁盘空间不足？ … 异常处理基本模式 Method1 在Java编程语言中，用try和catch语句来处理异常 格式如下 123456//ch06.ExceptionDemotry&#123; //可能发生异常的语句&#125;catch(Exception e)&#123; //发生异常了 执行这里的代码&#125; Method2 与方法1大致相同，增加finally语句 格式如下 12345678910//ch06.ExceptionDemo2try&#123; //可能发生异常的语句 //如果前面发生了异常 就不会执行这里&#125;catch(Exception e)&#123; //发生异常了 执行这里的代码 //如果没有发生异常 不会执行这里&#125;finally&#123; //不管是否发生异常都会执行这里&#125; 注意finally：不管如何(是否发生异常)，都会执行这里的代码。 异常的产生 所有的异常都是通过throw创建出来的 创建方法 12throw new 异常的构造函数()...//例如:throw new Exception(&quot;用户不存在!&quot;); 需要注意的是，不可以随便抛出一个东西 例如如下代码就是错误的 12throw new String(&quot;用户不存在!&quot;);//ch06.ExceptionDemo3 抛出的内容必须是Throwable的子类。 只要是Throwable的子类，都可以使用throw/catch进行操作； 反之，不是Throwable的子类，都不能使用throw/catch进行操作。 可抛出Throwable的几个类型 Error Exception RuntimeException 异常类型 Error及其子类 Error类表示Java运行时产生的系统内部错误或资源耗尽等严重错误； 这种错误通常是程序无法控制和解决的，如果发生这种错误，通常的做法是通知用户并中止程序的执行； 这种异常超出了程序员能力范围，没解决办法，建议程序直接退出。编译器检查、必须处理。 1//ch06.ErrorDemo 例：NoClassDefFoundError, OutOfMemoryError, VirtualMachineError, InternalError and so on. Exception及其子类 Exception又称为”可检异常“，”非运行时异常“； 程序能处理的异常； 这种错误的出现完全在程序员意料之中，有对应的解决办法。编译器检查、必须处理。 1//ch06.ExceptionDemo2 例：IOException, SQLException and so on. 此外，还有很多用户自定义的：口令错误、余额不足… RuntimeException及其子类 RuntimeException类及其子类被称为”运行时异常“ 一般发生在JRE内部； 也称”非必检异常“； 如NullPointerException。 RuntimeException类及其子类都成为运行时异常，这种异常的特点是Java编译器不会检查它。也就是说，当程序中可能出现这类异常，即使没有用try-catch语句，出现异常时也会抛出这个错误； RuntimeException表示无法让程序恢复运行的异常，导致这种异常的原因通常是由于执行力错误操作，建议直接显示错误，因此Java编译器不检查这种异常； 也有一种说法认为Exception之所以不检测，是因为不应该替别人背黑锅！ 1//ch06.RuntimeExceptionDemo Example ArithmaticException 12int a=12/0;//Wrong//Exception NullPointerException 123Date d=null;System.out.println(d.toString());//Wrong//RuntimeException ArrayIndexOutOfBoundException 1234int [] array=new int [4];array[0]=1;array[4]=1;//Wrong//RuntimeException ClassCastException 123456class Animal&#123;&#125;class Dog extends Animal&#123;&#125;class Cat extends Animal&#123;&#125;Animal animal=new Dog();Cat cat=(Cat)animal;//Wrong//RuntimeException 创建用户自定义异常类 步骤 1//ch06.UserDefineException 创建用户自定义异常时，一般需要完成如下工作 声明一个新的异常类，使之以Exception类或其他某个已经存在的系统异常类或用户异常类为父类； 为新的异常类定义属性和方法，或重载父类的属性和方法，使这些属性和方法能够体现该类所对应的错误的信息。 异常的处理 自己处理 12//ch06.ExceptionDemo4//自己处理 自己不处理 继续throw 12//ch06.ExceptionDemo5//等着别人处理 分门类得处理异常 定义多种异常类(Throwable子类)，不同情况下，抛出不同异常类 1//ch06.ExceptionDemo6 Questions 如果抛出了可以捕捉得东西，一定要在方法后面加throws吗？ 有时候需要 如果抛出的是Exception的子类，且非RuntimeException的子类，必须抛出或者捕捉； 有时候不需要 如果抛出的是RuntimeException的子类或者Error的子类，则不需要显式得抛出。 可不可以在不抛出内容的情况下catch？ 有时候不行 //ch06.ExceptionDemo9 &lt;!--code￼15--&gt; RuntimeException的子类或者Error的子类，可以在不抛出的情况下捕捉。 catch Exception能捕捉到所有抛出的“东西”吗？ 不能，要写捕捉所有抛出的“东西”，必须catch Throwable //ch06.ExceptionDemo101 &lt;!--code￼16--&gt; 异常的顺序问题 异常会首先被符合条件的catch捕捉 12345678910try&#123; throw new java.io.IOException(&quot;ie&quot;); //IOException是Exception的子类&#125;catch (IOException ie)&#123; //异常在这里被捕捉了 System.out.println(&quot;IOException&quot;);&#125;catch (Exception e)&#123; //这段就不会执行了 System.out.println(&quot;Exception&quot;);&#125; 如果将上程序中两个catch语句块交换，则会导致编译错误，为什么？ 12345678910try&#123; throw new java.io.IOException(&quot;ie&quot;);&#125;catch(Exception e)&#123; System.out.println(&quot;Exception&quot;);&#125;catch(IOException ie)&#123; //永远接收不到exception System.out.println(&quot;IOException&quot;);&#125; 上面这段代码就会出现编译报错，原因是下面的catch永远不会接收到异常，这是由于Exception是最大的异常类，所有的异常都属于Exception类，所以第一个catch就会优先接收到所有满足条件的异常，即使是IOException的异常，由于IOException也是Exception的一个子类，因此也会再第一个catch处被捕获，而第二个catch也就永远不会有作用了。因此我们必须是按照从小范围到大范围的顺序对catch语句进行排列。 返回问题，下面函数为什么会报错 1234567891011121314//ch06.ExceptionDemo20.java//buypublic int buy(String username, int amount) throws Exception &#123; try &#123; int orgBalance = this.getBalance(username); if (orgBalance &lt; amount) &#123; throw new BalanceException(&quot;余额不足！&quot;); &#125; return orgBalance - amount; &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); // 这里没有返回值，也就意味着如果发生异常，函数就没用返回，所以会报错。 &#125;&#125; 初始化问题，下面函数为什么报错 1234567891011121314//ch06.ExceptionDemo20.java//buy2public void buy2(String username, int amount) throws Exception &#123; int orgBalance; try &#123; orgBalance = this.getBalance(username); if (orgBalance &lt; amount) &#123; throw new BalanceException(&quot;余额不足！&quot;); &#125; &#125; catch (Exception e) &#123; System.out.println(&quot;余额不足:&quot; + orgBalance); // 系统编译的时候认为try里面代码完全有可能一行都不被执行，所以必须要在try前面给变量赋值 &#125;&#125; 初始化问题，下面函数为什么报错 12345678910111213141516171819//ch06.ExceptionDemo20.java//readFromFilepublic void readFromFile(String fileName) &#123; InputStream in; // 正确的写法是InputStream in=null; try &#123; in = new FileInputStream(fileName); // ....以后还有代码，此处省略 &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; if (in != null) &#123; // in没有初始化 in.close(); // in close的时候可能再次发生异常 &#125; &#125;&#125; Exception引发的override问题 1//ch06.ExceptionSon 一个方法必须通过throws语句在方法的声明部分说明它可能抛出而并未捕获的所有的“必检异常”，如果没有这么做，将不能通过编译； 如果在子类中覆盖了父类的某一方法，那么该子类方法不可以比被其覆盖的父类方法抛出更多的异常(但可以更少)。 异常到底应该捕捉还是抛出？ 捕获并处理那些你知道并且应该负责处理的异常； 对那些你不知道方法的调用者会如何处理的的异常，最好将它们留给方法的调用者进行处理。 异常的优点与用途 优点 极大的降低了程序调试难度，使得错误定位准确； 强制让用户在编译阶段发现一些未解决的问题，提高程序健壮性。 用途 异常的最大用途——查看错误堆栈 1234567891011//ch06.ExceptionDemo31public static void main(String[] args) &#123; try &#123; new ExceptionDemo31(); &#125;catch(Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125;&#125;//编译结果java.lang.ArrayIndexOutOfBoundsException:10 at ch06.ExceptionDemo31.main(Exception31.java:14) Points try中代码是有可能一行都不执行的； 处理异常的过程中，可能再次发生异常； Exception包含在java.lang包中，所以使用Exception不需要import； 可以在不存在潜在风险的情况下throws； 不可以在不存在潜在风险的情况下catch； override的时候要考虑Exception； return的时候要考虑Exception； 异常的常见处理方法 123456789//ch06.ExceptionDemo31public static void main(String[] args) &#123; try &#123; new ExceptionDemo31(); &#125;catch(Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125;&#125; throw与throws用处的区别 12345678910111213141516//ch06.ThrowsDemopublic class ThrowsDemo &#123; public ThrowsDemo() &#123; // TODO Auto-generated constructor stub &#125; public void method() throws SQLException, IOException &#123; if(1&gt;2) &#123; throw new IOException(&quot;IOException&quot;); &#125; if(2&gt;3) &#123; throw new SQLException(&quot;SQLException&quot;); &#125; &#125;&#125; throws：跟在方法声明后面，后面跟着的是异常类名； throw：用在方法体内，后面跟着的是异常类对象名。 处理异常的过程中，可能再次发生异常 1234567891011121314151617181920212223242526//ch06.ExceptionInExceptionpackage ch06;import java.io.FileInputStream;import java.io.IOException;/** * 这个例子演示了 异常处理中 仍然可能发生异常 */public class ExceptionInException &#123; public ExceptionInException() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; FileInputStream in=null; try &#123; in=new FileInputStream(&quot;D:/temp.txt&quot;); //..其他操作 &#125;catch (IOException e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); if(in!=null) &#123; //这行导致的异常处理中的异常 in.close(); &#125; &#125; &#125;&#125; 文章源码 文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"解决Github官网打不开的问题","slug":"STFIOG","date":"2021-03-22T02:59:11.000Z","updated":"2021-03-26T14:07:57.361Z","comments":false,"path":"2021/03/22/STFIOG/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/22/STFIOG/","excerpt":"","text":"Method 1","categories":[{"name":"Solution","slug":"Solution","permalink":"https://cheeseburgerim.github.io/categories/Solution/"}],"tags":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"Git","slug":"Git","permalink":"https://cheeseburgerim.github.io/tags/Git/"},{"name":"Solution","slug":"Solution","permalink":"https://cheeseburgerim.github.io/tags/Solution/"},{"name":"Github","slug":"Github","permalink":"https://cheeseburgerim.github.io/tags/Github/"}]},{"title":"数字逻辑与数字系统-Part3","slug":"MLAMS/MLAMS-Part3","date":"2021-03-19T12:35:02.000Z","updated":"2021-06-22T03:16:46.236Z","comments":false,"path":"2021/03/19/MLAMS/MLAMS-Part3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/19/MLAMS/MLAMS-Part3/","excerpt":"","text":"Chapter3 SystemVerilog硬件描述语言基础 硬件描述语言(HDL)的起源 Question 数字逻辑电路(组合逻辑)设计的方法有哪些？ 这些方法存在什么问题？ 现代数字电路设计方法是什么？ 什么是硬件描述语言？ 具有特殊结构能够对硬件逻辑电路的功能和时序进行描述的一种高级编程语言，称之为硬件描述语言(Hardware Description Language, HDL) 综合与仿真 逻辑综合 仿真验证 SystemVerilog HDL程序的基本结构 SystemVerilog HDL的语法要素 基于SystemVerilog的数字逻辑电路建模方法 基于SystemVerilog的测试程序 常见组合逻辑电路模块的设计 逻辑阵列","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"Java-Part3","slug":"Java/Java-Part3","date":"2021-03-15T03:31:53.000Z","updated":"2021-06-17T06:31:16.745Z","comments":false,"path":"2021/03/15/Java/Java-Part3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/15/Java/Java-Part3/","excerpt":"","text":"深入理解JAVA语言 变量及其传递 Java数据类型划分 Java中的数据类型分为两大类，一类是基本数据类型； 另一类是引用类型，后者相当于对象。 Java数据类型划分在Java-Part1中有详细介绍 注意：只有类、接口和数组是引用数据类型！ String不是引用数据类型，StringBuffer是引用数据类型！ 从JDK1.4以后，引用、对象类型和原始类型基本通用。 类型 引用、对象类型 原始数据类型 整数 Integer int 单精度 Float float 双精度 Double double 布尔 Boolean boolean 字符 Character char 字节 Byte byte 1234567891011121314151617181920212223242526//ch05.ref_val.ObjectAndPrimitivepackage ch05.ref_val;public class ObjectAndPrimitive &#123; public ObjectAndPrimitive() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Integer i1 = new Integer(0); int i2 = i1; String s=&quot;abc&quot;; Object o=s; ((String)o).length(); test(i1); // Integer可以用的地方，int也可以 test(678); // 但是Integer的方法，int是不能直接用的 i1.hashCode(); // 下面这个是不可以的 ((Integer) i2).hashCode(); Boolean b1 = Boolean.FALSE; boolean b2 = b1; &#125; public static void test(Integer i) &#123; &#125;&#125; 基本类型变量与引用型变量 基本类型：其值直接存于变量中； 引用型的变量除占据一定的内存空间外，它所引用的对象实体(由new创建)也要占据一定空间； 引用型变量保存的实际上是对象在内存的地址，也称为对象的句柄； ch05.ref_val.MyDate体会m/n什么时候一起改变，什么时候不一起改变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//ch05.ref_val.MyDatepackage ch05.ref_val;/** * 本例子演示了两个对象指向的是同一个地址，而不是简单的值的复制 */public class MyDate &#123; private int day = 12; private int month = 6; private int year = 1900; public MyDate(int y, int m, int d) &#123; year = y; month = m; day = d; &#125; void addYear() &#123; year++; &#125; @Override public Object clone() &#123; // TODO Auto-generated method stub return new MyDate(this.year, this.month, this.day); &#125; public void display() &#123; System.out.println(year + &quot;-&quot; + month + &quot;-&quot; + day); &#125; public static void main(String[] args) &#123; // MyDate m, n; // m = new MyDate(2020, 3, 2);// m指向了一个对象 // // n = (MyDate)m.clone();// n和m指向了同一个对象 // n=m; // n.addYear();// m n同时改变 // m.display(); // n.display();// m n都变成了2021 // n = new MyDate(2019, 3, 2);// n指向了一个新对象 // m.display(); // n.display();// m n 具有不同的值 MyDate m = new MyDate(2020, 3, 6); modifyDate(m); m.display(); &#125; public static void modifyDate(MyDate m) &#123; m=new MyDate(2020, 3, 6); m.addYear(); &#125;&#125; 调用对象方法时，要传递参数。在传递参数时，Java是值传递，即在调用一个方法时，是将表达式的值复制给形式参数； 对于引用型变量，传递的值是引用值(可以理解为内存地址)； 1234567891011121314151617181920212223242526272829303132//ch05.ref_val.TransByValue.javapackage ch05.ref_val;/** * 本例子演示了什么样的情况下传递的是地址，什么情况下是值的复制 */public class TransByValue &#123; private static int a; public static void main(String[] args) &#123; int a = 0; modify( a); // System.out.println(a);// 输出0 int[] b = new int[1]; modify(b); System.out.println(b[0]); &#125; /** * 值的复制 */ public static void modify(int a) &#123; // 原始类型 传递值 // a++; a = a + 1; &#125; /** * 传递的是地址 */ public static void modify(int[] c) &#123; // 对象类型 传递地址 c[0]++; c = new int[5]; &#125; &#125; Java中的参数都是按值传递的，但对于引用型变量，传递的值是引用值，所以方法中对数据的操作可以改变对象的属性； 但是不能简单地认为函数如果传递的参数是一个对象，就可以在函数内部修改这个参数，例如：ch05.ref_val.TestValue 1234567891011121314151617181920212223242526272829303132333435363738394041//ch05.ref_val.TestValuepackage ch05.ref_val;/** * 函数中如果传递的是对象，未必一定可以在函数内部修改这个参数 * @author Administrator * */public class TestValue &#123; public TestValue() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; String str=&quot;a&quot;; modify(str); System.out.println(str); StringBuffer buf=new StringBuffer(&quot;a&quot;); modify(buf); System.out.println(buf.toString()); &#125; /** * s能被修改么？ * @param s */ public static void modify(String s) &#123; s=s+&quot;1&quot;; &#125; /** * buf能被修改么 * @param buf */ public static void modify(StringBuffer buf) &#123; buf.append(&quot;1&quot;); &#125;&#125; 实例变量与局部变量 从语法角度看 实例变量属于类或接口，public,private,static,final修饰； 而局部变量是在方法中定义的变量或方法的参变量； 都可用final修饰，但局部变量则不能够被访问控制符及static修饰。 从存储角度看 从变量在内存中的存储方式来看，实例变量是对象的一部分，而对象是存在于堆中的，局部变量是存在于栈中； 实例变量的生命周期与局部变量的声明周期不同，通常前者较长； 另外，实例变量可以自动赋初值，局部变量则须显式赋值。局部变量必须显式赋值后才能够使用。 1234567891011//ch05.LocalVarAndMemberVarpackage ch05;public class LocalVarAndMemberVar &#123; int a; void m()&#123; int b; System.out.println(a); // a的值为0 System.out.println(b); //编译不能通过 &#125;&#125; 变量的返回 方法的返回： 返回基本类型； 返回引用类型，他就可以存取对象实体。 123456Object getNewObject()&#123; Object obj=new Object(); return obj;&#125;//调用时: Object p=getNewObject(); 多态 子类对象可以当作父类对象，对于重载的方法，Java运行时根据实际的类型调用正确的方法，就叫&quot;多态型性&quot;； 所有的非final/static/private方法都可以实现多态； 多态能够使对象所编写的程序，不用做修改就可以适应于其所有的子类。如在调用方法时，程序会正确地调用子对象的方法。 12345678910111213141516171819202122232425262728293031323334//ch05.intergate.IntegrationDemopackage ch05.intergate;/** * 本例子演示了接口的作用 */public class IntegrationDemo &#123; public IntegrationDemo() &#123; // TODO Auto-generated constructor stub &#125; /** * 计算积分的一个函数 * @param fun * @param a * @param b * @param step * @return */ public double integrateAB(Integrable fun,double a,double b,double step) &#123; double sum=0; while(a&lt;b) &#123; sum=sum+step*fun.getValue(a); a=a+step; &#125; return sum; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub IntegrationDemo demo=new IntegrationDemo(); Integrable myFun=new MyFunction(); //Integrable myFun=new MyFun2(); double sum=demo.integrateAB(myFun,0,1,0.0005); System.out.println(sum); &#125;&#125; 多态的特点大大提高了程序的抽象程度和简洁性，最大限度地降低了类和程序模块之间的耦合性，提高了类模块的封闭性，使得它们不需了解对方的具体细节，就可以很好地共同工作。这个有点对于程序的设计、开发和维护都有很大的好处。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//多态的例子//ch05.virtual.testVirtualInvoke.java//important!package ch05.virtual;class Shape &#123; void draw() &#123; System.out.println(&quot;Shape Drawing&quot;); &#125; static void stDraw() &#123; System.out.println(&quot;static Shape Drawing&quot;); &#125;&#125;class Circle extends Shape &#123; void draw() &#123; System.out.println(&quot;Draw Circle&quot;); &#125; static void stDraw() &#123; System.out.println(&quot;static Shape Drawing&quot;); &#125; &#125;class Triangle extends Shape &#123; void draw() &#123; System.out.println(&quot;Draw Triangle&quot;); &#125; static void stDraw() &#123; System.out.println(&quot;static Draw Triangle&quot;); &#125;&#125;class Line extends Shape &#123; void draw() &#123; System.out.println(&quot;Draw Line&quot;); &#125; static void stDraw() &#123; System.out.println(&quot;static Draw Line&quot;); &#125;&#125;public class TestVirtualInvoke &#123; static void doStuff(Shape s) &#123; s.draw(); &#125; public static void main(String[] args) &#123; Circle c = new Circle(); Triangle t = new Triangle(); Line l = new Line(); c.draw(); t.draw(); l.draw(); Shape c2=new Circle(); c2.draw(); c2.stDraw(); System.out.println(&quot; c2 instancof Shape=&quot;+(c2 instanceof Shape)); c2=new Triangle(); c2.draw(); c2.stDraw(); System.out.println(&quot; c2 instancof Triangle=&quot;+(c2 instanceof Triangle)); c2=new Line(); c2.draw(); c2.stDraw(); System.out.println(&quot; c2 instancof Line=&quot;+(c2 instanceof Line)); &#125;&#125; Class类 getClass() 对象可以通过getClass()方法来获得运行时的信息； getClass()是java.lang.Object的方法，而Object是所有类的父类。所以任何对象都可以用getClass()方法； getClass()方法得到对象的运行时的类信息，即一个Class类的对象，它的getFeilds()及getMethods()方法能进一步获得其详细信息。 12345678910111213141516171819202122//ch05.RunTimeClassInfo.javapackage ch05;import java.lang.reflect.*;class RunTimeClassInfo &#123; public static void main(String[] args) &#123; Object obj = new Integer(1); Class cls = obj.getClass(); System.out.println( &quot;类名:&quot; + cls.getName() ); Field [] fields = cls.getFields(); for( int i=0; i&lt;fields.length; i++ )&#123; Field f = fields[i]; System.out.println( &quot;域:&quot; + f.getName() + &quot;:&quot; + f ); &#125; Method [] methods = cls.getMethods(); for( int i=0; i&lt;methods.length; i++ )&#123; Method m = methods[i]; System.out.println( &quot;方法：&quot; + m.getName() + &quot;:&quot; + m ); &#125; &#125;&#125; instanceof instanceof一个对象是否是某个类/接口(或子类，或实现了这个接口) 用法：对象名 instanceof 类名 对象构造与初始化 对象的构造与初始化 调用本类或父类的构造方法； this调用本类的其他构造方法； super调用直接父类的构造方法； 如果没有this及super，则编译器自动加上super()，即调用直接父类不带参数的构造方法； this或super要放在第一条语句，且只能够有一条。 12345678910111213141516171819202122232425262728293031323334353637//ch05.seq.ConstructCallThisAndSuperpackage ch05.seq;class ConstructCallThisAndSuper &#123; public static void main(String[] args)&#123; PersonThisAndSuper p = new Graduate(); &#125;&#125;class PersonThisAndSuper&#123; String name; int age; PersonThisAndSuper()&#123;&#125; PersonThisAndSuper( String name, int age )&#123; this.name=name; this.age=age; System.out.println(&quot;In Person(String,int)&quot;); &#125;&#125;class StudentThisAndSuper extends PersonThisAndSuper&#123; String school; StudentThisAndSuper()&#123; this( null, 0, null ); System.out.println(&quot;In Student()&quot;); &#125; StudentThisAndSuper( String name, int age, String school )&#123; super( name, age ); this.school = school; System.out.println(&quot;In Student(String,int,String)&quot;); &#125;&#125;class Graduate extends StudentThisAndSuper&#123; Graduate()&#123; System.out.println(&quot;In Graduate()&quot;); &#125;&#125; 在构造函数中使用this和super； 在构造方法中调用this及super或自动加入的super，最终保证了任何一个构造方法都要调用父类的构造方法，而父类的构造方法又会再调用其父类的构造方法，直到最顶层的Object类。这是符合面向对象的概念的，因为必须令所有父类的构造方法都得到调用，否则整个对象的构建就可能不正确。 构造方法的执行过程 对于一个复杂的对象，构造方法的执行过程遵照以下步骤 调用本类或父类的构造方法，直至最深一层派生类； 按照声明顺序执行域的初始化赋值； 执行构造函数中的各语句； 构建器的调用顺序非常重要。先父类构造，再本类成员赋值，最后执行构造方法中的语句。 1234567891011121314151617181920212223242526272829303132333435//ch05.seq.ConstructSequence.javapackage ch05.seq;class ConstructSequence &#123; public static void main(String[] args) &#123; Student p = new Student(&quot;李明&quot;, 18, &quot;北大&quot;); &#125;&#125;class Person &#123; static &#123; System.out.println(&quot;Person initializing!&quot;); &#125; String name = &quot;未命名&quot;; int age = -1; Person(String name, int age) &#123; System.out.println(&quot;开始构造Person(),此时this.name=&quot; + this.name + &quot;,this.age=&quot; + this.age); this.name = name; this.age = age; System.out.println(&quot;Person()构造完成,此时this.name=&quot; + this.name + &quot;,this.age=&quot; + this.age); &#125;&#125;class Student extends Person &#123; static &#123; System.out.println(&quot;Student initializing!&quot;); &#125; String school = &quot;未定学校&quot;; Student(String name, int age, String school) &#123; super(name, age); System.out.println( &quot;开始构造Student(),此时this.name=&quot; + this.name + &quot;,this.age=&quot; + this.age + &quot;,this.school=&quot; + this.school); this.school = school; System.out.println( &quot;Student()构造完成,此时this.name=&quot; + this.name + &quot;,this.age=&quot; + this.age + &quot;,this.school=&quot; + this.school); &#125;&#125; 构造方法内部调用的方法的多态性 在构造子类的一个对象时，子类构造方法会调用父类的构造方法，而如果父类的构造方法中调用到对象的其他方法，如果所调用的方法又被子类所覆盖的话，它可能实际上调用的是子类的方法，这是由动态绑定(虚方法调用)所决定的。从语法上来说这是合理的，但有时会造成事实上的不合理，所以在构造方法中调用其他方法时要小心。 12345678910111213141516171819202122232425262728293031//ch05.metamorph.ContructInvoke.javapackage ch05.metamorph;class ConstructInvoke &#123; public static void main(String[] args)&#123; Person p = new Student(&quot;李明&quot;, 18, &quot;北大&quot;); &#125;&#125;class Person&#123; String name=&quot;未命名&quot;; int age=-1; Person( String name, int age )&#123; this.name=name; this.age=age; sayHello(); &#125; void sayHello()&#123; System.out.println( &quot;我是一个人，我名叫：&quot; + name + &quot;,年龄为：&quot;+ age ); &#125;&#125;class Student extends Person&#123; String school=&quot;未定学校&quot;; Student( String name, int age, String school )&#123; super( name, age ); this.school = school; &#125; void sayHello()&#123; System.out.println( &quot;我是学生，我名叫：&quot; + name + &quot;,年龄为：&quot;+ age + &quot;,学校在：&quot; + school ); &#125;&#125; 对象清除与垃圾回收 new创建对象； 自动清除，清楚过程成为垃圾回收； 对象回收是由Java虚拟机的垃圾回收线程来完成的； 系统中的任何对象都有一个引用计数器，当其值为0时，说明该对象可以回收； 垃圾回收：System.gc()方法。它可以要求系统进行垃圾回收。但是它仅仅只有建议权。 finalize()方法 Object具有finalize()方法，类C++中析构函数； 可以通过覆盖Object的finalize()方法来实现关闭打开的文件、清除一些非内存资源等工作需要在对象懂得回收时进行。因为系统在回收时会自动调用对象的finalize()方法； 一般来说，子类的finalize()方法中应该调用父类的finalize()方法，以保证父类的清理工作能够正常运行； 但是程序绝对不能完全依赖finalize()释放资源，因为finalize()是不可控的； 为了准确释放资源，应该用try finally或者AutoCloseable接口。 1234567891011121314151617181920212223//ch05.clean.TestFinalizepackage ch05.clean;/** * 本例子演示了finalize的调用 */public class TestFinalize &#123; public TestFinalize() &#123; // TODO Auto-generated constructor stub &#125; @Override protected void finalize() throws Throwable &#123; // TODO Auto-generated method stub System.out.println(&quot; this finalize&quot;); //finalize应该放在最后，这个和构造函数调用super正好相反 super.finalize(); &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub TestFinalize t = new TestFinalize(); t = null; System.gc(); &#125;&#125; 内部类与匿名类 定义 内部类是在其他类中的类； 匿名类是一种特殊的内部类，它没有类名，在定义类的同时就生成该对象的一个实例 内部类的定义和使用 将类的定义置入一个用于封装它的类内部即可； 内部类不能够与外部类同名； 在封装它的类的内部使用内部类，与普通类的使用方式相同； 在其他地方使用，类名前要冠以外部类的名字； 在用new创建内部类时，也要在new前面冠以对象变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//ch05.inner.TestInnerUse.javapackage ch05.inner;/** * 本例子演示了内部类的使用 */class TestInnerUse &#123; public static void main(String[] args) &#123; Parcel p = new Parcel(); p.testShip(); Parcel.Contents c = p.new Contents(33); Parcel.Destination d = p.new Destination(&quot;Hawii&quot;); p.setValue(c, d); p.ship(); &#125;&#125;class Parcel &#123; private Contents c; private Destination d; class Contents &#123; private int i; Contents(int i) &#123; this.i = i; &#125; int value() &#123; return i; &#125; &#125; class Destination &#123; private String label; Destination(String whereTo) &#123; label = whereTo; &#125; String readLabel() &#123; return label; &#125; &#125; void setValue(Contents c, Destination d) &#123; this.c = c; this.d = d; &#125; void ship() &#123; System.out.println(&quot;运输&quot; + c.value() + &quot;到&quot; + d.readLabel()); &#125; public void testShip() &#123; c = new Contents(22); d = new Destination(&quot;Tanzania&quot;); ship(); &#125;&#125; 在内部类中使用外部类的成员 内部类中可以直接访问外部类的其他域及方法。即使private也可以； 如内部类中有与外部类同名的域或方法，可以用this来访问外部成员。 12345678910111213141516171819202122//ch05.inner.TestInnerThis.javapackage ch05.inner; class TestInnerThis&#123; public static void main(String args[])&#123; D a = new D(); D.B b = a.new B(); b.mb(333); &#125;&#125;class D&#123; private int s = 111; public class B &#123; private int s = 222; public void mb(int s) &#123; System.out.println(s); // 局部变量s System.out.println(this.s); // 内部类对象的属性s System.out.println(D.this.s); // 外层类对象属性s &#125; &#125;&#125; 内部类的修饰符 内部类与类中的域、方法一样是外部类的成员，他的前面也可以有访问控制符和其他修饰符； 内部类可用的修饰符比外部类的修饰符更多 外部类不能够使用protected,private,static等修饰，而内部类可以； 访问控制符：public, protected, default, private, final, abstract； 用static修饰表明该内部类实际是一种外部类。 static内部类 static环境在使用时要遵循以下规则 实例化static内部类时，在new前面不需要用对象变量； static内部类中不能访问其外部类的非static的域及方法，即只能访问static成员； static方法中不能访问非static的域及方法，也不能够不带前缀地new一个非static的内部类。 123456789101112131415161718192021222324252627282930//ch05.inner.TestInnerStaticpackage ch05.inner;class TestInnerStatic &#123; public static void main(String[] args) &#123; A.B a_b = new A().new B(); // ok A a = new A(); A.B ab = a.new B(); OuterStatic.Inner oi = new OuterStatic.Inner(); // Outer.Inner oi2 = Outer.new Inner(); //!!!error // Outer.Inner oi3 = new Outer().new Inner(); //!!! error &#125;&#125;class A &#123; private int x; void m() &#123; new B(); &#125; static void sm() &#123; // new B(); // error!!!! &#125; class B &#123; B() &#123; x = 5; &#125; &#125;&#125;class OuterStatic &#123; static class Inner &#123; &#125;&#125; 方法中的内部类 在一个方法中也可以定义类。这种类称为方法中的内部类 123456789101112131415161718192021222324252627//ch05.inner.TestInnerMethodpackage ch05.inner;class TestInnerInMethod &#123; public static void main(String[] args) &#123; Object obj = new Outer().makeTheInner(47); System.out.println(&quot;Hello World!&quot; + obj.getClass().toString() ); &#125;&#125;class OuterMethod&#123; private int size = 5; public Object makeTheInner( int localVar ) &#123; final int finalLocalVar = 99; class Inner &#123; public String toString() &#123; return ( &quot; InnerSize: &quot; + size + // &quot; localVar: &quot; + localVar + // Error! &quot; finalLocalVar: &quot; + finalLocalVar ); &#125; &#125; return new Inner(); &#125;&#125; 同局部变量一样，方法中的内部类前不能够用public, private, protected, static修饰，但可以被final或者abstract修饰； 方法中的内部类可以访问其外部类的成员。若是static中的内部类可以访问外部类的static成员； 方法中的内部类中，不能够访问该方法的局部变量，除非是final局部变量； 方法中定义的类，在其他地方使用时，没有类的情况，正像例中一样，只能够用其父类来引用这样的变量。 匿名类 匿名类有以下几个特点： 不取名字，直接用其父类的名字； 类的定义域创建该类的一个实例同时进行，即类的定义前面有一个new。不使用关键词class。new类名或接口名(){…}； 类名前面不能够有修饰符； 类中不能够定义构造方法，因为它没有名字。在构造对象时不能够带参数。 文章源码 文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"数字逻辑与数字系统-Part2","slug":"MLAMS/MLAMS-Part2","date":"2021-03-13T12:43:15.000Z","updated":"2021-06-17T06:33:00.261Z","comments":false,"path":"2021/03/13/MLAMS/MLAMS-Part2/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/13/MLAMS/MLAMS-Part2/","excerpt":"","text":"Chapter2 组合逻辑设计 Introduction 数字逻辑电路 数字逻辑电路(logic circuit)是一个可以处理离散值变量的网络； 其中包括： 一个或多个离散值输入端； 一个或多个离散值输出端； 描述输入和输出关系的功能规范； 描述当输入改变时输出响应延迟的时序规范。 结点(node)和模块(element) 电路由节点和模块组成； 结点是一段导线，通过电压传递离散值变量； 输入结点：接收外部的值(图中的A,B,C)； 输出结点：输出值到外部(图中的Y,Z)； 内部结点：不属于以上两者的结点(图中的n1)。 模块本身是一个带有输入、输出、功能规范和时序规范的电路； 每一个模块本身都是一个电路； 图中的E1,E2,E3。 数字逻辑电路的分类 组合逻辑电路(combinational logic) 任一时刻的输出仅由该时刻的输入信号决定； 无记忆的，与电路状态无关。 时序逻辑电路(sequential logic) 任一时刻的输出由该时刻的输入和电路该时刻的状态共同决定； 有记忆的，与电路状态有关。 组合逻辑电路 每个电路模块都是一个组合逻辑电路； 每个电路结点： 或者是电路的输入； 或者是只连接电路模块的一个输出端。 电路中不包含回路。 判断下列哪写电路是组合逻辑电路 √； ×，有回路； √； ×，连接了两个模块的输出端； √； ×，有回路。 布尔代数 基本概念 布尔代数的定义 布尔代数中的变量取值只能为**“真”(True)或“假”(False)**； “1”表示真，“0”表示假； 三种基本逻辑运算： “与”，运算符“·”，例：A·B或AB； “或”，运算符“+”，例：A+B； “非”，运算符“上划线”，例：A。 基本概念 变量：可以使用A、B、C…或a、b、c…来表示，取值只能为0或1； 反变量(变量的非，Complement)：变量上面有一条横线 A，B，C； 项(Literal)：变量或它的反变量 A，A，B，B，C，C； 布尔表达式 适用于描述组合逻辑电路中输入与输出间的功能规范； 例如： S=F(A,B,Cin)； Cout=F(A,B,Cin)。 公理和定理 布尔代数的公理 对偶规则 对偶(Duality) 设F为任意逻辑表达式，若将F中所有运算符和常量做如下变换 例如：F=AB+CD→F‘=(A+B)(C+D) 则所得新的表达式F’为F的对偶式。 对偶是相互的，F和F’互为对偶式； 对偶规则：两个逻辑表达式F和G相等，则对偶式F’和G’也相等。 单变量定理 多变量定理 德·摩根定律 最小项和最大项 基本概念 蕴含项(Implicant)：项的乘积 ABC，AC，BC； 最小项(Miniterm)：包含全部输入变量的乘积项 ABC，ABC，ABC； 最大项(Maxterm)：包含全部输入变量的求和项(Sum) (A+B+C)，(A+B+C)，(A+B+C)。 最小项 最小项是一种特殊的乘积项(&quot;与&quot;项)； 最小项特点： n个变量逻辑函数的每个最小项，一定是包含n个因子的乘积项； 在各个最小项中，每个变量必须以原来变量或反变量形式作为因子出现一次，而且仅出现一次； 最小项的编号 最小项用mi表示 m表示最小项； 下标i为使该最小项为1的变量取值所对应的等效十进制数。 三变量最小项编号表 三变量最小项真值表 从表中可以看出，每个最小项只有一组变量取值能使其值为1，而其他各组取值该最小项皆为0。由这种“与”函数真值表中1的个数最少，而得名“最小项”。 最小项的性质 变量任取一组值，仅有一个最小项为1，其他最小项为0； n变量的全体最小项(共有2n个)之和恒为1； n个变量任意两个不同的最小项相与，结果恒为0； 两最小项相邻，相邻最小项相&quot;或&quot;，可以合并成一项，并可以消去一个变量因子 相邻：两最小项如果仅有一个变量因子不同，其他变量均相同，则称这两个最小项相邻 例：ABC+ABC=AB； 任一n变量的最小项，必定和其他n个不同最小项相邻(每一变量取反都是相邻项) 例：ABC与ABC、ABC、ABC相邻。 最大项 最大项是一种特殊的和项(&quot;或&quot;项)； 最大项特点 n个变量构成的每个最大项，一定是包含n个因子的&quot;或&quot;项； 在各个最大项中，每个变量必须以原变量或反变量形式作为因子出现一次，而且仅出现一次。 最大项编号 最大项用Mi表示 M表示最大项； 下标i为使该最大项为0的变量取值所对应的等效十进制数。 三变量最大项编号表 三变量最大项真值表 每个最大项只有对应的一组变量取值能使其值为0，正因为这种“或”函数真值表中1的个数最多，所以取名“最大项”。 最大项的性质 变量任取一组值，仅有一个最大项为0，其他最大项为1； n变量的全体最大项之积为0； 不同的最大项相或，结果为1； 两相邻的最大项相“与”，可以合并成一项(等于相同因子之和)，并可消去一个变量因子 相邻：两最大项如果仅有一个变量因子不同，其他变量均相同，则称这两个最大项相邻； 任一n变量的最大项，必定和其他n个不同的最大项相邻。 最小项和最大项的关系 编号下标相同的最小项和最大项互为反函数 标准与或式和标准或与式 标准或与式(sum-of-products) 由最小项之和构成的逻辑表达式； 每个最小项都对应真值表中值为1的一行； 标准与或式是最小项之间的或运算； 标准与或式与真值表间一一对应； 因此，从标准与或式中可以直接判断哪些变量取值可以使表达式为1。 标准与或式具有唯一性 任一逻辑函数都可以表达为最小项之和的形式，而且是唯一的 标准或与式(product-of-sums) 最大项之积构成的逻辑表达式； 任一逻辑函数都可以表达为最大项之积的形式、而且是唯一的。 标准与或式和标准或与式的关系 布尔表达式与真值表的转换 布尔表达式→真值表 三种方法 将变量的组合所有取值组合一一带入表达式进行计算得到； 将表达式转化为标准与或式 根据函数式的逻辑含义直接填表 方法三所得到的真值表 通过上述方法所得到的真值表 真值表→布尔表达式 根据最小项的性质，直接从真值表写出标准与或式 根据最大项的性质，直接写出标准或与式 例子 使用定理化简表达式 例1 例2 从逻辑到门 由布尔表达式绘制原理图 与或式可以使用两级门电路来实现 第一级：与门； 第二级：或门。 例 电路原理图绘制原则 原理图需要遵循一致的风格，以易于阅读和检查错误； 绘制原则如下： 输入在原理图的左边(或顶部)； 输出在原理图的右边(或底部)； 门电路流应从左至右(或从上至下)； 尽量使用直线连接； T型接头表示两条线有连接； 两条线交叉的地方有一个点，表示有连接； 两条线交叉的地方没有点，表示没有连接。 实例 多输出电路 构造一个“优先级电路” 在所有输入为真的信号中，选择其中最重要的信号所对应的输出为1； 其余输出为0。 实例 优先级电路的实现 以上多输出电路实例为例 多级组合逻辑 减少硬件 减少硬件的目的 扇入(fan-in)：单个逻辑门能够接受的数字信号的最大输入数。 所有的逻辑表达式都可以转化为与或式； 理论上，与或式可以使用两级门电路来实现(先与后或)； 使用二级逻辑可能带来更高的成本； 在工程上，门电路的扇入数不可能无限制的增加 受工艺、成本等方面的制约。 采用多级逻辑 可以减少门电路的数量； 可以减少扇入数。 3输入异或门的实现 使用更少的门电路 推气泡 推气泡 CMOS电路中经尝使用与非门和或非门； 不易直接根据电路推导出表达式； 推气泡可以帮助我们重画电路，更容易确定逻辑功能； 向后推 电路符号变化； 将气泡加在输入端； 向前推 电路符号变化； 将气泡加在输出端； 写出电路的逻辑表达式 Y=AB+CD 推气泡的方法 从输出端向输入端推； 将气泡从电路最后的输出端开始推； 如果当前门有一个输入气泡、则消除该气泡，并在其上一级门的输出加上气泡。 推气泡的例子 X和Z 非法值(illegal)：X 竞争(Contention)：电路结点同时被0和1驱动 电压值可能介于0~VDD之间； 可能是0，可能是1，也可能处于禁止区域内； 导致电路的功耗变大，电路发热，并导致损坏。 注意：竞争通常是由于电路设计缺陷引起的。 无关项(Don’t Care)：X 在优先级电路中： 如果A3输入为TRUE，则输出不用考虑其他的输入量。 用符号X表示不需要考虑的输入。 浮空值(floating)：Z 浮空也称为悬空、高阻态(High impedance)、高Z态、开路、断路； 浮空不等于逻辑0 使用电压并不能判断哪个电路结点处于浮空状态； 测量断路节点的电压和接地点的电压，在电压表上读数都为0。 当电路的输入结点浮空时，输出不确定 可能为0，可能为1，也可能为某个中间电压(处于禁止区)。 产生浮空结点常见的原因是忘记将电压连接到输入端； 但浮空结点并不意味着电路一定出错。 三态缓冲器(tristate buffer) 浮空可以用来防止结点处于竞争状态； 当一个结点同时连接n个输出时，若其中n-1个输出处于浮空状态，则当前结点的值等于驱动正常电平输出端的值； 三态缓冲器 有三种可能输出状态； 高电平、低电平和浮空； 输入端A，输出端Y，使能端E。 三态缓冲器的应用 在连接多个芯片的总线上使用 许多不同的设备同时连接在一总线上； 在某一个时刻只允许一个芯片的使能信号有效，并向总线输出数据； 其他芯片的输出必须浮空，以防止总线竞争； 任何芯片在任何时刻都可以通过总线读取信息。 卡诺图 使用卡诺图化简布尔表达式 卡诺图的构成 三变量卡诺图 二变量、四变量卡诺图 五变量卡诺图 用卡诺图表示逻辑函数 卡诺图上合并最小项的规则 实例 合并规则总结 用卡诺图化简逻辑函数 组合逻辑电路设计方法 设计思路 对实际逻辑问题进行抽象，定义输入和输出逻辑变量； 由实际逻辑问题列出真值表； 由真值表写出表达式； 化简表达式； 画出原理图。 7段数码管驱动电路 4位输入数据，输入一个十进制数字(4位二进制数可以表示一位十进制数)； 7位输出控制发光管显示数字0~9。 7段数码管的两种连接方法 共阴极：0代表不亮 共阳极：1代表不亮 7段数码管逻辑电路设计思路 对实际问题进行抽象，定义输入和输出逻辑变量 由实际逻辑问题列出真值表 由真值表写出表达式 化简表达式 画出原理图 考虑无关项 组合逻辑模块 编码器 用n位二进制代码对N=2n个特定信息进行编码的逻辑电路 例：设计一个具有4路信号输入的优先级编码器 输入：X0、X1、X2、X3(高电平为有效信号)； 输出：A1、A0、EO(用于判定是否存在有效输入)； 功能：将4个输入信号进行二进制编码(4线-2线编码器)。 带输出使能的优先级编码器 优先级编码：当有多个信号同时输入时，只对优先权高的一个信号进行编码； 输出使能端：用于判别电路是否有信号输入。 设计逻辑电路 译码器 译码是编码的逆过程，有n个输入，2n个输出； 每一种输入的组合对应使能某个特定的输出信号； 输出的独热(one-hot，互斥)的，同一时刻只能输出一个有效信号。 与上述4线-2线译码器(高电平为有效信号)相对应，以下为2线-4线译码器(高电平为有效信号) 译码器电路的实现 使用译码器实现复杂逻辑 译码器每个输出都对应一个最小项； 使用译码器+或门可以构造出更加复杂的表达式。 多路选择器 定义 根据选择信号的值从N个可能的输入中选择一个作为输出； 需要使用log2N位选择信号作为输入，控制输入信号的选择。 实现 更多输入的多路选择器 使用多路选择器实现复杂逻辑 组合逻辑中的时序问题 传播延迟和最小延迟 在实际电路中，输入影响输出的改变需要一定时间； 电路设计中最具有挑战性的问题是时序 定义 传播延迟(propagation delay)：tpd 输入改变直到一个或多个输出改变为最终值所经历的最长时间延迟； 最小延迟(contamination delay)：tcd 输入发生变化直到任何一个输出开始改变的最短时间。 产生原因 产生延迟的原因包括： 电路中的电阻和电容的充放电； 光速的上限。 tpd和tcd的值可能不同 上升沿与下降沿的延迟可能不同； 电路存在多个输入和输出时，不同输出的延迟可能不同； 电路对温度敏感，电路较热时速度会变慢。 关键路径与最短路径 毛刺 毛刺的产生 一个输入改变引起输出的多次变化； 也成为“冒险”(hazard)； 例：观察A=0，C=1时，B由1变0的瞬间发生了什么？ 上毛刺产生的分析 消除毛刺 当信号的变化在卡诺图中穿越2个主蕴含项的边缘时会出现毛刺； 通过在卡诺图中增加多余的蕴含项来盖住这些边缘以避免毛刺； 多个输入(几乎)同时变化也会产生毛刺； 这些不能通过增加硬件来避免。 毛刺在大多数电路中都存在。","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"Java-Part2","slug":"Java/Java-Part2","date":"2021-03-11T08:36:32.000Z","updated":"2021-06-17T06:31:08.492Z","comments":false,"path":"2021/03/11/Java/Java-Part2/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/11/Java/Java-Part2/","excerpt":"","text":"类、包和接口 本文章一些等价的名词 类 / class； 实例 / 对象：类的一个具体化； 方法 / 函数：在Java种等价； 实例变量 / 成员变量 / 实例属性 / 成员属性 / 域； static变量 / 类变量 / 静态变量； override 覆盖； overload 重载； 父类 / 超类 / superclass。 类、成员变量、方法 / 函数 类 类是组成Java程序的基本要素。它封装了一类对象的状态和方法，是这一类对象的原型； 一个类的例子：ch04.Person 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//ch04.Personpackage ch04;public class Person extends Object&#123; /* 实例变量又叫域变量，成员变量访问修饰符可以是private/protected/public或者干脆没有，但是没有friend; 实例变量不能重名，例如有一个变量是name，不能再有另外一个name; 实例变量如果没有赋值，会有默认值。字符串为null，整数为0... */ private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; /* 构造函数同样也可以有修饰符。构造函数必须和类名字同名，且不能有类型，也不能有返回值; 构造函数可以有多个。 */ public Person(String n, int a) &#123; name = n; age = a; &#125; /* 实例方法又叫成员方法、对象方法。同样可以有修饰符; 方法和构造函数最大的区别在于必须要有返回类型(如果什么都不返回则返回void)。 */ public void sayHello() &#123; //局部变量 String content=null; content = &quot;Hello! My name is &quot; + name + &quot;!&quot;; System.out.println(content); &#125; public void eat() &#123; System.out.println(&quot;eating!&quot;); &#125; public static void main(String[] args) &#123; //类的使用 //Person是一个类，person是类的一个实例 Person person = new Person(&quot;tom&quot;, 20); //注意调用方式 person.sayHello(); //下面这种方法是错误的 //Person.syHellow(); //也可以这样使用 person = new Person(&quot;abc&quot;, 30); Person p; p = new Person(&quot;li&quot;, 19); //和C++不同，使用完以后，不需要释放内存 //不同于C++，对象new完后不需要释放，系统会自动释放 &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; &#125; 部分笔记在上述代码中！ 构造函数 必须和类同名且定义在类中； 不能有任何返回值，void也不行。 12345678public class Dog&#123; public Dog()&#123;...&#125;;//Correct public Dog(String name)&#123;...&#125;;//Correct ... public void Dog()&#123;...&#125;;//Wrong void public createDog()&#123;...&#125;;//Wrong name&#125;public Dog()&#123;...&#125;;//Wrong outside 类的封装 应该尽量只能通过对象变量来访问这个对象的变量或方法，不通过引用变量就无法访问其中的变量或方法。对于访问者而言，这个对象是封装成一个整体的，这正体现了面向对象的程序设计的“封装性”。 重载 多个方法可以享有相同的名字； 这些方法的参数必须不同，或者是参数个数不同，或者是参数类型不同； 不能仅仅返回值类型不同。 1234567891011121314151617181920212223242526272829303132333435363738394041//ch04.Dogpackage ch04;public class Dog &#123; private String name; private int weight; public Dog(String name, int weight) &#123; this.name = name; this.weight = weight; &#125; //构造函数 //构造函数的重载 public Dog( int weight,String name) &#123; this(name,weight); //this.name = name; //this.weight = weight; //this.name表示对象的属性，name表示函数送入的参数。 &#125; //构造函数的重载 public Dog(int weight) &#123; this(&quot;noname&quot;,weight); &#125; //重载的例子 //两个speak一个有参数，一个没有参数 public void speak() &#123; System.out.println(&quot;wang wang!&quot;); &#125; //重载的例子 //两个speak一个有参数，一个没有参数 public void speak(String content) &#123; System.out.println(content); &#125; public static void main(String[] args) &#123; Dog dog=new Dog( 0 ); //错误，this不能用在static方法中 //用上语句会调用构造函数，其中包含 //this.name=&quot;noname&quot;; &#125;&#125; 如下方法每两个构成一对重载 123456789public void f1();public void f1(String p1);//public void f1(String f1,int f2);public void f1(int f2,String p1);//public void f1(String f1);private void f1(int f1);//修饰符可以不相同 如下方法每两个不构成一对重载 123456789101112public void f1();public int f1();//public void f1(String name,String address);public void f1(String address,String name);//public void f1(String f1);public void f2(String f1);//public void f1(String f1);private void f1(String f1);//不能仅用不同的访问控制来重载 this的用途1 使用this解决局部变量与实例同名的问题； this的上述用途1不能用在static方法中。 this的用途2 在一个构造函数里面调用另外一个构造函数； 可尽量减少代码的重复，便于修改。 类的继承 类的继承格式 1234class 父类 &#123;&#125;class 子类 extends 父类 &#123;&#125; 继承(inheritance)是面向对象的程序设计中最为重要的特征之一； 由继承而得到的类为子类(subclass)，被继承的类为父类或超类(superclass)，父类包括所有直接或间接被继承的类； 一个类只能有一个直接父类； 子类继承父类的状态和行为，同时也可以修改父类的状态或重载父类的行为，并添加新的状态和行为； 采用继承的机制来组织、设计系统中的类，可以提高程序的抽象程度，使之更接近与人类的思维方式，同时也通过继承能较好地实现代码重用，可以提高程序开发效率，降低维护的工作量。 1234567891011121314151617181920212223242526272829303132333435363738394041//ch04.Studentpackage ch04;public class Student extends Person &#123; private String school; @Override public void sayHello() &#123; //如何在子类中调用父类地方法 super.sayHello(); System.out.println(&quot;My school is &quot; + school); &#125; public void study() &#123; System.out.println(&quot;I am studying! &quot;); &#125; public Student(String name, int age, String school) &#123; //如何在子类中调用父类的构造函数 super(name, age); this.school = school; &#125; public static void main(String[] arggs) &#123; Person p = new Person(&quot;Liming&quot;, 50); p.sayHello(); Student student = new Student(&quot;Wangqiang&quot;, 20, &quot;PKU&quot;); student.sayHello(); student.eat(); String str=&quot;3&quot;; str=str+student; System.out.println(str); &#125; @Override public String toString() &#123; return &quot;Student [school=&quot; + school + &quot;, toString()=&quot; + super.toString() + &quot;]&quot;; &#125;&#125; Java中的继承 Java中的继承是通过extends关键字来实现的； 1class SubClass extends SuperClass&#123;...&#125; 如果没有extends语句，则该类默认为java.lang.Objext的子类； Java中所有的类都是通过直接或间接地继承java.lang.Object得到的。 方法地继承、覆盖与增加 方法地继承 父类地非私有方法也可以被子类自动继承。如Student自动继承Person的方法eat()； 方法的覆盖(Overriding) 子类也可以重新定义与父类同名同参数的方法，实现对父类方法的覆盖，如sayHello()； 实例方法和变量的增加 子类可以增加新方法，如study()。 包(Package) Java提供包来管理类名空间。包实际上提供了一种命名机制和可见性限制机制； 包是一种松散的类的集合，一般不要求处于同一个包中的类有明确的相互关系，如包含、继承等。但是由于同一包中的类在默认情况下可以相互访问，所以为了方便编程和管理，通常把需要在一起工作的类放在一个包里。 Package语句 package pkg1[.pkg2[.pkg3...]]; &lt;!--code￼8--&gt; 其中，package1[.package2[.package3…]]表明包的层次，与package语句相同，它对应于文件目录，classname则指明要引入的类，如果要从一个包中引入多个类，则可以用星号(*)来代替。例如： 12import java.awt.*;import java.util.Date; Java编译器为所有程序自动引入包java.lang，因此不必用import语句引入它包含的所有的类，但是若需要使用其他包中的类，必须用import语句引入； 注意：使用星号(*)只能表示本层次的所有类，不包括子层次下的类； 例如，经常需要用两条import语句来引入两个层次的类： 12import java.awt.*;import java.awt.event.*; Java中的访问控制符 同一个类中 同一个包中 不同包中的子类 不同包中的非子类 private Yes 默认 Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes 类的访问控制符 类、方法、变量前面可以加访问控制符，例如： 12345public class man()...private String name;protected String address;String email;//不写访问修饰符也是一种修饰符public static void main(String[],args)... setter与getter 在Java编程中，有一种常见的做法，是将所有的或部分的域用private修饰，从而更好地将信息进行封装和隐藏。用setXXXX和getXXXX方法对类的属性进行存取，分别成为setter与getter。这种方法有以下优点： 属性用private更好的封装和隐藏，外部类不能随意存取和修改； 提供方法来存取对象的属性，在方法中可以对给定的参数的合法性进行检验； 方法可以完成其他必要的工作(如清理资源、设定状态等等)； 只提供getXXXX方法，而不提供setXXXX方法，可以保证属性是只读的。 Eclipse中可自动生成setter&amp;getter 修饰符static、final和abstract static static变量，又叫静态变量/类变量，归属于整个类，而不属于某个类的实例； static方法：又叫静态方法/类方法，归属于整个类，而不属于某个类的实例； 访问static变量/方法可以通过类名.变量名/方法名来访问； 访问实例变量/方法要通过实例名.变量/方法名来访问； static方法中，只能访问static变量/方法，不能访问实例变量/方法； 实例方法中，既能访问static变量/方法，又能访问实例变量/方法。 1234567891011121314151617181920212223242526272829303132//ch04.Countpackage ch04;public class Count &#123; public int myCount; public static int totalCount; public int getMyCount() &#123; return myCount; &#125; public void setMyCount(int myCount) &#123; this.myCount = myCount; &#125; public static int getTotalCount() &#123; return totalCount; &#125; public static void setTotalCount(int totalCount) &#123; Count.totalCount = totalCount; &#125; public static void main(String args[]) &#123; Count count = new Count(); count.setMyCount(1); Count.setTotalCount(1); System.out.println(&quot;count.myCount=&quot; + count.getMyCount()); System.out.println(&quot;count.count=&quot; + Count.getTotalCount()); Count count2 = new Count(); count2.setMyCount(2); Count.setTotalCount(2); System.out.println(&quot;count1.myCount=&quot; + count.getMyCount()); System.out.println(&quot;count2.myCount=&quot; + count2.getMyCount()); System.out.println(&quot;count1.count=&quot; + Count.getTotalCount()); &#125;&#125; final final类：如果一个类被final修饰符所修饰和限定，说明这个类不能被继承，即不可能有子类； final方法：final修饰符所修饰的方法，是不能被子类所覆盖的方法； final变量：可以近似理解成不能被修改值的变量； 一个实例变量被static final两个修饰符所限定时，它实际的含义就是常量，如Integer.MAX_VALUE(表示最大整数)、Math.PI(表示圆周率)就是这种常量。在程序中，通常用static与final一起使用来指定一个常量； 在定义static final时，要么在定义的时候赋值，要么在类初始化的时候static{…}赋值； 在定义final实例变量时，要么在定义变量时赋初始值，要么在构造函数中赋值。 12345678910111213141516171819202122232425//ch04.TestFinalpackage ch04;public final class TestFinal &#123; private static final int totalNumber=0; private static final int totalId; static &#123; totalId=0; System.out.println(&quot;class init!&quot;); &#125; private final int myNumber=0; private final int myId; public TestFinal()&#123; System.out.println(&quot;instance init!&quot;); myId=1; &#125; public TestFinal(int id)&#123; System.out.println(&quot;instance init!&quot;); myId=id; &#125; public void setMyId() &#123; &#125; public static void main(String[] args) &#123; new TestFinal(); &#125;&#125; abstract 凡是用abstract修饰符修饰的类都被称为抽象类； 抽象类不能被实例化 被abstract所修饰的方法叫抽象方法，抽象方法的作用在为所有子类定义一个统一的接口。对抽象方法只需声明，而不需实现，即用分号(;)而不是用{}，格式如下： 1abstract returnType abstractMethod([paramlist]); 抽象类中可以包含抽象方法，也可以不包含abstract方法。但是，一旦某个类中包含了abstract方法，则这个类必须声明为abstract类； 抽象方法在子类中必须被实现，否则子类仍然是abstract的； abstract不能和private static final native同时修饰； abstract方法只能存在于abstract类中； abstract类中可以没有abstract方法。 1234567891011121314151617181920212223//ch04.AbstractTestpackage ch04;abstract class C&#123; abstract void callme( ); void metoo( )&#123; System.out.println(&quot;Inside C&#x27;s metoo( ) method&quot;); &#125;&#125;class D extends C&#123; void callme( )&#123; System.out.println(&quot;Inside D&#x27;s callme( ) method&quot;); &#125;&#125;abstract class E extends C&#123; &#125;public class AbstractTest&#123; public static void main( String args[ ] )&#123; C c = new D( ); c.callme( ); c.metoo( ); &#125;&#125; 对抽象类的总结 抽象类中的抽象方法没有方法体，因此无法直接实例化对象； 抽象类必须有子类，子类使用extends继承抽象类，一个子类只能够继承一个抽象类； 能够实现对象的子类，必须实现抽象类中全部的抽象方法。也就是说，只有当所有抽象方法不在抽象了，才能依据类，实现对象。 接口(interface) 有些时候，对象之间存在明显的单一方向继承关系，例如： Q：Java只支持单一继承 A： Java通过接口使得处于不同层次，甚至互不相关的类可以具有相同的行为； 接口就是方法定义和常量值的集合。它的用处主要体现在下面几个方面： 通过接口可以实现不相关类的相同行为，而不需要考虑这些类之间的层次关系； 通过接口可以指明多个类需要实现的方法； 通过接口可以了解对象的交互页面，而不需了解对象所应对的类。 在接口中定义这些共同的行为，然后由每个类分别实现这些行为； 与C++不同，Java不支持多继承，而是用接口实现比多继承更强的功能； 多重继承指一个类可以为多个类的子类，它使得类的层次关系不清楚，而且当多个父类同时拥有相同的成员变量和方法时，子类的行为是不确定的，这给编程带来了困难； 单一继承则清楚地表明了类的层次关系，指明子类和父类各自的行为； 接口则把方法的定义和类的层次区分开来，通过它可以在运行时动态地定位所调用的方法。同时接口中可以实现“多重继承”，且一个类可以实现多个接口。正式这些机制使得接口提供了比多重继承更简单、更灵活而且更强劲的功能。 接口的成员特点 成员变量：只能是常量； 默认修饰符：public static final； 构造方法：没有构造方法； 成员方法：只能是抽象的； 默认修饰符：public abstract； 接口的声明语法格式 1234[可见度] interface 接口名称 [extends 其他的接口名]&#123; //声明变量 //抽象方法&#125; 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字； 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字； 接口中的方法都是共有的。 1234567891011//Exampleimport java.lang.*;public interface NameOfInterface&#123; //任何类型 final,static字段 //抽象方法&#125;interface Animal&#123; public void eat(); public void travel();&#125; 当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类； 类使用implements关键字实现接口。在类声明中，implements关键字放在class声明后面； 实现一个接口的语法，可以使用这个公式： 1...implements 接口名称 [,其他接口名称,其他接口名称...,...]... 12345678910111213141516171819//Examplepublic class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(&quot;Mammal eats&quot;); &#125; public void travel()&#123; System.out.println(&quot;Mammal travels&quot;); &#125; public static void main(String[] args)&#123; MammalInt m=new MammalInt(); m.eat(); m.travel(); &#125;&#125;/*编译运行结果:Mammal eatsMammal travels*/ 接口的继承 使用extends关键字，子接口继承父接口的方法。 接口的多继承 在Java中，类的多继承是不合法的，但接口允许多继承； 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口 1public interface Hockey extends Sports,Event 接口的理解 Java语言中，接口占据着非常重要的地位 接口定义了Java语言当中的“全抽象”概念； 接口为Java赋予了较强的扩展性，而借助于接口的扩展性，Java语言能够在不同时期找到自己的位置，从而实现持续发展； 接口为Java的模块化奠定了基础。 接口和类 抽象类和接口的协同工作 狗都具有eat()、sleep()方法，我们分别通过抽象类和接口定义这个抽象的概念 如果需要让狗拥有一项特殊的技能——钻火圈DrillFireCircle()，抽象类？or接口？ 一个Special Dog即可继承Dog类，又可实现DrillFireCircle()接口。 继承：是不是； 接口：有没有； 如果一个类继承了某个抽象类，则子类必定是抽象类的种类； 而接口实现的则是有没有、具备不具备的关系； 接口定义是为了在不同的模块/组件之间协议或契约； 接口不关心内部的状态。 接口实例 12345678//ch05.inter.swimmerpackage ch04.inter;public interface Swimmer &#123; public void swim(); default int getSwimSpeed () &#123; return 0; &#125;&#125; 接口中只能包含public、static、final和没有修饰符类型的成员变量和public、abstract和没有修饰符类型的成员方法； 接口中JDK8之前，接口不能定义任何实现，这意味着之前所有的Java版本中，接口指定的方法是抽象的，不包含方法体。从JDK8开始，添加了一种新功能——默认方法。默认方法允许接口方法定义默认实现，而所有子类都将拥有该方法及实现。 接口的实现及用途 在类的声明中用implements语句来表示一个类使用某个接口，在类体中可以使用接口中定义的常量，而且必须实现接口中定义的所有方法。一个类可以实现多个接口。 好的编程风格应该面向抽象编程而不是面向具体编程。 实现例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//fishpackage ch04.inter;public class Fish extends Animal implements Swimmer &#123; public Fish() &#123; // TODO Auto-generated constructor stub &#125; @Override public void swim() &#123; // TODO Auto-generated method stub System.out.println(&quot;Fish swim!&quot;); &#125; @Override public void eat() &#123; // TODO Auto-generated method stub System.out.println(&quot;Fish eat!&quot;); &#125;&#125;//frogpackage ch04.inter;public class Frog extends Animal implements Runner,Swimmer &#123; public Frog() &#123; // TODO Auto-generated constructor stub &#125; @Override public void eat() &#123; // TODO Auto-generated method stub System.out.println(&quot;Frog eat!&quot;); &#125; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(&quot;Frog run!&quot;); &#125; @Override public void swim() &#123; // TODO Auto-generated method stub System.out.println(&quot;Frog swim!&quot;); &#125;&#125;//carpackage ch04.inter;public class Car implements Runner &#123; public Car() &#123; // TODO Auto-generated constructor stub &#125; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(&quot;car run!&quot;); &#125;&#125; 用途 123456789101112131415161718192021222324252627282930313233package ch04.inter;public class InterfaceUsage &#123; public InterfaceUsage() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; InterfaceUsage demo = new InterfaceUsage(); Car car = new Car(); Fish fish = new Fish(); Frog fog = new Frog(); demo.startRun(car); demo.startRun(fog); demo.startSwim(fish); demo.startSwim(fog); &#125; public void startRun(Runner runner) &#123; System.out.println(&quot;start run...&quot;); runner.run(); System.out.println(&quot;end run...&quot;); System.out.println(&quot;------------------------------&quot;); &#125; public void startSwim(Swimmer swimmer) &#123; System.out.println(&quot;start swim...&quot;); swimmer.swim(); System.out.println(&quot;end swim...&quot;); System.out.println(&quot;------------------------------&quot;); &#125;&#125; 接口、父类和子类类型转换 子类可以当作父类来用； 父类不能当作子类用； 实现了某个接口的子类可以当这个接口用； 接口不能当子类用。 强制类型转换 (类名) 对象 例如：String str=(String)obj。 实例如下(Important!) 12345678910111213141516171819//ch04.inter.ParentSubInterfaceAssignpackage ch04.inter;public class ParentSubInterfaceAssign &#123; public static void main(String[] args) &#123; String str=&quot;1&quot;; Object obj=str; str =obj; str =(String)obj; obj=new Object(); str =(String)obj; Frog frog=new Frog(); Swimmer swimmer=frog; Runner runner=frog; frog=swimmer; frog=(Frog)swimmer; swimmer=new Fish(); frog=(Frog)swimmer; &#125;&#125; 抽象类和接口的区别 接口的设计目的，是要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制； 抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为，且其中一部分行为的实现方法一致时，可以让这些类都派生于一个抽象类，避免让所有的子类来重复，实现代码复用的目的。其余个性化部分，留给各个子类自己实现。 instanceof 用于判断一个对象是否是某个类/接口(或子类，或是否实现了这个接口) 用法： 1对象名 instanceof 类名 instanceof例子： 枚举类型 123456789101112131415161718192021//ch04.en.EnumDirection2package ch04.en;static class EnumDriection2&#123; public enum EnumDirection2 &#123; EAST(&quot;东&quot;), SOUTH(&quot;南&quot;), WEST(&quot;西&quot;), NORTH(&quot;北&quot;); private EnumDirection2(String desc) &#123;//私有类型构造函数 this.desc = desc; &#125; private String desc;//存放其他属性，其他属性可以随意增减 public String getDesc() &#123;//取得其他属性 return desc; &#125; &#125; public static void main(String[] args) &#123; for(int i=0;i&lt;EnumDirection2.values().length;i++) &#123; EnumDriection2 dir=EnumDirection2.values()[i]; //ordinal()取得序号;getDesc()取得自定义描述 System.out.println(dir+&quot;=&quot;+dir.getDesc()+&quot;\\tindex=&quot;+dir.ordinal()); &#125; &#125;&#125; 关于构造函数 再谈构造函数——关于默认构造函数 必须和类同名且定义在类种； 不能有任何返回值，void也不行； 不能用static修饰，但是可以用public/private/protected修饰。 一个类可以没有显式的构造函数，可以调用默认构造方法(Important!) 默认构造方法是没有参数的构造方法，你可以显式定义类的默认构造方法； 为了保证每个类至少有一个构造方法，如果定义的类中一个构造方法也没有写，Java将自动提供一个默认构造方法。该构造方法没有参数，用public修饰，而且方法体为空。格式如下： 1public ClassName()&#123;&#125; 只要类中显式定义了一个或多个构造方法，而且所有显式定义的构造方法都带参数，那么将失去默认构造方法。 构造函数里面调用构造函数用this(…) 只能在构造函数第一行调用this(…)，且只能调用一次。 构造函数中的this/super 构造函数中调用自己的构造函数 this(…)； 调用父类的构造函数 super(…)； 每个构造函数在开始以前，会默认的调用其父类的无参数构造方法，除非这个类开始显式的调用了其他的父类构造函数； 但是，每个类的构造函数不会默认的调用自己的无参数构造方法。 构造函数的注意事项 推论1：如果一个父类，显式的声明了构造函数，且没有无参数构造函数，则其子类构造函数的第一句必须显式的调用父类的一个构造函数； 推论2：如果一个父类，显式的声明了构造函数，且没有无参数构造函数，则其子类必须显式的声明构造函数。 子类调用父类构造方法 在构造子类对象时，JVM会先调用父类的构造方法或者子类构造方法中通过super语句调用父类构造方法； 如果子类构造方法中没有通过super语句调用父类构造方法，那么JVM会调用父类的默认构造方法，如果不存在默认构造方法，将导致编译错误。 文章源码 文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"计算机网络-层次划分","slug":"Network/Network-Layers","date":"2021-03-10T12:56:22.000Z","updated":"2021-06-17T06:33:57.692Z","comments":false,"path":"2021/03/10/Network/Network-Layers/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/10/Network/Network-Layers/","excerpt":"","text":"计算机网络层次划分 应用层(Application Layer) 传输层(Transport Layer) 网络层(Network Layer) 链路层(Link Layer) 物理层(Physics Layer)","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"ComputerNetwork","slug":"ComputerNetwork","permalink":"https://cheeseburgerim.github.io/tags/ComputerNetwork/"}]},{"title":"数据库原理-Part1","slug":"DataBase/DataBasePrinciple-Part1","date":"2021-03-09T11:03:57.000Z","updated":"2021-06-19T15:13:14.559Z","comments":false,"path":"2021/03/09/DataBase/DataBasePrinciple-Part1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/09/DataBase/DataBasePrinciple-Part1/","excerpt":"","text":"","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/categories/DataBase/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/tags/DataBase/"},{"name":"DataBasePrinciple","slug":"DataBasePrinciple","permalink":"https://cheeseburgerim.github.io/tags/DataBasePrinciple/"}]},{"title":"数字逻辑与数字系统-Part1","slug":"MLAMS/MLAMS-Part1","date":"2021-03-07T03:02:24.000Z","updated":"2021-06-17T06:32:52.202Z","comments":false,"path":"2021/03/07/MLAMS/MLAMS-Part1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/07/MLAMS/MLAMS-Part1/","excerpt":"","text":"Chapter1 逻辑门 逻辑门 Logic Gates 单输入逻辑门 两输入逻辑门 多输入逻辑门 逻辑电平 Logic Levels 通过离散电压代表1和0 For example： ​ 0 = ground(GND) or 0 volts ​ 1 = VDD or 5 volts Questions： What about 4.99 volts ? Is that a 0 or a 1 ? What about 3.2 volts ? ground(GND)为接地电压； VDD为电源电压。 噪声 任何使得信号衰减的事物都是噪声 例如电源供电时耦合到传输线中的阻抗等就是噪声； 实例：一个驱动门输出电压为5V，但因为输出线上存在阻抗，接受端收到的电压只有4.5V 静态约束 对于有效的逻辑输入，所有的电路单元都必须产生有效的逻辑输出； 只能使用有限的电压范围来表示离散的数值1和0。 噪声容限 直流传输特性 理想情况与实际情况对比 逻辑电平系列 Logic Family VDD VIL VIH VOL VOH TTL 5(4.75-5.25) 0.8 2.0 0.4 2.4 CMOS 5(4.5-6) 1.35 3.15 0.33 3.84 LVTTL 3.3(3-3.6) 0.8 2.0 0.4 2.4 LVCMOS 3.3(3-3.6) 0.9 1.8 0.36 2.7 CMOS晶体管 在硅和锗晶体中，原子之间靠的很近，分属于每个原子的价电子受到相邻原子的影响，而使价电子为两个原子所共有，每个原子与其相邻的原子之间形成共价键，共用一对价电子。 形成共价键后，每个原子的最外层电子是八个，构成稳定结构； 共价键有很强的结合力，使原子规则排列，形成晶体； 共价键中的两个电子被紧紧束缚在共价键中，称为束缚电子，常温下束缚电子很难脱离共价键成为自由电子，因此本征半导体中的自由电子很少，所以本征半导体的导电能力很弱。 N型半导体 P型半导体 PN结的形成 在同一片半导体基片上，分别制造P型半导体和N型半导体，经过载流子的扩散，在它们的交界面处就形成了PN结。 PN结处载流子的运动 PN结的单向导电性 PN结反向偏置 半导体二极管的开关特性 MOS晶体管 nMOS晶体管 pMOS晶体管 CMOS晶体管功能 晶体管功能 nMOS能很好的导通低电平0，因此源极接地GND； pMOS能很好的导通高电平1，因此源极接电源VDD。 CMOS非门 A P1 N1 Y 0 ON OFF 1 1 OFF ON 0 CMOS与非门 晶体管功耗 功耗=单位时间消耗的能量 动态功耗； 静态功耗。 动态功耗 对栅极电容进行充电所耗费的能量 对电容充电到电压VDD所耗费的能量为CVDD； 当晶体管以频率f来工作，充电的频率为f/2，放电的频率也为f/2； 但放电的过程不需要耗费能量，因此同台功耗计算如下： 动态功耗：Pdynamic=1/2 CVDD2f 静态功耗 当系统处于空闲状态时，晶体管处于截至状态，但仍然会泄露少量电流，因此会产生静态功耗。静态功耗由电源和地之间的漏电流IDD产生，正比于漏电流。 计算公式如下： Pstatic=IDDVDD 功耗计算实例","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"Java-Part1","slug":"Java/Java-Part1","date":"2021-03-06T05:09:19.000Z","updated":"2021-06-17T06:30:59.852Z","comments":false,"path":"2021/03/06/Java/Java-Part1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/06/Java/Java-Part1/","excerpt":"","text":"Introduction Java编程语言的主要特性 面向对象 object-oriented 可移植性，跨平台 portable 支持分布式的网络应用 安全性和健壮性 secure and robust Java编程语言是个简单的、面向对象的、分布式的、解释性的、健壮的、安全的与系统无关的、可移植的、高性能的、多线程的并且静态的语言——Sun Java虚拟机 概念 Java虚拟机(Java Virtual Machine)在实际的计算机上通过软件模拟来实现； Java虚拟机有自己想象中的硬件。 功能 提供垃圾回收的功能； 提供运行时环境。 .class可以跨平台(操作系统) Java虚拟机每个平台(操作系统)不一样 关于跨平台的概念 Java是一次编译到处运行 Java编译为.class文件后，到其他操作系统无需再次编译 Java不是一次编写到处运行 C++文件在Windows上编写、编译成.exe文件运行，同样的代码在Linux要再次编译为Linux上可执行文件 Java程序运行模式 网页中的Applet，依托浏览器运行，目前已经很少使用了； Web方式(需要依托webserver如tomcat/websphere…)； Application，下文将重点讨论。 Java基础知识 Example 首先来看一个Java应用程序的示例：HelloWorldApp 12345678910//location:.../src/ch02/HelloWorldApp.javapackage ch02;//包的名字，注意一定要和目录严格匹配//注意如何定义一个类，每个.java文件只能定义一个public类，类名字必须和文件名完全符合public class HelloWorldApp&#123; //任何一个Application程序必须要有一个public static void main(String[] args)方法 //但不是所有的类都需要main方法 public static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 关于包package 每个包对应了源程序的一个目录，每个包可以有子包(子目录)； JDK的Java类库中的几个重要包：java.lang, java.io, java.awt, java.net, java.util； 包不同层级之间用 . 分割，正如目录用 / 分割； 一个包下包含了若干类文件或者子包 包 ch02 对应了 ch02/； 包 ch02.sub01 对应了 ch02/sub01/。 关于Java的源文件 初学者可以认为一个源文件(.java)对应一个类的定义(实际上这种说法并不准确，初学者可以这样认为)； .java文件经过编译后生成一个.class文件； Java虚拟机解释.class文件执行程序(java不能直接生成.exe文件)。 关于main方法 每个能够以Java Application模式运行的类中必须有一个main方法； public static void main(String[] args)或static public void main(String[] args)。 Java最基本语法 {} 程序段 每行程序以分号；结束 // 单行注释 /* 。。。*/ 多行注释 System.out.println(); 输出并换行； System.out.print(); 输出不换行； Java对大小写非常敏感！ 包名、类名、方法名、变量名均大小写敏感！ 字符界面的输入与输出 java.io包 System.in.read() System.out.print()/println() 程序： ch02.AppCharInOut 1234567891011121314151617181920212223package ch02;import java.io.*;/** * 例子2-3 * * 本例子演示了如何从控制台读入一个字符，并输出。 * * @author Administrator * */public class AppCharInOut &#123; public static void main(String[] args) &#123; char c = &#x27; &#x27;; System.out.print(&quot;Please input a char: &quot;); try &#123; c = (char) System.in.read(); &#125; catch (IOException e) &#123; &#125; System.out.println(&quot;You have entered: &quot; + c); &#125;&#125; ch02.AppLineInOut 12345678910111213141516171819202122package ch02;import java.io.*;/** * 本例子演示了如何从控制台读入一个行字符，并输出。 * * @author Administrator * */public class AppLineInOut &#123; public static void main(String[] args) &#123; String s = &quot;&quot;; System.out.print(&quot;Please input a line: &quot;); try &#123; BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); s = in.readLine(); &#125; catch (IOException e) &#123; &#125; System.out.println(&quot;You have entered: &quot; + s); &#125;&#125; ch02.AppNumInOut 123456789101112131415161718192021222324252627282930package ch02;//导入输入输出包import java.io.*;/** * 例子2-5 本例子演示了如何从控制台读入一个数字（浮点或者整数）并输出 * * @author Administrator * */public class AppNumInOut &#123; public static void main(String[] args) &#123; String s = &quot;&quot;; int n = 0; double d = 0; try &#123; BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); System.out.print(&quot;Please input an int: &quot;); s = in.readLine(); n = Integer.parseInt(s); System.out.print(&quot;Please input a double: &quot;); s = in.readLine(); d = Double.parseDouble(s); //异常的处理，初学者可以忽略这部分 &#125; catch (IOException e) &#123; &#125; System.out.println(&quot;You have entered: &quot; + n + &quot; and &quot; + d); &#125;&#125; 查看JDK源码 以Eclipse oxygen为例 操作系统Windows7 64位 其他操作系统及软件版本操作类似 鼠标点击对应变量名 或者ctrl鼠标点击方法名 Java数据类型 Java数据类型划分 Java中的数据类型分为两大类 一类是基本数据类型(primitive types)； 另一类是引用类型(reference types)； 后者相当于对象 数据类型={基本数据类型={数值型={整数类型(byte,short,int,long)浮点类型(float,double)字符型(char)布尔型(boolean)引用数据类型={类(class)接口(interface)数组数据类型=\\begin{cases} 基本数据类型=\\begin{cases} 数值型=\\begin{cases} 整数类型(byte,short,int,long)\\\\ 浮点类型(float,double) \\end{cases}\\\\ 字符型(char)\\\\ 布尔型(boolean) \\end{cases}\\\\ 引用数据类型=\\begin{cases} 类(class)\\\\ 接口(interface)\\\\ 数组 \\end{cases} \\end{cases} 数据类型=⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​基本数据类型=⎩⎪⎪⎪⎨⎪⎪⎪⎧​数值型={整数类型(byte,short,int,long)浮点类型(float,double)​字符型(char)布尔型(boolean)​引用数据类型=⎩⎪⎨⎪⎧​类(class)接口(interface)数组​​ Java基本数据类型 Java中定义了四类/八种基本数据类型 逻辑型——boolean 文本型——char 整数型——byte，short，int，long 浮点数型——float，double 逻辑型 boolean类型适合于逻辑运算，一般用于程序流程控制； boolean类型数据只允许取值true或false，不可以0或非0的整数替代true和false； 例如 12345boolean b=false;if(b==true)&#123;//do something&#125; 字符类型 char型数据用来表示通常意义上“字符”； 字符常量是用单引号括起来的单个字符 char c = ‘A’； Java字符采用Unicode编码，每个字符占两个字节，因而可用十六进制编码形式表示 char c1 = ‘\\u0061’； Java语言中还允许使用转义字符’'来将其后的字符转变为其他的含义 char c2 = ‘\\r’； 常用的转义字符 整数类型 Java各整数类型有固定的表数范围和字段长度，而不受具体操作系统的影响，以保证Java程序的可移植性 类型 占用存储空间(字节) 表数范围 byte 1 -128~127 short 2 -215~215-1 int 4 -231~231-1 long 8 -263~263-1 Java语言整形常量的三种表示形式(ch03.HexOctInt)： 十进制整数：如12，-134，0； 八进制整数：要求以0开头，如012； 十六进制数：要求以0x或0X开头，如0x12。 Java语言的整形常量默认为int型，如： int i=3； 声明long型常量可以后加’l’或’L’，如： long l=3L； 123456789101112131415161718//ch03.HexOctIntpackage ch03;public class HexOctInt &#123; public HexOctInt() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; int i = 10; int j = 010;//鍏繘鍒� int k = 0x10;//鍗佸叚杩涘埗 System.out.println(&quot;10=&quot; + i); System.out.println(&quot;010=&quot; + j); System.out.println(&quot;0x10=&quot; + k); &#125;&#125; 浮点型 Java浮点类型有固定的表数范围和字段长度 类型 占用存储空间(字节) 表述范围 float 4 -3.403E38~3.403E38 double 8 -1.798E308~1.798E308 Java浮点类型常量有两种表示形式 十进制数形式，必须含有小数点，例如： 3.14，314.0，。314 科学计数法形式，如： 3.14e2，3.14E2，314E2 Java浮点型常量默认为double型，如要声明一个常量为float型，则需在数字后面加f或F，如： double d=3.14； float f=3.14f； 基本数据类型变量声明和赋值 例子见如下代码 ch03.DeclareAssign 123456789101112131415161718192021//ch03.DeclareAssignpackage ch03;public class DeclareAssign&#123; public static void main (String args []) &#123; boolean b = true; int x, y=8; float f = 4.5f; double d = 3.1415; char c; c =&#x27;\\u0031&#x27;; x = 12; System.out.println(&quot;b=&quot; + b); System.out.println(&quot;x=&quot; + x); System.out.println(&quot;y=&quot; + y); System.out.println(&quot;f=&quot; + f); System.out.println(&quot;d=&quot; + d); System.out.println(&quot;c=&quot; + c); &#125;&#125; Java中的关键字 标识符 任何一个变量、常量、方法、对象和类都需要有名字，这些名字就是标识符。标识符可以由编程者自由指定，但是需要遵循一定的语法规定； 标识符要满足如下的规定： 首字母只能是a-z，A-Z，$或者_； 其余字母只能是a-z，A-Z，$，_或者数字。 在实际应用标识符时，应该使标识符能一定程度上反映它所表示的变量、常量、对象、或类的意义，这样程序的可读性会更好； 同时，应注意Java时大小写敏感的语言。 运算符与表达式 运算符 算术运算符 1234567891011121314151617181920212223242526272829//ch03.ArithmaticOppackage ch03;public class ArithmaticOp&#123; public static void main( String args[] )&#123; int a=5+4; //a=9 int b=9*2; //b=18 int c=18/4; //c=4 int d=18-4; //d=14 int e=-d; //e=-14 int f=-14%4; //f=-2 double g=18.4; double h=g%4; //h=2.4 int i=3; int j=i++; //i=4,j=3 int k=++i; //i=5,k=5 System.out.println(&quot;a = &quot;+a); System.out.println(&quot;b = &quot;+b); System.out.println(&quot;c = &quot;+c); System.out.println(&quot;d = &quot;+d); System.out.println(&quot;e = &quot;+e); System.out.println(&quot;f = &quot;+f); System.out.println(&quot;g = &quot;+g); System.out.println(&quot;h = &quot;+h); System.out.println(&quot;i = &quot;+i); System.out.println(&quot;j = &quot;+j); System.out.println(&quot;k = &quot;+k); &#125;&#125; 逻辑运算符 1234567891011121314//ch03.LogicOperatorpackage ch03;public class LogicOperator&#123; public static void main( String args[] )&#123; System.out.println(&quot;true&amp;&amp;false =&quot;+(true&amp;&amp;false) ); System.out.println(&quot;true||false =&quot;+(true||false) ); System.out.println(&quot;!true =&quot; +(!true)); System.out.println(&quot;true^false =&quot; +(true^false)); System.out.println(&quot;true&amp;false =&quot;+(true&amp;false) ); System.out.println(&quot;true|false =&quot;+(true|false) ); &#125;&#125; 位运算符 移位运算符 移位运算符性质 使用数据类型：byte、short、char、int、long，对低于int型的操作数将先自动转换为int型再移位； 对于int型整数移位a&gt;&gt;b，系统先将b对32取模，得到的结果才是真正移位的位数； 同样的，对于long型整数移位a&gt;&gt;b，则是先将b对64取模。 移位运算符应用举例 赋值运算符 赋值运算符= 当 “=” 两侧的数据类型不一致时，可以使用默认类型转换或强制类型转换(casting)原则进行处理 12long l=100;int i=(int)l; Exception：可以将整型常量直接赋值给byte，short，char等类型变量，而不需要进行强制类型转换，只要不超出其表数范围 12byte b=12; //legalbyte b=4096; //illegal 1234567891011121314151617181920212223242526272829303132333435363738//ch03.AssignOpertor/** * */package ch03;public class AssignOpertor &#123; /** * */ public AssignOpertor() &#123; // TODO Auto-generated constructor stub &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub double d=65; //float f1=d;//Wrong float f2=(float)d;//Right //int i1=f2;//Wrong int i2=(int)f2;//Right //char c1=i2;//Wrong char c2=(char)i2;//Right //byte b1=c2;//Wrong byte b2=(byte)c2;//Right //byte b3=128;//Wrong byte b4=65;//Right System.out.println(&quot;i2=&quot;+i2); System.out.println(&quot;c2=&quot;+c2); System.out.println(&quot;b2=&quot;+b2); &#125;&#125; 扩展赋值运算符 位和位移运算的实例 12345678910111213141516171819//ch03.BitOpertorpackage ch03;public class BitOperator &#123; public static void main(String args[]) &#123; int FLAG1 = 1; // (0x0001) int FLAG2 = 2; // (0x0010) int FLAG3 = 7; // (0x0111) System.out.println(&quot;0x0001|0x0010=&quot; + (FLAG1 | FLAG2)); System.out.println(&quot;0x0001&amp;0x0111=&quot; + (FLAG1 &amp; FLAG3)); System.out.println(&quot;0x0001^0x0111=&quot; + (FLAG1 ^ FLAG3)); System.out.println(&quot;0x0001&amp;0x0111=&quot; + (~FLAG1)); System.out.println(&quot;2&lt;&lt;1=&quot; + (2 &lt;&lt; 1)); System.out.println(&quot;2&gt;&gt;1=&quot; + (2 &gt;&gt; 1)); System.out.println(&quot;2&gt;&gt;1=&quot; + ((-2) &gt;&gt; 1)); System.out.println(&quot;2&gt;&gt;&gt;1=&quot; + ((-2) &gt;&gt;&gt; 1)); &#125;&#125; 表达式 表达式是符合一定语法规则的运算符和操作数的序列 表达式的类型和值 对表达式中操作数进行运算得到的结果称为表达式的值； 表达式的值的数据类型即为表达式的类型。 表达式的运算顺序 首先应按照运算符的优先级从高到低的顺序进行； 优先级相同的运算符按照事先约定的结合方向进行。 表达式中的类型转换 当有不同种类的混合运算时：int→long→float→double； 所有的byte，short，char等转为int； 例如 123double d=1;System.out.println(2*d);//输出为2.0而不是2 运算符优先级与结核性 流程控制语句 结构化程序设计的三种基本流程 顺序、分支、循环 简单语句 最简单的语句是方法调用语句及赋值语句，是在方法调用或赋值表达式后加一个分号(；) 如 123System.out.println(&quot;Hello World&quot;);a=3+x;b=a&gt;0?a:-a; 分支语句——if 1234567891011121314151617181920212223242526272829//ch03.LeapYear/** * */package ch03;public class LeapYear &#123; /** * */ public LeapYear() &#123; // TODO Auto-generated constructor stub &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub int year = 2003; if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)) &#123; System.out.println(year + &quot; is a leap year.&quot;); &#125; else &#123; System.out.println(year + &quot; is not a leap year.&quot;); &#125; &#125;&#125; 分支语句——switch 12345678910111213141516171819202122232425//ch03.GradeLevel.javapackage ch03;public class GradeLevel&#123; public static void main( String args[ ] )&#123; char grade=&#x27;C&#x27;; //normal use switch( grade )&#123; case &#x27;A&#x27; : System.out.println(grade+&quot; is 85~100&quot;); break; case &#x27;B&#x27; : System.out.println(grade+&quot; is 70~84&quot;); break; case &#x27;C&#x27; : System.out.println(grade+&quot; is 60~69&quot;); break; case &#x27;D&#x27; : System.out.println(grade+&quot; is &lt;60&quot;); break; default : System.out.println(&quot;input error&quot;); &#125; &#125;&#125; 循环语句 循环语句功能 在循环条件满足的情况下，反复执行特定代码。 循环语句的四个组成部分 初始化部分(init_statement)； 循环条件部分(test_exp)； 循环体部分(body_statement)； 迭代部分(alter_statement)。 循环语句分类 for循环； while循环 do/while循环。 123456789101112131415161718192021222324252627282930313233//ch03.Sum100package ch03;public class Sum100 &#123; public static void main(String args[]) &#123; int sum, n; System.out.println(&quot;\\n**** for statement ****&quot;); sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; sum = sum+i; &#125; System.out.println(&quot;sum is &quot; + sum); System.out.println(&quot;\\n**** while statement ****&quot;); sum = 0; n = 100; while (n &gt; 0) &#123; sum += n; n--; &#125; System.out.println(&quot;sum is &quot; + sum); System.out.println(&quot;\\n**** do_while statement ****&quot;); sum = 0; n = 0; do &#123; sum += n; n++; &#125; while (n &lt;= 100); System.out.println(&quot;sum is &quot; + sum); &#125;&#125; 特殊流程控制语句 123456789101112131415161718192021//ch03.BreakDemo/** * */package ch03;public class BreakDemo &#123; /** * @param args */ public static void main(String args[]) &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 3) break; System.out.println(&quot; i =&quot; + i); &#125; System.out.println(&quot;Game Over!&quot;); &#125;&#125; 12345678910111213141516171819202122232425//ch03.ContinueDemo/** * */package ch03;public class ContinueDemo &#123; /** * @param args */ public static void main(String args[]) &#123; round1:for (int i = 0; i &lt; 10; i++) &#123; round2:for (int j = 0; j &lt; 10; j++) &#123; if (j %2!=0) continue round2; if (i %2==0) continue round1; System.out.println(&quot; i =&quot; + i+&quot;\\t j =&quot; + j); &#125; &#125; System.out.println(&quot;Game Over!&quot;); &#125;&#125; 12345678910111213141516171819202122232425//ch03.BreakContinuepackage ch03;public class BreakContinue &#123; public BreakContinue() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; label1: for (int i = 0; i &lt; 5; i++) &#123; label2: for (int j = 0; j &lt; 5; j++) &#123; if(j==3)&#123; continue label2; &#125; if(i==3)&#123; break label1; &#125; System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j); &#125; &#125; &#125;&#125; 数组 数组概述 数组是多个相同类型数据的组合，实现对这些数据的统一管理； 数组属于引用类型，数组型数据是对象(object)，数组中的每个元素相当于该对象的成员变量； 数组中的元素可以是任何数据类型，包括基本类型和引用类型。 一维数组声明 一维数组的声明方式 12345type var[] or type[] var//For exampleint a[];int[] a1;double b[]; Java语言中声明数组时不能指定其长度(数组中元素的个数) 1int a[5]; //illegal 但是可以在需要初始化的时候声明长度 1int[] a=new int[5]; Java数组长度可以是变量(不同于C) 12int len=4;int[] a=new int[len]; 12345678910111213141516171819202122232425262728293031//ch03.ArrayDemopackage ch03;/** * 涓�缁存暟缁勭殑澹版槑鍜屽垵濮嬪寲 * @author Administrator * */public class ArrayDemo &#123; public static void main( String args[ ] )&#123; int[] a; a = new int[3]; a[0] = 3; a[1] = 9; a[2] = 8; int[] b= new int[3]; b[0] = 3; b[1] = 9; b[2] = 8; int[] c= &#123;1,2,3&#125;; //The following is illegal //int[] d=new int[3]; //d= &#123;1,2,3&#125;; int f[]= &#123;1,2,3&#125;; System.out.println(f instanceof Object); &#125;&#125; 数组元素的默认初始化 数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化 123456public class Test&#123; public static void main(String[] args)&#123; int a[]=new int[5]; System.out.println(a[3]); &#125;&#125; 12345678910111213141516//ch03.Fibonaccipackage ch03;public class Fibonacci &#123; public static void main(String args[]) &#123; int i; int f[] = new int[10]; f[0] = f[1] = 1; for (i = 2; i &lt; f.length; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; for (i = 1; i &lt;= f.length; i++) &#123; System.out.println(&quot;F[&quot; + i + &quot;]= &quot; + f[i - 1]); &#125; &#125;&#125; 数组元素的引用 定义并用运算符 new 为之分配空间后，才可以引用数组中的每个元素； 数组元素的引用方式：arrayName[index] index为数组元素下标，可以是整型常量或整型表达式 如a[3], b[i], c[6*i]； 数组元素下标从0开始；长度为n的数组合法下标取值范围：0~n-1； 每个数组都有一个属性 length 指明它的长度 例如：a.length 指明数组 a 的长度(元素个数)。 多维数组 12//二维数组举例int a[][]=&#123;&#123;1,2&#125;,&#123;3,4,0,9&#125;,&#123;5,6,7&#125;&#125;; i\\j j=0 j=1 j=2 j=3 i=0 1 2 i=1 3 4 0 9 i=2 5 6 7 Java中多维数组被做为数组的数组处理； Java中多维数组的声明和初始化应按从高维到低维的顺序进行 123456//legalint t[][]=new int[4][];t[0]=new int[5];t[1]=new int[5];//illegalint t1[][]=new int[][4]; Java中多维数组不必须是规则矩阵形式 1234567int [][] tt=new int[4][];tt[0]=new int[2];tt[1]=new int[4];tt[2]=new int[6];tt[3]=new int[8];int tt[][]=new int[4][5]; 多维数组初始化 静态初始化 12int intArray[][]=&#123;&#123;1,2&#125;,&#123;2,3&#125;,&#123;3,4,5&#125;&#125;;//legalint intArray[3][2]=&#123;&#123;1,2&#125;,&#123;2,3&#125;,&#123;4,5&#125;&#125;;//illegal 动态初始化 12345int a[][]=new int[4][5];int b[][]=new int[3][];b[0]=new int[2];b[1]=new int[3];b[2]=new int[5]; 复制数组 关于String和char初步认知 Java中字符(char)和字符串(String)的区别 123456789101112131415161718192021//ch03.CharAndString/** * */package ch03;public class CharAndString &#123; public static void main(String[] args) &#123; char c=&#x27;a&#x27;; char c2=(char)256; String s1=&quot;abc&quot;; String s2=String.valueOf(c); System.out.println(&quot;c=&quot;+c); System.out.println(&quot;c2=&quot;+c2); System.out.println(&quot;s1=&quot;+s1); System.out.println(&quot;s2=&quot;+s2); &#125;&#125; char是基本数据类型，可以保存一个字符，用’ '； 可以把一个整数转换为char； String是一个类，可以保存0个或者更多char，用&quot; &quot;； String类中提供把char转换为String的方法。 Java中的字符 &quot;+&quot;可用于对字符串进行连接操作 1String s=&quot;hello, &quot;+&quot;world!&quot;; &quot;+&quot;两侧操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串 1234int i=300+5;String s=&quot;hello, &quot;+i+&quot;号&quot;;System.out.println(s);//输出：hello, 305号 体会&quot;+&quot;的不同结果 1234String s5=&quot;1&quot;+&#x27;1&#x27;;char c2=&#x27;1&#x27;+&#x27;1&#x27;;System.out.println(s5+&quot;,&quot;+c2);//输出：11,b char[] String int 之间的转换 12345678910111213141516171819202122232425262728//ch03.CharArrayStringInt/** * */package ch03;public class CharArrayStringInt &#123; public CharArrayStringInt() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; String s1 = &quot;abc&quot;; // String to char[] char[] charArray = s1.toCharArray(); // char[] to String String s2 = new String(charArray); // get the length of String int len = s1.length(); int num=123; // int to String String s3=String.valueOf(num); // String to int int num2=Integer.valueOf(s3); &#125;&#125; 字符串的比较 判断s1，s2是否相等 123s1.equals(s2);ors1.equalsIgnoreCse(s2); 比较两个字符串大小 1234s1.compareTo(s2);相等 返回0;大于 返回正数，第一位不同的字符相差的ASCII值;小于 返回负数，第一位不同的字符相差的ASCII值; 12345678910111213141516171819202122232425//ch03.StringComparepackage ch03;public class StringCompare &#123; public StringCompare() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; String s1=&quot;&quot;; String s2=&quot;123&quot;; for(int i=0;i&lt;4;i++) &#123; s1=s1 + i; &#125; System.out.println(&quot;s1.equals(s2):&quot;+s1.equals(s2)); System.out.println(&quot;s1 == s2 :&quot;+(s1==s2)); System.out.println(&quot;abc.equals(ABc) :&quot;+&quot;abc&quot;.equals(&quot;ABc&quot;)); System.out.println(&quot;abc.equals(ABc) :&quot;+&quot;abc&quot;.equalsIgnoreCase( &quot;ABc&quot;)); System.out.println(&quot;abc.compareTo(aaa) :&quot;+&quot;azc&quot;.compareTo(&quot;aaa&quot;)); System.out.println(&quot;abc.compareTo(abc) :&quot;+&quot;abc&quot;.compareTo(&quot;abc&quot;)); System.out.println(&quot;abc.compareTo(abd) :&quot;+&quot;abc&quot;.compareTo(&quot;abz&quot;)); &#125;&#125; String其他常见操作 错误程序例子 测试代码及输出结果 123456789101112131415161718192021package Test;public class Test&#123; public static void main(String[] args) &#123; int i=300+5; String s=&quot;hello&quot;+i+&quot;号&quot;; System.out.println(s); String s5=&quot;1&quot;+&#x27;1&#x27;; char c2=&#x27;1&#x27;+&#x27;1&#x27;; System.out.println(s5+&quot;,&quot;+c2); System.out.println(5+7); System.out.println(1234567890+1234567890); System.out.println(1234567890l+1234567890); System.out.println(&quot;abc.compareTo(aaa) :&quot;+&quot;azc&quot;.compareTo(&quot;aaa&quot;)); System.out.println(&quot;abc.compareTo(abc) :&quot;+&quot;abc&quot;.compareTo(&quot;abc&quot;)); System.out.println(&quot;abc.compareTo(abd) :&quot;+&quot;abc&quot;.compareTo(&quot;abz&quot;)); &#125;&#125; 文章源码 文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"域名更换","slug":"ChangeDomainName1","date":"2021-03-05T05:00:54.000Z","updated":"2021-03-22T15:25:22.865Z","comments":false,"path":"2021/03/05/ChangeDomainName1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/05/ChangeDomainName1/","excerpt":"","text":"2021/3/5 ~ 2022/3/5 域名暂时更换至 CheeseburgerIM.space","categories":[{"name":"Notification","slug":"Notification","permalink":"https://cheeseburgerim.github.io/categories/Notification/"}],"tags":[{"name":"ChangeDomainName","slug":"ChangeDomainName","permalink":"https://cheeseburgerim.github.io/tags/ChangeDomainName/"},{"name":"Notification","slug":"Notification","permalink":"https://cheeseburgerim.github.io/tags/Notification/"}]},{"title":"NOWCODER-2021-3","slug":"CodeExercise/NOWCODER-2021-3","date":"2021-03-01T09:29:44.000Z","updated":"2021-03-29T13:59:43.334Z","comments":false,"path":"2021/03/01/CodeExercise/NOWCODER-2021-3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/01/CodeExercise/NOWCODER-2021-3/","excerpt":"","text":"Part1 3/3 求出两个数的最大公约数 My Code 12345678910111213#include &lt;iostream&gt;using namespace std;int gcd(int a,int b);int main()&#123; system(&quot;pause&quot;); return 0;&#125;int gcd(int a,int b)&#123; if(a%b==0) return b; return gcd(b,a%b);&#125; Question From：HERE 判断给定的链表中是否有环。如果有环则返回true，否则返回false。 My Code 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;struct ListNode&#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;bool hasCycle(ListNode *head);int main()&#123; system(&quot;pause&quot;); return 0;&#125;bool hasCycle(ListNode *head)&#123; ListNode *slow=head,*fast=head; while(slow&amp;&amp;fast&amp;&amp;fast-&gt;next) &#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast) return true; &#125; return false;&#125; 思路：定义快慢指针，若慢指针能追上快指针，说明链表中存在环，否则不存在； Question From：HERE Part2 3/5 TRDD开了一家免费WiFi体验店， 所有人都可以免费连接WiFi， 只有一个条件， 你要提前一天预约。今天，TRDD收到了n(1 &lt;= n &lt;=1000)个人的预约， 每个人有一个时间段[L, R] (1 &lt;= L &lt;= R &lt;= 5000)表示这个人预约连接WiFi从L时刻到R时刻。 但是市面上只有一种路由器， 这种路由器单台最多能同时连接m(n &lt;= 100)台设备， TRDD想要知道最少使用多少台路由器就能保证明天每个人都能连上WiFi。 思路：首先在纸上直角坐标系，可以清晰地找到最大值； 在C++中，通过定义二维数组来模拟坐标系； 每当有人来使用WiFi时，找到可以使x=l和x=r之间(x,y)恒等于0的y的最小值，将(l,y),(l+1,y)…(r,y)全部置1，问题得解； 不过由于题目中n为1000，定义一个[1000] [1000]的二维数组在提交时提示越界。 Answer 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main()&#123; int n,m; int a[5001]=&#123;0&#125;; cin&gt;&gt;n&gt;&gt;m; int Max=1e-7; while(n--)&#123; int l,r; cin&gt;&gt;l&gt;&gt;r; for(int i=l;i&lt;=r;i++)&#123; a[i]++; if(a[i]&gt;Max)&#123; Max=a[i]; &#125; &#125; &#125; int result; if(Max%m==0)&#123; result = Max/m; &#125; else&#123; result = Max/m+1; &#125; cout&lt;&lt;result&lt;&lt;endl;&#125; 思路：与我思路相似，不过在实现时将二维数组改为一维数组，二维数组的纵坐标即为一维数组中的元素大小，输入所有人的时间后，找到最大值，问题得解。 Question From：HERE Part3 3/6 tabris有一个习惯，无聊的时候就会数圈圈，无论数字还是字母。 现在tabris更无聊啦，晚上睡不着觉就开始数羊，从a只数到b只。 顺便还数了a到b之间有多少个圈。 但是tabris笨啊，虽然数羊不会数错，但很可能数错圈的个数。 但是tabris很难接受自己笨这个事实，所以想问问你他一共应该数出多少个圈，这样tabris才好判断他到底笨不笨啊。 My Code 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; int t; while(cin&gt;&gt;t) &#123; int a,b; for(int i=0;i&lt;t;i++) &#123; cin&gt;&gt;a&gt;&gt;b; int sum=0; for(int j=a;j&lt;=b;j++) &#123; int temp=j; while(temp!=0) &#123; int r=temp%10; if(r==4||r==6||r==9||r==0) sum++; else if(r==8) sum=sum+2; temp=temp/10; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：暴力循环即可。 Question From：HERE Part4 3/7 Atsa just bought Super Mario Maker and wants to test your skills for an analysis with a level that he prepared. My Code 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main()&#123; int l,g; while(cin&gt;&gt;l&gt;&gt;g) &#123; int max=0; for(int i=0;i&lt;g;i++) &#123; int p,d; cin&gt;&gt;p&gt;&gt;d; if(d==0&amp;&amp;d&gt;max) &#123; max=d; &#125; else if(d==1&amp;&amp;l-d&gt;max) &#123; max=l-d-1; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：相撞并不影响走的距离，就像高中物理，质量相同的两小球相撞，无能量损失，碰撞后都按原来相反方向相同速率运动。 Question From：HERE 妞妞希望能选取最大数量的硬币，使其总价值足以支付车费并且出租车司机能接受。 妞妞希望你能帮她计算最多可以支付多少个硬币。 My Code 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n,s; while(cin&gt;&gt;n&gt;&gt;s) &#123; int p[20]=&#123;&#125;; for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i]; sort(p,p+n); int temp=0,ans=0,i=0; while(temp&lt;s) &#123; temp=temp+p[i]; ans++; i++; &#125; for(int i=ans-1;i&gt;=0;i--) &#123; if(temp-p[i]&gt;=s) &#123; ans--; temp=temp-p[i]; &#125; &#125; cout&lt;&lt;ans; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：将硬币大小从小到大排序，用循环拿硬币，直到钱已经大于车费时停止循环；再在所拿的硬币中从大到小取出硬币，直到司机接受为止。 Question From：HERE Part5 3/8 情人节到了，小芳和小明手牵手，打算过一个完美的情人节，但是小刚偏偏也来了，当了一个明晃晃的电灯泡，小明很尴尬，就和小刚说，我交给你个任务，你完成了我俩就带你玩，否则你就回家吧。小刚很有当单身狗的觉悟，他坚决不想让小明过好情人节，同为单身狗的你能帮帮他吗？现在有一个n×n（1 &lt;= n &lt;= 1000）的格子，每一个格子都有一个电灯泡，可能是亮的，也可能是灭的（1代表亮， 0代表灭），现在有两种操作，一种是给你一个坐标，对于那个坐标上的灯泡，如果他是亮的，那么熄灭他，反之如果他是灭的，那么打开它。第二种操作是给你两个坐标，第一个坐标代表一个子矩阵的左上角，另一个坐标是右下角，请你求出当前子矩阵中有多少个灯泡是亮着的。燥起来吧！！！单身狗们！！！！ My Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; int bulb[1010][1010]=&#123;&#125;; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;bulb[i][j]; &#125; &#125; for(int i=0;i&lt;m;i++) &#123; int f; cin&gt;&gt;f; if(f==1) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; if(bulb[x][y]==1) bulb[x][y]=0; else if(bulb[x][y]==0) bulb[x][y]=1; &#125; else if(f==2) &#123; int x1,y1,x2,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; int num=0; for(int j=x1;j&lt;=x2;j++) &#123; for(int k=y1;k&lt;=y2;k++) &#123; if(bulb[j][k]==1) num++; &#125; &#125; cout&lt;&lt;num&lt;&lt;endl; &#125; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE 今天qwb要参加一个数学考试，这套试卷一共有n道题，每道题qwb能获得的分数为ai，qwb并不打算把这些题全做完，他想选总共2k道题来做，并且期望他能获得的分数尽可能的大，他准备选2个不连续的长度为k的区间,即[L,L+1,L+2,…,L+k-1]，[R,R+1,R+2,…,R+k-1]（R &gt;= L+k）。 My Code 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int getSum(int a[],int l,int r);int main()&#123; int t; while(cin&gt;&gt;t) &#123; int n,k; for(int i=0;i&lt;t;i++) &#123; cin&gt;&gt;n&gt;&gt;k; int *a=new int [n+1]; for(int j=0;j&lt;n;j++) &#123; cin&gt;&gt;a[j]; &#125; int max=0; for(int j=0;j+k+k&lt;=n;j++) &#123; for(int m=j+k;m+k&lt;=n;m++) &#123; int temp=getSum(a,j,j+k-1)+getSum(a,m,m+k-1); if(temp&gt;max) max=temp; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125;int getSum(int a[],int l,int r)&#123; int sum=0; for(int i=l;i&lt;=r;i++) &#123; sum=sum+a[i]; &#125; return sum;&#125; 思路：暴力循环求解，超时。 答案代码如下 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[2000005];int main()&#123; ios::sync_with_stdio(0); int _;cin&gt;&gt;_; while(_--)&#123; int n,k;cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],a[i]+=a[i-1]; ll ma=-1e18,ans=-1e18; for(int i=k;i+k&lt;=n;i++)&#123; ma=max(ma,a[i]-a[i-k]); ans=max(ans,ma+a[i+k]-a[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 因为区间大小是固定为k的，所以显然需要前缀和处理一下 处理之后我们去维护前缀中长度为k的最大值ma，枚举第二个长度为k的起点，那么答案就是max(ma+当前长度为k的序列和) 复杂度为O(n) 极限数据计算 n为2e5，k=1e5 所有ai都是1e5 那么最大值是2e5*1e5&gt;(1&lt;&lt;31)-1 超过了int所能表示的范围 所以需要开long long 定义数组a[0]=0; cin&gt;&gt;a, a[1]=a[1-1]+a; cin&gt;&gt;a, a[2]=a[2-1]+a; … cin&gt;&gt;a, a[n]=a[n-1]+a. 通过单层for循环找到前两个最大值，问题得解。 Question From：HERE Part6 3/9 良神爱吃甜点，如果他吃不到甜点的话就会很暴躁！现在桌子上摆着一排n个点心，每个点心具有一个甜度ai，良神一次能吃连续的一些点心，但是他一次不能吃总甜度和超过m（可以等于m），否则他就长不高啦！良神想要知道他最少吃几次才能把这些点心都吃完。 My Code 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; int *a=new int[n+1]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; int ans=0; int temp=0; for(int i=0;i&lt;n;i++) &#123; if(temp+a[i]&lt;=m) &#123; temp=temp+a[i]; &#125; else &#123; ans++; temp=0; i=i-1; &#125; &#125; cout&lt;&lt;ans+1&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE 大吉大利，今晚吃鸡——枪械篇 My Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;struct GUN&#123; double p; int k; double accessory[1010]=&#123;&#125;;&#125;;struct ACCESSORY&#123; int type; double damage;&#125;;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; //输入n把枪的属性 //GUN *gun=new GUN[n+10]; GUN gun[1010]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;gun[i].p&gt;&gt;gun[i].k;//输入p，k for(int j=0;j&lt;gun[i].k;j++) cin&gt;&gt;gun[i].accessory[j];//输入第i把枪可以装备的配件种类，共k种 &#125; //输入m个配件的属性 //ACCESSORY *a=new ACCESSORY[m+10]; ACCESSORY a[1010]; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a[i].type&gt;&gt;a[i].damage;//输入配件的种类和威力 &#125; //找到每个配件的最大值 double *maxA=new double[m+10]; maxA[0]=-1; for(int i=1;i&lt;=m;i++) &#123; double max=0; for(int j=0;j&lt;m;j++) &#123; if(a[j].type==i&amp;&amp;a[j].damage&gt;max) max=a[j].damage; &#125; maxA[i]=max; &#125; /* for(int i=0;i&lt;=m;i++) &#123; cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;maxA[i]&lt;&lt;endl; &#125; */ double MAX=0; for(int i=0;i&lt;n;i++) &#123; double tempG=gun[i].p; double tempA=0; for(int j=0;j&lt;gun[i].k;j++) &#123; tempA=tempA+maxA[int(gun[i].accessory[j])]; &#125; double temp=tempG*(1+tempA); if(temp&gt;MAX) MAX=temp; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;MAX&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE Part7 3/10 现在给出一个赛区的规模，也就是这个赛区的实际参赛队伍数，小 Q 同学想知道有多少队伍的奖牌会由银变金、由铜变银、由铁变铜。 My Code 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; double n; while(cin&gt;&gt;n) &#123; double gold=n*0.1; double silver=n*0.2; double bronze=n*0.3; int goldChange=0,silverChange=0,bronzeChange=0; if(gold-(int)gold&gt;0) goldChange=1; if(silver-(int)silver&gt;0) silverChange=goldChange+1; else silverChange=goldChange; if(bronze-(int)bronze&gt;0) bronzeChange=silverChange+1; else bronzeChange=silverChange; cout&lt;&lt;goldChange&lt;&lt;&quot; &quot;&lt;&lt;silverChange&lt;&lt;&quot; &quot;&lt;&lt;bronzeChange&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE Part8 3/11 彩虹岛网红脸盆大哥最骄傲就是自己制作的木桶。一天𝑙𝑤𝑞拿了𝑛块木板，其中第𝑖块木板的高度为ℎ𝑖，他希望脸盆大哥能够用这些木板制作出精美的木桶。脸盆大哥告诉𝑙𝑤𝑞制作一个木桶需要𝑘块木板，并且所有桶的底面积为𝑠，底面的木板由𝑠𝑙𝑝提供。𝑙𝑤𝑞想知道用这些木块所制作出来的木桶最多能够盛多少体积的水。 注意，木板不能叠在另一个木板上，且不需要考虑木桶具体是怎么由木板组成的，即是说1块或2块木板也可以组成木桶，底面积仍为𝑠。 My Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;#include &lt;valarray&gt;using namespace std;//int findMax(int h[]);int main()&#123; int t; while (cin &gt;&gt; t) &#123; while (t--) &#123; int n, k, s; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; int height[1010]=&#123;&#125;; for (int i = 0; i &lt; n; i++) cin &gt;&gt; height[i]; //for(int i=0;i&lt;n;i++) cout&lt;&lt;height[i]&lt;&lt;&quot; &quot;; //cout&lt;&lt;endl; int ans = 0; for (int i = 0; i &lt; n / k; i++) &#123; int min = 10000; for (int j = 0; j &lt; k; j++) &#123; int max = *max_element(height, height + n); //cout&lt;&lt;&quot;max:&quot;&lt;&lt;max&lt;&lt;endl; if (max &lt; min) min = max; //int index = *find(height, height + n, max) - 1; int index=0; for(int m=0;m&lt;n;m++) &#123; if(height[m]==max) &#123; index=m; break; &#125; &#125; //cout&lt;&lt;&quot;index:&quot;&lt;&lt;index&lt;&lt;endl; height[index] = -1; &#125; //cout&lt;&lt;min*s&lt;&lt;endl; ans = ans + min * s; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE 银行的定期存款一般有1年期、2年期、3年期、5年期四种。 现在我们有1块钱，我们想知道，通过合理安排存款方式，n年以后这1块钱最多会变成几块钱。 假设在这n年里利率不变，且n年以后这笔钱不能处于2年期、3年期、5年期存款年限的中间（否则会变成活期）。 My Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int n; double r1,r2,r3,r5; cin&gt;&gt;n&gt;&gt;r1&gt;&gt;r2&gt;&gt;r3&gt;&gt;r5; double money=1; while(n) &#123; if(n&gt;=5) &#123; int time=n/5; for(int i=0;i&lt;time;i++) &#123; money=money*pow(1+r5,5); &#125; n=n%5; &#125; else if(n&gt;=3) &#123; int time=n/3; for(int i=0;i&lt;time;i++) &#123; money=money*pow(1+r3,3); &#125; n=n%3; &#125; else if(n&gt;=2) &#123; int time=n/2; for(int i=0;i&lt;time;i++) &#123; money=money*pow(1+r2,2); &#125; n=n%2; &#125; else &#123; money=money*(1+r1); n--; &#125; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(5)&lt;&lt;money&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 思路：起初认为存钱年数越长，得到的本息越多，后发现这是错的； 需要使用动态规划。 Answer 1234567891011121314151617181920212223242526272829303132# include&lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;# include &lt;math.h&gt;# define ll long longusing namespace std;double max(double a,double b)&#123; if(a&gt;b) return a; else return b;&#125;double dp[40];int main()&#123; int n;double r1,r2,r3,r5; cin&gt;&gt;n&gt;&gt;r1&gt;&gt;r2&gt;&gt;r3&gt;&gt;r5; r1=pow(1+r1,1); r2=pow(1+r2,2); r3=pow(1+r3,3); r5=pow(1+r5,5); dp[0]=1; for(int i=1;i&lt;=20;++i) &#123; if(i&gt;=1)dp[i]=max(dp[i-1]*r1,dp[i]); if(i&gt;=2)dp[i]=max(dp[i-2]*r2,dp[i]); if(i&gt;=3)dp[i]=max(dp[i-3]*r3,dp[i]); if(i&gt;=5)dp[i]=max(dp[i-5]*r5,dp[i]); &#125; cout&lt;&lt;dp[n]&lt;&lt;endl; return 0;&#125; 动态规划 Question From：HERE Part9 3/13 栗酱在酒桌上玩一个小游戏，第一个人从1开始数数，如果遇到数字中含4或者数字是4的倍数则跳过报下一个，数错了就要罚酒一杯。 My Code 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;bool isFour(int num);int main()&#123; int n; while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;i++) &#123; if(i%4!=0&amp;&amp;isFour(i)) cout&lt;&lt;i&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125;bool isFour(int num)&#123; while(num!=0) &#123; int rest=num%10; if(rest==4) return false; num=num/10; &#125; return true;&#125; Question From：HERE 坤酱想把一块圆形的布裁成正多边形，于是请你告诉坤酱正多边形的几个顶点应在哪里？ 为了方便表示，圆给出在坐标系中，正多边形的第一个顶点固定在该圆在平行于x轴正方向最远的位置上，请按顺时针顺序输出所有的顶点。 My Code 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;math.h&gt;const double PI(acos(-1));using namespace std;int main()&#123; int t; while (cin &gt;&gt; t) &#123; while (t--) &#123; double x, y, r, n; cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; n; double angle = 2 * PI / n; double tempAngle = 0; for (int i = 0; i &lt; n; i++, tempAngle = tempAngle - angle) &#123; if(fabs(x+r*cos(tempAngle))&lt;10e-6) cout&lt;&lt;&quot;0.00 &quot;; else cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; x + r * cos(tempAngle) &lt;&lt; &quot; &quot;; if(fabs(y+r*sin(tempAngle))&lt;10e-6) cout&lt;&lt;&quot;0.00&quot;&lt;&lt;endl; else cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; y + r * sin(tempAngle) &lt;&lt; endl; &#125; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：第一个顶点在原点右边；通过for循环以及cos和sin三角函数计算每次的横坐标和纵坐标改变量； 注意： 通过const double PI(acos(-1));定义PI来减小误差； 通过判断横纵坐标绝对值是否足够小来决定输出(避免输出-0.00)，其中fabs为适用于double类型的绝对值函数。 Question From：HERE Part10 3/14 中国文化的五行：金、木、水、火、土相生相克， 一天Alice和Bob玩起了卡牌游戏。卡牌包含5种类型Jin，Mu，Shui，Huo，Tu，分别代表金、木、水、火、土。 金克木，木克土，土克水，水克火，火克金。游戏规则如下： 两人玩n轮，每轮各自抽取一张卡牌，如果其中一个人的牌克制另一个人的牌那么这个人得3分，另一个人得0分。没有克制关系两人都得1分。最后得分高的获胜。 My Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;math.h&gt;using namespace std;int getLevel(string s);int main()&#123; int n; while(cin&gt;&gt;n) &#123; int score1=0,score2=0; while(n--) &#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; int Alice=getLevel(s1),Bod=getLevel(s2); if(abs(Alice-Bod)==1) &#123; if(Alice&gt;Bod) score1=score1+3; else score2=score2+3; &#125; else if(abs(Alice-Bod)==4) &#123; if(Alice==1) score1=score1+3; else score2=score2+3; &#125; else &#123; score1++; score2++; &#125; &#125; if(score1&gt;score2) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl; else if(score1&lt;score2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Draw&quot;&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125;int getLevel(string s)&#123; if(s==&quot;Jin&quot;) return 5; if(s==&quot;Mu&quot;) return 4; if(s==&quot;Tu&quot;) return 3; if(s==&quot;Shui&quot;) return 2; else return 1;&#125; 小明在坐景驰科技研发的无人车到达了目的地。 景驰科技（JingChi.ai）是一家由人工智能技术驱动、以无人驾驶技术为核心的智能出行公司。它将打造面向中国市场的全无人驾驶。从无人车下来以后，小明看到了一个长长的楼梯。 有一个n级台阶的楼梯，小明一次可以向上跳1步，两步，甚至是n步，请问小明跳到n级台阶有多少种跳法？ My Code 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int f(int n)&#123; if(n==1) return 1; return 2*f(n-1);&#125;int main()&#123; int t,n; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; cout&lt;&lt;f(n)&lt;&lt;endl; &#125; return 0;&#125; 思路：f(0)=1 n=1，f(1)=1； n=2，第一步有两种跳法，分别为一次跳一步和一次跳两步。跳一步时，第二步有一种跳法，即f(1)；跳两步时，不用跳第二步，也就是有一种跳法f(0)。所以f(2)=f(1)+f(0)。 n=3，第一步有三种跳法，分别为1，2，3。跳一步时，第二步有f(2)种跳法；跳两步时，第二步有f(1)种跳法；跳三步时，第二步有f(0)种跳法。所以f(3)=f(2)+f(1)+f(0)，又因为f(2)=f(1)+f(0)，所以f(3)=2*f(2)。 推广到n时，f(n)=2*f(n-1)。 Question From：HERE Part11 3/15 点点是一名出色的狼人。众所周知，狼人只有在满月之夜才会变成狼。同时，月亮的大小随着时间变化，它的大小变化30天为一循环。它的变化情况(从第一天开始)为0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 然后又再一次循环。今年夏天点点很无聊，于是开始看月亮。由于点点很忙，所以他只选择一段连续的时间看月亮，并把月亮的大小记录了下来。现在，他告诉你他记录下东西，让你告诉他下一天(即点点记录下的最后一天的第二天)的月亮是比前一天(即点点记录下的最后一天)大还是小。 My Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std;int main()&#123; int n; while (cin &gt;&gt; n) &#123; if (n == 1) &#123; int a; cin &gt;&gt; a; if (a == 15) cout &lt;&lt; &quot;DOWN&quot; &lt;&lt; endl; else if (a == 0) cout &lt;&lt; &quot;UP&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; continue; &#125; else &#123; int a = 0, b = 0; int situation = 0; for (int i = 1; i &lt;= n; i++) &#123; if (i &lt; n - 1) &#123; int x; cin &gt;&gt; x; &#125; else &#123; if (i == n - 1) cin &gt;&gt; a; else if (i == n) &#123; cin &gt;&gt; b; if (a &gt; b) situation = -1; else situation = 1; &#125; &#125; &#125; if (b == 15) cout &lt;&lt; &quot;DOWN&quot; &lt;&lt; endl; else if (b == 0) cout &lt;&lt; &quot;UP&quot; &lt;&lt; endl; else if (situation == 1) cout &lt;&lt; &quot;UP&quot; &lt;&lt; endl; else if (situation == -1) cout &lt;&lt; &quot;DOWN&quot; &lt;&lt; endl; //0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1 &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 注意： n==0时不是全部不能判断； 只取输入的后两位时，前面还有n-2个数会输入。 Question From：HERE Part12 3/16 小明现在在玩一个游戏，游戏来到了教学关卡，迷宫是一个N*M的矩阵。小明的起点在地图中用“S”来表示，终点用“E”来表示，障碍物用“#”来表示，空地用“.”来表示。障碍物不能通过。小明如果现在在点（x，y）处，那么下一步只能走到相邻的四个格子中的某一个：（x+1，y），（x-1，y），（x，y+1），（x，y-1）；小明想要知道，现在他能否从起点走到终点。 Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,m;int f;int s,e;int vis[505][505];char a[505][505];int dir[][2]=&#123;&#123;-1,0&#125;, &#123;1 ,0&#125; , &#123;0,-1&#125; ,&#123;0,1&#125;&#125;;//方向 上 下 左 右void dfs(int x,int y)&#123; if(x==s&amp;&amp;y==e) &#123; f=1; &#125; for(int i=0;i&lt;4;i++) &#123; int xx=x+dir[i][0]; int yy=y+dir[i][1]; if(a[xx][yy]!=&#x27;#&#x27;&amp;&amp;!vis[xx][yy]&amp;&amp;xx&gt;=0&amp;&amp;xx&lt;n&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;m) &#123; vis[xx][yy]=1; dfs(xx,yy); &#125; &#125;&#125;int main()&#123; int sv,se; while(cin&gt;&gt;n&gt;&gt;m) &#123; f=0; memset(vis,0,sizeof(vis)); memset(a,0,sizeof(a)); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; scanf(&quot; %c&quot;,&amp;a[i][j]); if(a[i][j]==&#x27;S&#x27;)&#123;sv=i,se=j;&#125; if(a[i][j]==&#x27;E&#x27;)&#123;s=i,e=j;&#125; &#125; &#125; dfs(sv,se); if (f) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125; 深度优先算法DFS Question From：HERE 栗酱突发闲心，玩了一会儿仙剑。她玩的这个版本的仙剑非常简单，打架的时候，每次只有一个小怪，栗酱也只有一个主角，主角在每回合开始先攻击小怪，小怪有a点生命值，主角有b点生命值，小怪有c点攻击力，主角有d点攻击力，每次攻击都会造成确确实实的攻击力的伤害。生命值小于等于零时就会挂掉。栗酱发现好像战斗一开始就已经能知道结果了，请你帮她算一下，这样她就可以挂机去做更有趣的事了。数据保证攻击力和初始生命值均大于等于1。 My Code 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int main()&#123; int t; while (cin &gt;&gt; t) &#123; while (t--) &#123; int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; //cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; while (1) &#123; a = a - d; if (a &lt;= 0) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; break; &#125; b = b - c; if (b &lt;= 0) &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; break; &#125; //cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; &#125; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE Part13 3/19 My Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;bool cmp(pair&lt;int, int&gt;a, pair&lt;int, int&gt;b)&#123; return a.first&lt;b.first;//根据fisrt的值升序排序 //return a.second&lt;b.second;//根据second的值升序排序&#125;typedef pair&lt;int, int&gt; p;int main()&#123; int n,k; while(cin&gt;&gt;n&gt;&gt;k) &#123; //pair&lt;int,int&gt; dawn[1000010]; //pair&lt;int,int&gt; dusk[1000010]; p *dawn=new p[n+1]; p *dusk=new p[n+1]; for(int i=0;i&lt;n;i++)&#123; int x; cin&gt;&gt;x; dawn[i]=make_pair(x,i); //cin&gt;&gt;dawn[i].first; //dawn[i].second=i; &#125; sort(dawn,(dawn+n),cmp); for(int i=0;i&lt;n;i++)&#123; int x; cin&gt;&gt;x; dusk[i]=make_pair(x,i); //cin&gt;&gt;dusk[i].first; //dusk[i].second=i; &#125; sort(dusk,(dusk+n),cmp); int sweet=0; for(int i=0,index=n-1;i&lt;=k;i++,index--) &#123; int index1=dawn[index].second; int index2=dusk[index].second; int max1=dawn[index].first; int max2=dusk[index].first; if(index1==index2) &#123; if(max1&gt;=max2) &#123; sweet=sweet+max1; dawn[index1].first=0; dusk[index2].first=0; &#125; else &#123; sweet=sweet+max2; dawn[index1].first=0; dusk[index2].first=0; &#125; &#125; else &#123; sweet=sweet+max1+max2; dawn[index1].first=0; dusk[index1].first=0; dawn[index2].first=0; dusk[index2].first=0; &#125; //cout&lt;&lt;max1&lt;&lt;&quot; &quot;&lt;&lt;max2&lt;&lt;endl; //cout&lt;&lt;sweet&lt;&lt;endl; &#125; cout&lt;&lt;sweet&lt;&lt;endl; delete [] dawn; delete [] dusk; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：对甜度从小到大排序，每次取早上甜度的最大值和晚上甜度的最大值进行比较，分为块数相同和不同两种情况。若块数相同，则增加该块数的早晚甜度最大值；若块数不同，则增加这两个 思路错误，明天再更&gt;_&lt; Question From：HERE Part14 3/27 巴啦啦能量，沙鲁沙鲁，小魔仙大变身：对于一个数，把他所有位上的数字进行加和，得到新的数。 如果这个数字是个位数的话，那么他就满足条件。 My Code 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;typedef long long ll;ll solution(ll n);int main()&#123; ll n; while (cin &gt;&gt; n) &#123; int ans=solution(n); while(ans&gt;=10)&#123; ans=solution(ans); &#125; cout&lt;&lt;ans; &#125; system(&quot;pause&quot;); return 0;&#125;ll solution(ll n)&#123; int ans = 0; while (n / 10 != 0) &#123; ans = ans + n % 10; n = n / 10; &#125; ans = ans + n; return ans;&#125; Question From：HERE Forever97与未央是一对笔友，他们经常互相写信。有一天Forever97去邮局寄信，发现邮局的收费方式变成了按字收费，收取的费用为总字数除了其自身以外的最大因子。虽然Forever97是一个有情调的人，但他不想因新收费方式而破财，所以他打算把信分成几份寄出去来减少邮费。已知Forever97写的信共有n个字，可以拆成无数封信，也可以不拆，每封信最少为2个字。求Forever97最少需要付多少邮费？ My Code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;bool isPrime(int n);int main()&#123; int t; while(cin&gt;&gt;t) &#123; while(t--) &#123; int n; cin&gt;&gt;n; if(isPrime(n)) cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; else if(n%2==0) cout&lt;&lt;&quot;2&quot;&lt;&lt;endl; else if(isPrime(n-2)) cout&lt;&lt;&quot;2&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;3&quot;&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125;// bool isPrime(int n)// &#123;// for(int i=2;i&lt;=n/2+1;i++)// &#123;// if(n%i==0) return false;// &#125;// return true;// &#125;bool isPrime(int x)//判断是不是是素数&#123; int l=sqrt(x*1.0); for(int i=2;i&lt;=l;i++) &#123; if(x%i==0) return 0; &#125; return 1;&#125; 思路：找到n可以被分为最少几个质数； 需要注意的是 不是所有合数都能分成两个质数的和，例如27、35、51等奇合数； 大于2的偶数都可以表示为两个质数的和。 所以，这道题一共只有三种输出：1，2和3。 注意：在使用函数判断一个数是否为质数时，在for循环中只需循环至根号n即可。 Question From：HERE Points C++对double类型取余 123456789101112131415161718192021222324include &lt;math.h&gt;double a,b;fmod(double a,double b);//a对b取余modf(double a,double *b);//将参数的整数部分通过指针回传，返回小数部分//Example#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; double a = 12.4, b = 3; double c=0; cout &lt;&lt; fmod(a, b) &lt;&lt; endl &lt;&lt; modf(a, &amp;c) &lt;&lt; endl &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;/*输出：0.40.412*/ C++ max_element find max 深度优先算法DFS","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"CodeExercise","slug":"CodeExercise","permalink":"https://cheeseburgerim.github.io/tags/CodeExercise/"},{"name":"Exercise","slug":"Exercise","permalink":"https://cheeseburgerim.github.io/tags/Exercise/"},{"name":"Practice","slug":"Practice","permalink":"https://cheeseburgerim.github.io/tags/Practice/"},{"name":"NOWCODER","slug":"NOWCODER","permalink":"https://cheeseburgerim.github.io/tags/NOWCODER/"},{"name":"Daily","slug":"Daily","permalink":"https://cheeseburgerim.github.io/tags/Daily/"}]},{"title":"Course-js","slug":"Course-js","date":"2021-02-26T02:07:24.000Z","updated":"2021-03-22T15:25:57.569Z","comments":false,"path":"2021/02/26/Course-js/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/26/Course-js/","excerpt":"","text":"","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Website","slug":"Website","permalink":"https://cheeseburgerim.github.io/tags/Website/"},{"name":"Design","slug":"Design","permalink":"https://cheeseburgerim.github.io/tags/Design/"},{"name":"js","slug":"js","permalink":"https://cheeseburgerim.github.io/tags/js/"}]},{"title":"NOWCODER-2021/2","slug":"CodeExercise/NOWCODER-2021-2","date":"2021-02-24T01:45:50.000Z","updated":"2021-03-29T13:59:31.405Z","comments":false,"path":"2021/02/24/CodeExercise/NOWCODER-2021-2/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/24/CodeExercise/NOWCODER-2021-2/","excerpt":"","text":"Part1 2/23 1有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ My Code 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; int ans=0; while(n&gt;0) &#123; if(n==1) &#123; break; &#125; else if(n==2) &#123; n=n-2; ans++; break; &#125; else//n&gt;=3 &#123; int temp=n/3; ans=ans+temp; n=n%3+temp;; &#125; &#125; if(ans&gt;0) cout&lt;&lt;ans&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; 此解法过于复杂； 通过数学分析，最后获得的饮料总数是总空瓶数整除2； 则有下代码 1234567#include&lt;stdio.h&gt;int main ()&#123; int m; while(~scanf(&quot;%d&quot;,&amp;m)&amp;&amp;m!=0) printf(&quot;%d\\n&quot;,m/2); return 0;&#125; 2明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 My Code 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; int Arr[1010]=&#123;0&#125;; int If[1010]=&#123;0&#125;; for(int i=0;i&lt;n;i++) &#123; int x; cin&gt;&gt;x; if(If[x]) continue; If[x]=1; Arr[i]=x; &#125; sort(Arr,Arr+n); for(int i=0;i&lt;n;i++) &#123; if(Arr[i]==0) continue; cout&lt;&lt;Arr[i]&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：输入n个数，重复时不输入，最后排序，按从小到大的顺序输出正数； 题解思路：声明一个足够大的数组，当输入的数为i时，令数组第i为置1；for循环输出，当数组该位为1时，输出位数； 代码如下 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int N, n; while (cin &gt;&gt; N) &#123; int a[1001] = &#123; 0 &#125;; while (N--) &#123; cin &gt;&gt; n; a[n] = 1; &#125; for (int i = 0; i &lt; 1001; i++) if (a[i]) cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 3写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。 My Code 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; char str[100]; while(cin&gt;&gt;str) &#123; int ans=strtol(str,NULL,16); cout&lt;&lt;ans&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; C++可以规定输入进制数，不需要调用strtol函数； 代码如下 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;hex&gt;&gt;n) &#123; cout&lt;&lt;n&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE Part2 2/24 输入一个链表，反转链表后，输出新链表的表头。 My Code 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;ListNode* ReverseList(ListNode* pHead);int main()&#123; system(&quot;pause&quot;); return 0;&#125;ListNode* ReverseList(ListNode* pHead)&#123; if(pHead==NULL) &#123; return NULL; &#125; ListNode *Pre=NULL; ListNode *Next=NULL; while(pHead!=NULL) &#123; Next=pHead-&gt;next; pHead-&gt;next=Pre; Pre=pHead; pHead=Next; &#125; return Pre;&#125; 思路1：从头到尾遍历，新建反转链表，不过会浪费一些空间； 思路2(以上代码思路)：将pHead指针逐个后移，再通过Pre以及Next指针将原指针反转，最后返回链表头指针； Question From：HERE 给定一个数组，请你编写一个函数，返回该数组排序后的形式。 12345678vector&lt;int&gt; MySort(vector&lt;int&gt;&amp; arr) &#123; // write code here //sort(arr.begin(),arr.end()); //sort(begin(arr),end(arr)); //sort(arr.begin(),arr.end(),less&lt;int&gt;()); sort(begin(arr),end(arr),less&lt;int&gt;()); return arr;&#125; 通过begin和end函数找到数组的起始位置和结束位置； Question From：HERE Part3 2/25 1老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩. My Code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; int Grade[30010]=&#123;0&#125;; for(int i=1;i&lt;=n;i++) &#123; int temp; cin&gt;&gt;temp; Grade[i]=temp; &#125; while(m--) &#123; char c; int a,b; cin&gt;&gt;c&gt;&gt;a&gt;&gt;b; if(c==&#x27;Q&#x27;) &#123; if(a&gt;b) &#123; int temp=b; b=a; a=temp; &#125; int max=0; for(int i=a;i&lt;=b;i++) &#123; if(Grade[i]&gt;max) max=Grade[i]; &#125; cout&lt;&lt;max&lt;&lt;endl; &#125; else if(c==&#x27;U&#x27;) &#123; Grade[a]=b; &#125; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 这道题没什么难度，唯一需要注意的是当输入字符为Q时，可能会有a&gt;b的情况 2开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。 处理: 1.记录最多8条错误记录，对相同的错误记录(即文件名称和行号完全匹配)只记录一条，错误计数增加；(文件所在的目录不同，文件名和行号相同也要合并) 2.超过16个字符的文件名称，只记录文件的最后有效16个字符；(如果文件名不同，而只是文件名的后16个字符和行号相同，也不要合并) 3.输入的文件可能带路径，记录文件名称不能带路径 My Code A Little Bit Hard 3扑克牌游戏大家应该都比较熟悉了，一副牌由54张组成，含3~A，2各4张，小王1张，大王1张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）😃 3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER 输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如：4 4 4 4-joker JOKER 请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR My Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int getType(string str,int l);int main()&#123; string str; while(getline(cin,str)) &#123; int index=str.find(&#x27;-&#x27;); string left=str.substr(0,index); string right=str.substr(index+1,str.length()); string Card=&quot;12345678910JQKA2jokerJOKER&quot;; //Type of left and right //Type: 1Single; 2Pair; 3Trible; 4joker; 5JOKER; // 6Sequence; 7bomb; 8KingBomb int ll=left.length(); int rl=right.length(); int typeOfLeft=getType(left,ll),typeOfRight=getType(right,rl); //Solve the Problem if(typeOfLeft&lt;=6&amp;&amp;typeOfRight&lt;=6&amp;&amp;typeOfLeft!=typeOfRight) cout&lt;&lt;&quot;ERROR&quot;&lt;&lt;endl; else if(typeOfLeft==8) cout&lt;&lt;left&lt;&lt;endl; else if(typeOfRight==8) cout&lt;&lt;right&lt;&lt;endl; else if(typeOfLeft==7&amp;&amp;typeOfRight==7) &#123; int indexLeftSpace=left.find(&#x27; &#x27;),indexRightSpace=right.find(&#x27; &#x27;); string tl=left.substr(0,indexLeftSpace),tr=right.substr(0,indexRightSpace); //cout&lt;&lt;tl&lt;&lt;&quot; &quot;&lt;&lt;tr&lt;&lt;endl; int indexl=Card.find(tl),indexr=Card.find(tr); if(indexl&gt;indexr) cout&lt;&lt;left&lt;&lt;endl; else if(indexl&lt;indexr) cout&lt;&lt;right&lt;&lt;endl; else cout&lt;&lt;&quot;ERROR&quot;&lt;&lt;endl; &#125; else if(typeOfLeft==7) cout&lt;&lt;left&lt;&lt;endl; else if(typeOfRight==7) cout&lt;&lt;right&lt;&lt;endl; else if(typeOfLeft==5) cout&lt;&lt;left&lt;&lt;endl; else if(typeOfRight==5) cout&lt;&lt;right&lt;&lt;endl; else if(typeOfLeft==4) cout&lt;&lt;left&lt;&lt;endl; else if(typeOfRight==4) cout&lt;&lt;right&lt;&lt;endl; else &#123; int indexLeftSpace=left.find(&#x27; &#x27;),indexRightSpace=right.find(&#x27; &#x27;); string tl=left.substr(0,indexLeftSpace),tr=right.substr(0,indexRightSpace); int indexl=Card.find(tl),indexr=Card.find(tr); if(indexl&gt;indexr) cout&lt;&lt;left&lt;&lt;endl; else if(indexl&lt;indexr) cout&lt;&lt;right&lt;&lt;endl; else cout&lt;&lt;&quot;ERROR&quot;&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125;int getType(string str,int l)&#123; int numOfSpace=0; for(int i=0;i&lt;l;i++) &#123; if(str[i]==&#x27; &#x27;) numOfSpace++; &#125; if(str==&quot;joker&quot;) return 4; else if(str==&quot;JOKER&quot;) return 5; else if(str==&quot;joker JOKER&quot;||str==&quot;JOKER joker&quot;) return 8; else if(l&lt;=2) return 1; else if(numOfSpace==1) return 2; else if(numOfSpace==2) return 3; else if(numOfSpace==3) return 7; else return 6;&#125; 思路 找到输入字符串‘-’的位置； 在该位置将字符串分成left，right两个字串； 分别判断出两个字串的类型； 比较大小； 问题的解。 Question From：HERE Part4 2/27 1写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000） My Code 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string Reverse(string str);int main()&#123; string s; while(cin&gt;&gt;s) &#123; cout&lt;&lt;Reverse(s)&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125;string Reverse(string str)&#123; reverse(str.begin(),str.end()); return str;&#125; 函数：直接调用&lt; algorithm&gt;头文件中的reverse函数； Question From：HERE 2大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。 My Code 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int Fibonacci(int n);int main()&#123; int n; while(cin&gt;&gt;n) &#123; cout&lt;&lt;Fibonacci(n)&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125;int Fibonacci(int n)&#123; if(n==0) return 0; else if(n==1) return 1; else if(n==2) return 1; else return Fibonacci(n-1)+Fibonacci(n-2);&#125; Question From：HERE 3给定一个字符串，请编写一个函数判断该字符串是否回文。如果回文请返回true，否则返回false。 My Code 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool judge(string str);int main()&#123; string s; while(cin&gt;&gt;s) &#123; if(judge(s)) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125;bool judge(string str)&#123; int l=str.length(); int mid=l/2; if(l%2==0)//even &#123; for(int i=0,j=l-1;i&lt;=mid;i++,j--) &#123; if(str[i]!=str[j]) return false; else return true; &#125; &#125; else//odd &#123; for(int i=0,j=l-1;i&lt;mid;i++,j--) &#123; if(str[i]!=str[j]) return false; &#125; return true; &#125;&#125; Question From：HERE 4山峰元素是指其值大于或等于左右相邻值的元素。给定一个输入数组nums，任意两个相邻元素值不相等，数组可能包含多个山峰。找到索引最大的那个山峰元素并返回其索引。 My Code 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int peak(int* a,int aLen);int main()&#123; system(&quot;pause&quot;); return 0;&#125;int peak(int* a,int aLen)&#123; for(int i=aLen-1;i&gt;=0;i--) &#123; if(i==aLen-1) &#123; if(a[i]&gt;a[i-1]) return i; &#125; else &#123; if(a[i]&gt;a[i-1]&amp;&amp;a[i]&gt;a[i+1]) return i; &#125; &#125; return 0;&#125; 这道题很简单，不过以上代码还有可以简化的地方； 将条件设为a[i]&gt;a[i-1]，好处为：如果循环到第i位，说明a[i+1]&lt;a[i]，所以下次不需要再次判断a[i+1]和a[i]的关系； 答案代码如下 12345678int solve(int* a, int aLen) &#123; // write code here for(int i=aLen-1;i;i--) &#123; if(a[i]&gt;a[i-1])return i; &#125; return 0;&#125; Question From：HERE Points C++可以规定输入进制数 123//Example 16int x;cin&gt;&gt;hex&gt;&gt;x; 数组函数 begin end 123456int Arr[]=&#123;1,2,3,......,n&#125;//random numberbegin(Arr)-&gt;1;end(Arr)-&gt;n//convenient when needed to be sorted#include &lt;algorithm&gt;sort(begin(Arr),end(Arr)); C++中输入反斜杠’’ 12345678/*在C++编程中有时候会遇到有些符号不能直接输入，像反斜杠&#x27;\\&#x27;，如果直接输入会出现：错误的终止了宏调用的错误，这时我们就需要把这些符号转义一下For Example */#include &lt;string&gt;string str=&#x27;\\&#x27;;//Wrong!string str=&#x27;\\\\&#x27;;//Correct!//使用转义字符&#x27;\\\\&#x27;，这样其实输入的还是&#x27;\\&#x27;// C++ Pair结构 C++ reverse函数 1234#include &lt;algorithm&gt;#include &lt;string&gt;string str=&quot;abcd&quot;;reverse(str.begin(),str.end()); C++ vector结构","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"CodeExercise","slug":"CodeExercise","permalink":"https://cheeseburgerim.github.io/tags/CodeExercise/"},{"name":"Exercise","slug":"Exercise","permalink":"https://cheeseburgerim.github.io/tags/Exercise/"},{"name":"Practice","slug":"Practice","permalink":"https://cheeseburgerim.github.io/tags/Practice/"},{"name":"NOWCODER","slug":"NOWCODER","permalink":"https://cheeseburgerim.github.io/tags/NOWCODER/"},{"name":"Daily","slug":"Daily","permalink":"https://cheeseburgerim.github.io/tags/Daily/"}]},{"title":"To The Moon","slug":"Game/To-The-Moon","date":"2021-02-23T01:25:13.000Z","updated":"2021-05-11T05:29:39.110Z","comments":false,"path":"2021/02/23/Game/To-The-Moon/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/23/Game/To-The-Moon/","excerpt":"","text":"","categories":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"}],"tags":[{"name":"Fun","slug":"Fun","permalink":"https://cheeseburgerim.github.io/tags/Fun/"},{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"To The Moon","slug":"To-The-Moon","permalink":"https://cheeseburgerim.github.io/tags/To-The-Moon/"}]},{"title":"Course-css","slug":"Course-css","date":"2021-02-22T05:44:24.000Z","updated":"2021-03-22T15:25:44.942Z","comments":false,"path":"2021/02/22/Course-css/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/22/Course-css/","excerpt":"","text":"","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Website","slug":"Website","permalink":"https://cheeseburgerim.github.io/tags/Website/"},{"name":"Design","slug":"Design","permalink":"https://cheeseburgerim.github.io/tags/Design/"},{"name":"css","slug":"css","permalink":"https://cheeseburgerim.github.io/tags/css/"}]},{"title":"Markdown技巧——标签外挂","slug":"ExternalTag","date":"2021-02-20T10:24:39.000Z","updated":"2021-05-11T09:05:38.038Z","comments":false,"path":"2021/02/20/ExternalTag/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/20/ExternalTag/","excerpt":"","text":"Button Inline 12This is my website, click the button &#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM %&#125;This is my website, click the button &#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,,outline%&#125; This is my website, click the button CheeseburgerIM This is my website, click the button CheeseburgerIM Option More than one button in center 123456789&lt;div class=&quot;btn-center&quot;&gt;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,blue larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,pink larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,red larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,purple larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,orange larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,green larger %&#125;&lt;/div&gt; CheeseburgerIM CheeseburgerIM CheeseburgerIM CheeseburgerIM CheeseburgerIM CheeseburgerIM CheeseburgerIM 123456789&lt;div class=&quot;btn-center&quot;&gt;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,outline larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,outline blue larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,outline pink larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,outline red larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,outline purple larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,outline orange larger %&#125;&#123;% btn &#x27;https://cheeseburgerim.github.io/&#x27;,CheeseburgerIM,far fa-hand-point-right,outline green larger %&#125;&lt;/div&gt; CheeseburgerIM CheeseburgerIM CheeseburgerIM CheeseburgerIM CheeseburgerIM CheeseburgerIM CheeseburgerIM Note 方法一 Simple 123456789101112131415161718192021222324252627&#123;% note simple %&#125;默认 提示块标籤&#123;% endnote %&#125;&#123;% note default simple %&#125;default 提示块标籤&#123;% endnote %&#125;&#123;% note primary simple %&#125;primary 提示块标籤&#123;% endnote %&#125;&#123;% note success simple %&#125;success 提示块标籤&#123;% endnote %&#125;&#123;% note info simple %&#125;info 提示块标籤&#123;% endnote %&#125;&#123;% note warning simple %&#125;warning 提示块标籤&#123;% endnote %&#125;&#123;% note danger simple %&#125;danger 提示块标籤&#123;% endnote %&#125; 默认 提示块标籤 default 提示块标籤 primary 提示块标籤 success 提示块标籤 info 提示块标籤 warning 提示块标籤 danger 提示块标籤 Modern 123456789101112131415161718192021222324252627&#123;% note modern %&#125;默认 提示块标籤&#123;% endnote %&#125;&#123;% note default modern %&#125;default 提示块标籤&#123;% endnote %&#125;&#123;% note primary modern %&#125;primary 提示块标籤&#123;% endnote %&#125;&#123;% note success modern %&#125;success 提示块标籤&#123;% endnote %&#125;&#123;% note info modern %&#125;info 提示块标籤&#123;% endnote %&#125;&#123;% note warning modern %&#125;warning 提示块标籤&#123;% endnote %&#125;&#123;% note danger modern %&#125;danger 提示块标籤&#123;% endnote %&#125; 默认 提示块标籤 default 提示块标籤 primary 提示块标籤 success 提示块标籤 info 提示块标籤 warning 提示块标籤 danger 提示块标籤 Flat 123456789101112131415161718192021222324252627&#123;% note flat %&#125;默认 提示块标籤&#123;% endnote %&#125;&#123;% note default flat %&#125;default 提示块标籤&#123;% endnote %&#125;&#123;% note primary flat %&#125;primary 提示块标籤&#123;% endnote %&#125;&#123;% note success flat %&#125;success 提示块标籤&#123;% endnote %&#125;&#123;% note info flat %&#125;info 提示块标籤&#123;% endnote %&#125;&#123;% note warning flat %&#125;warning 提示块标籤&#123;% endnote %&#125;&#123;% note danger flat %&#125;danger 提示块标籤&#123;% endnote %&#125; 默认 提示块标籤 default 提示块标籤 primary 提示块标籤 success 提示块标籤 info 提示块标籤 warning 提示块标籤 danger 提示块标籤 Disabled 123456789101112131415161718192021222324252627&#123;% note disabled %&#125;默认 提示块标籤&#123;% endnote %&#125;&#123;% note default disabled %&#125;default 提示块标籤&#123;% endnote %&#125;&#123;% note primary disabled %&#125;primary 提示块标籤&#123;% endnote %&#125;&#123;% note success disabled %&#125;success 提示块标籤&#123;% endnote %&#125;&#123;% note info disabled %&#125;info 提示块标籤&#123;% endnote %&#125;&#123;% note warning disabled %&#125;warning 提示块标籤&#123;% endnote %&#125;&#123;% note danger disabled %&#125;danger 提示块标籤&#123;% endnote %&#125; 默认 提示块标籤 default 提示块标籤 primary 提示块标籤 success 提示块标籤 info 提示块标籤 warning 提示块标籤 danger 提示块标籤 No-icon 123456789101112131415161718192021222324252627&#123;% note no-icon %&#125;默认 提示块标籤&#123;% endnote %&#125;&#123;% note default no-icon %&#125;default 提示块标籤&#123;% endnote %&#125;&#123;% note primary no-icon %&#125;primary 提示块标籤&#123;% endnote %&#125;&#123;% note success no-icon %&#125;success 提示块标籤&#123;% endnote %&#125;&#123;% note info no-icon %&#125;info 提示块标籤&#123;% endnote %&#125;&#123;% note warning no-icon %&#125;warning 提示块标籤&#123;% endnote %&#125;&#123;% note danger no-icon %&#125;danger 提示块标籤&#123;% endnote %&#125; 默认 提示块标籤 default 提示块标籤 primary 提示块标籤 success 提示块标籤 info 提示块标籤 warning 提示块标籤 danger 提示块标籤 方法二 Simple 123456789101112131415161718192021&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125; 你是刷 Visa 还是 UnionPay 2021年快到了… 小心开车 安全至上 这是三片呢？还是四片？ 你是刷 Visa 还是 UnionPay 剪刀石头布 前端最讨厌的浏览器 Modern 123456789101112131415161718192021&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125; 你是刷 Visa 还是 UnionPay 2021年快到了… 小心开车 安全至上 这是三片呢？还是四片？ 你是刷 Visa 还是 UnionPay 剪刀石头布 前端最讨厌的浏览器 Flat 123456789101112131415161718192021&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125; 你是刷 Visa 还是 UnionPay 2021年快到了… 小心开车 安全至上 这是三片呢？还是四片？ 你是刷 Visa 还是 UnionPay 剪刀石头布 前端最讨厌的浏览器 Disabled 123456789101112131415161718192021&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125; 你是刷 Visa 还是 UnionPay 2021年快到了… 小心开车 安全至上 这是三片呢？还是四片？ 你是刷 Visa 还是 UnionPay 剪刀石头布 前端最讨厌的浏览器 No-icon 123456789101112131415161718192021&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125; 你是刷 Visa 还是 UnionPay 2021年快到了… 小心开车 安全至上 这是三片呢？还是四片？ 你是刷 Visa 还是 UnionPay 剪刀石头布 前端最讨厌的浏览器 Pull Quote To add pull quotes to your posts 123&#123;% pullquote [class] %&#125;content&#123;% endpullquote %&#125; Left 123&#123;% pullquote left %&#125;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#123;% endpullquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. 。。。 。。。 。。。 Right 123&#123;% pullquote right %&#125;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#123;% endpullquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. 。。。 。。。 。。。 iframe 1234567&lt;!--Format--&gt;&#123;% iframe url [width] [height] %&#125;&lt;!--Example--&gt;&#123;% iframe &#x27;https://CheeseburgerIM.github.io&#x27; 100% 300px %&#125;&lt;!--CheeseburgerIM.github.io--&gt;&#123;% iframe &#x27;https://CheeseburgerIM.github.io&#x27; 100% 500px %&#125;&#123;% iframe &#x27;https://CheeseburgerIM.github.io&#x27; 100% 650px %&#125; Tag-hide Inline inline 在文本里面添加按钮隐藏内容，只限文字 ( content不能包含英文逗号，可用‚) 1&#123;% hideInline content,display,bg,color %&#125; content: 文本内容 display: 按钮显示的文字(可选) bg: 按钮的背景颜色(可选) color: 按钮文字的颜色(可选) Example 123哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;门里站着一个人? &#123;% hideInline 闪 %&#125; 哪个英文字母最酷？ 查看答案 因为西装裤(C装酷) 门里站着一个人? Click 闪 Block block 独立的block隐藏内容，可以隐藏很多内容，包括图片，代码块等等 ( display 不能包含英文逗号，可用‚) content: 文本内容 display: 按钮显示的文字(可选) bg: 按钮的背景颜色(可选) color: 按钮文字的颜色(可选) Example 1234查看答案&#123;% hideBlock 查看答案 %&#125;傻子，怎么可能有答案&#123;% endhideBlock %&#125; 查看答案 查看答案 傻子，怎么可能有答案 Tabs 123456789101112131415161718192021&#123;% tabs Unique name, [index] %&#125;&lt;!-- tab [Tab caption] [@icon] --&gt;Any content (support inline tags too).&lt;!-- endtab --&gt;&#123;% endtabs %&#125;Unique name : Unique name of tabs block tag without comma. Will be used in #id&#x27;s as prefix for each tab with their index numbers. If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes. Only for current url of post/page must be unique![index] : Index number of active tab. If not specified, first tab (1) will be selected. If index is -1, no tab will be selected. It&#x27;s will be something like spoiler. Optional parameter.[Tab caption] : Caption of current tab. If not caption specified, unique name with tab index suffix will be used as caption of tab. If not caption specified, but specified icon, caption will empty. Optional parameter.[@icon] : FontAwesome icon name (full-name, look like &#x27;fas fa-font&#x27;) Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;. Optional parameter. Demo 1 - 预设选择第一个默认 12345678910111213&#123;% tabs test1 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; test1 1test1 2test1 3This is Tab 1.This is Tab 2.This is Tab 3. Demo 2 - 预设选择tabs 12345678910111213&#123;% tabs test2, 3 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; test2 1test2 2test2 3This is Tab 1.This is Tab 2.This is Tab 3. Demo 3 - 没有预设值 12345678910111213&#123;% tabs test3, -1 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; test3 1test3 2test3 3This is Tab 1.This is Tab 2.This is Tab 3. Demo 4 - 自定义Tab名+只有icon+icon和Tab名 12345678910111213&#123;% tabs test4 %&#125;&lt;!-- tab 第一个Tab --&gt;**tab名字为第一个Tab**&lt;!-- endtab --&gt;&lt;!-- tab @fab fa-apple-pay --&gt;**只有图标 没有Tab名字**&lt;!-- endtab --&gt;&lt;!-- tab 炸弹@fas fa-bomb --&gt;**名字+icon**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 第一个Tab炸弹tab名字为第一个Tab只有图标 没有Tab名字名字+icon 文章转自Jerry","categories":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/categories/Course/"}],"tags":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"Hexo","slug":"Hexo","permalink":"https://cheeseburgerim.github.io/tags/Hexo/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Markdown","slug":"Markdown","permalink":"https://cheeseburgerim.github.io/tags/Markdown/"},{"name":"Blog","slug":"Blog","permalink":"https://cheeseburgerim.github.io/tags/Blog/"},{"name":"ExternalTag","slug":"ExternalTag","permalink":"https://cheeseburgerim.github.io/tags/ExternalTag/"}]},{"title":"Chapter5 优化程序性能","slug":"DUOCS/DUOCS-Chapter5","date":"2021-02-19T02:09:23.000Z","updated":"2021-06-07T10:49:39.815Z","comments":false,"path":"2021/02/19/DUOCS/DUOCS-Chapter5/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/19/DUOCS/DUOCS-Chapter5/","excerpt":"","text":"优化编译器的能力和局限性 表示程序性能 程序示例 消除循环的低效率 减少过程调用 消除不必要的存储器引用 理解现代处理器 降低循环开销 转换到指针代码 提高并行性 综合：优化合并(Combing)代码的效果小结 分支预测和预测错误处罚 理解存储器性能 现实生活：性能提高技术 确认和消除性能瓶颈 小结","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"DUOCS","slug":"DUOCS","permalink":"https://cheeseburgerim.github.io/tags/DUOCS/"}]},{"title":"Course for HTML","slug":"Course-html","date":"2021-02-17T13:10:46.000Z","updated":"2021-03-31T12:34:54.614Z","comments":false,"path":"2021/02/17/Course-html/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/17/Course-html/","excerpt":"","text":"教程 超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言； 可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析； HTML实例 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; **注意：**对于中文网页需要使用&lt; meta charset=“utf-8”&gt;生命编码，否则会出现乱码。有些浏览器(如360浏览器)会设置GBK为默认编码，则需要设置为&lt; meta charset=“gbk”&gt; Have A Try Examples for HTML 文档的后缀名 .html .htm 以上两种后缀名没有区别，都可以使用 参考手册 Reference HTML/CSS/JS在线工具 HTML/CSS/JS Online 简介 HTML实例 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 实例解析 &lt; !DOCTYPE html&gt; 声明为 HTML5 文档； &lt; html&gt; 元素是 HTML 页面的根元素； &lt; head&gt; 元素包含了文档的元（meta）数据，如 &lt; meta charset=“utf-8”&gt; 定义网页编码格式为 utf-8； &lt; title&gt; 元素描述了文档的标题； &lt; body&gt; 元素包含了可见的页面内容； &lt; h1&gt; 元素定义一个大标题； &lt; p&gt; 元素定义一个段落。 什么是HTML？ HTML是用来描述网页的一种语言 HTML 指的是超文本标记语言: HyperText Markup Language； HTML 不是一种编程语言，而是一种标记语言； 标记语言是一套标记标签 (markup tag)； HTML 使用标记标签来描述网页； HTML 文档包含了HTML 标签及文本内容； HTML文档也叫做 web 页面。 标签 HTML标记标签通常被称为HTML标签(HTML tag) HTML 标签是由尖括号包围的关键词，比如 &lt; html&gt;; HTML 标签通常是成对出现的，比如 &lt; b&gt;和&lt; /b&gt;; 标签对中的第一个标签是开始标签，第二个标签是结束标签； 开始和结束标签也被称为开放标签和闭合标签。 &lt;标签&gt;内容&lt;/标签&gt; 元素 “HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思； 但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例 HTML元素： &lt; p&gt;这是一个段落。&lt; /p&gt; Web浏览器 Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示; 浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户 网页结构 下面是一个可视化的HTML页面结构 &lt;html&gt; &lt;head&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 只有&lt; body&gt;区域才会在浏览器中显示 版本 从初期的网络诞生后，已经出现了许多HTML版本: 版本 发布时间 HTML 1991 HTML+ 1993 HTML 2.0 1995 HTML 3.2 1997 HTML 4.01 1999 XHTML 1.0 2000 HTML5 2012 XHTML5 2013 &lt; !DOCTYPE&gt;声明有助于浏览器中正确显示网页； 网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容； doctype 声明是不区分大小写的，以下方式均可 &lt;!DOCTYPE html&gt; &lt;!DOCTYPE HTML&gt; &lt;!doctype html&gt; &lt;!Doctype Html&gt; 基础 标题 HTML 标题（Heading）是通过&lt; h1&gt; - &lt; h6&gt; 标签来定义的。 123&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;h2&gt;这是一个标题&lt;/h2&gt;&lt;h3&gt;这是一个标题&lt;/h3&gt; 段落 HTML 段落是通过标签 &lt; p&gt; 来定义的。 12&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;p&gt;这是另外一个段落。&lt;/p&gt; 链接 HTML 链接是通过标签 &lt; a&gt; 来定义的。 提示：在href属性中指定链接的地址。 1&lt;a href=&quot;https://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt; 图像 HTML 图像是通过标签 &lt; img&gt; 来定义的。 注意：图像的名称和尺寸是以属性的形式提供的。 1&lt;img loading=&quot;lazy&quot; src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt; 元素 开始标签 元素内容 结束标签 &lt; p&gt; 这是一个段落 &lt; /p&gt; &lt; a href=“default.htm”&gt; 这是一个链接 &lt; /a&gt; &lt; br&gt; 换行 开始标签常被称为起始标签(opening tag)，结束标签常被称为闭合标签(closing tag) 元素语法 HTML 元素以开始标签起始 HTML 元素以结束标签终止 元素的内容是开始标签与结束标签之间的内容 某些 HTML 元素具有空内容（empty content） 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数 HTML 元素可拥有属性 嵌套的HTML元素 大多数HTML元素可以嵌套(HTML元素可以包含其他HTML元素)； HTML文档由相互嵌套的HTML元素构成。 HTML空元素 没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。 &lt; br&gt; 就是没有关闭标签的空元素（&lt; br&gt; 标签定义换行）。 在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。 在开始标签中添加斜杠，比如 &lt; br /&gt;，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。 即使 &lt; br&gt; 在所有浏览器中都是有效的，但使用 &lt; br /&gt; 其实是更长远的保障。 HTML提示：使用小写标签 HTML 标签对大小写不敏感：&lt; P&gt; 等同于 &lt; p&gt;。许多网站都使用大写的 HTML 标签。 菜鸟教程使用的是小写标签，因为万维网联盟（W3C）在 HTML 4 中推荐使用小写，而在未来 (X)HTML 版本中强制使用小写。 注：本文章转自菜鸟教程 Points 换行&lt; br&gt;； 上划线overline 1&lt;font style=&quot;text-decoration: overline;&quot;&gt;X&lt;/font&gt; 斜体 1&lt;i&gt;斜体&lt;/i&gt;","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"html","slug":"html","permalink":"https://cheeseburgerim.github.io/tags/html/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Website","slug":"Website","permalink":"https://cheeseburgerim.github.io/tags/Website/"},{"name":"Design","slug":"Design","permalink":"https://cheeseburgerim.github.io/tags/Design/"}]},{"title":"Chapter4 处理器体系结构","slug":"DUOCS/DUOCS-Chapter4","date":"2021-02-16T02:06:09.000Z","updated":"2021-06-07T10:49:32.613Z","comments":false,"path":"2021/02/16/DUOCS/DUOCS-Chapter4/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/16/DUOCS/DUOCS-Chapter4/","excerpt":"","text":"Y86指令集体系结构 逻辑设计和硬件控制语言HCL Y86的顺序(sequential)实现 流水线的通用原理 Y86的流水线实现 小结","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"DUOCS","slug":"DUOCS","permalink":"https://cheeseburgerim.github.io/tags/DUOCS/"}]},{"title":"Hexo博客添加自定义HTML页面","slug":"BUPWBP","date":"2021-02-12T12:43:04.000Z","updated":"2021-05-11T05:19:17.595Z","comments":false,"path":"2021/02/12/BUPWBP/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/12/BUPWBP/","excerpt":"","text":"Build up pages without being polished Steps 新建页面或文章 跳过渲染 添加并修改html文件 新建页面或文章 1234//Post$ hexo new post &quot;Post Name&quot;//Page$ hexo new page Page Name 跳过渲染 在博客根目录的配置文件_config.yml文件里，跳过渲染 找到 skip_render: 123456789# 跳过文件夹下所有文件skip_render: - &quot;filename/*&quot;# 跳过文件夹下的子文件夹skip_render: - &quot;filename/subfilename/*&quot;# 跳过文件夹下所有文件夹和文件skip_render: - &quot;filename/**&quot; 添加并修改html文件 最后，处理css、js文件 我们都知道，hexo部署的是静态文件，所有文章的md文件会被渲染成html文件(hexo g生成)，hexo会帮我们把所有的css、js文件都加到文章里，我们之前跳过了渲染(第二步)，所以就需要手动把css、js整合到html文件里，一般我们的代码是这种结构 或 下面分为两部分 css 找到index.html文件里的语句，例如 12&lt;link rel=&quot;stylesheet&quot; href=&quot;css/xxx.css&quot;&gt;&lt;!-- css目录下的xxx.css文件 --&gt; 直接在css文件夹里面找到对应的文件xxx.css，复制文件内容，把上面的代码改写为 1&lt;style&gt; css代码内容 &lt;/style&gt; js 找到index.html文件里的语句，例如 1&lt;script src=&quot;js/xxx.js&quot;&gt;&lt;/script&gt; 直接在js文件夹里面找到对应的xxx.js，复制文件内容，把上面的代码改为 1&lt;script&gt; js代码内容 &lt;/script&gt; 重新部署即可 From： https://blog.csdn.net/qq_40922859/article/details/100877777 示例 Proof That Tony Stark Has A Heart hexo new page IronMan 跳过渲染 12skip_render: - &quot;IronMan/**&quot; 添加并修改html文件 源码来自Here Author：阿阳热爱前端 并按上述方法整合css或js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;HTML+CSS 钢铁侠心脏反应堆&lt;/title&gt; &lt;style&gt; * &#123; /* 初始化 清除页面元素的内外边距 */ padding: 0; margin: 0;&#125;body &#123; /* 弹性布局 让页面元素垂直+水平居中 */ display: flex; justify-content: center; align-items: center; /* 让页面始终占浏览器可视区域高度 */ height: 100vh; /* 背景颜色 径向渐变 */ background: radial-gradient(#353c44, #222931);&#125;/* 定义一下几个盒子相同的部分 */.circle &#123; /* 圆形 */ border-radius: 50%;&#125;.center &#123; position: absolute; top: 50%; left: 50%; /* 元素走自身高度/宽度 的一半 */ transform: translate(-50%, -50%);&#125;.container &#123; /* 相对定位 */ position: relative; width: 300px; height: 300px; border: 1px solid rgb(18, 20, 20); background-color: #384c50; /* 盒子阴影 默认是外部阴影 写了inset 就是内部阴影 */ box-shadow: 0 0 32px 8px rgb(18, 20, 20), 0 0 4px 1px rgb(18, 20, 20) inset;&#125;.container .box1 &#123; width: 238px; height: 238px; background-color: rgb(22, 26, 27); box-shadow: 0 0 4px 1px #52fefe;&#125;.container .box2 &#123; width: 220px; height: 220px; background-color: #fff; box-shadow: 0 0 5px 1px #52fefe, 0 0 5px 4px #52fefe inset;&#125;.container .box3 &#123; width: 180px; height: 180px; background-color: #073c4b; box-shadow: 0 0 5px 4px #52fefe, 0 0 6px 2px #52fefe inset;&#125;.container .box4 &#123; width: 120px; height: 120px; border: 1px solid #52fefe; background-color: #fff; box-shadow: 0 0 2px 1px #52fefe, 0 0 10px 5px #52fefe inset;&#125;.container .box5 &#123; width: 70px; height: 70px; border: 5px solid #1b4e5f; box-shadow: 0 0 7px 5px #52fefe, 0 0 10px 10px #52fefe inset;&#125;.container .box6 &#123; position: relative; width: 100%; height: 100%; /* 动画 名称 时长 linear 是匀速运动 infinite是无限次播放 */ animation: rotate 3s linear infinite;&#125;.container .box6 .coil &#123; position: absolute; width: 30px; height: 20px; /* calc方法自动计算位移距离 */ top: calc(50% - 110px); left: calc(50% - 15px); background-color: #073c4b; box-shadow: 0 0 5px #52fefe inset; /* calc方法自动计算数值 var函数调用了我们刚刚给元素定义的--i属性值 然后分别乘以45度 算出各自的度数 */ transform: rotate(calc(var(--i) * 45deg)); /* 这个是旋转的中心 */ transform-origin: center 110px;&#125;/* 定义一下旋转动画 */@keyframes rotate &#123; 0% &#123; transform: rotate(0); &#125; 100% &#123; transform: rotate(360deg); &#125;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container circle&quot;&gt; &lt;div class=&quot;box1 circle center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2 circle center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3 circle center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4 circle center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5 circle center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box6 circle&quot;&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 0&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 5&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 6&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 7&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 重新部署即可","categories":[{"name":"Guidance","slug":"Guidance","permalink":"https://cheeseburgerim.github.io/categories/Guidance/"}],"tags":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"Hexo","slug":"Hexo","permalink":"https://cheeseburgerim.github.io/tags/Hexo/"},{"name":"Guidance","slug":"Guidance","permalink":"https://cheeseburgerim.github.io/tags/Guidance/"}]},{"title":"Chapter3 程序的机器级表示","slug":"DUOCS/DUOCS-Chapter3","date":"2021-02-11T08:50:41.000Z","updated":"2021-06-07T10:49:21.671Z","comments":false,"path":"2021/02/11/DUOCS/DUOCS-Chapter3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/11/DUOCS/DUOCS-Chapter3/","excerpt":"","text":"历史观点 程序编码 数据格式 访问信息 算术和逻辑操作 控制 过程 数组分配和访问 异类的数据结构 对齐(alignment) 综合：理解指针 实现生活：使用GDB调试器 存储器的越界引用和缓冲区溢出 浮点代码 在C程序中嵌入汇编代码 小结","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"DUOCS","slug":"DUOCS","permalink":"https://cheeseburgerim.github.io/tags/DUOCS/"}]},{"title":"Chapter2 信息的表示和处理","slug":"DUOCS/DUOCS-Chapter2","date":"2021-02-09T02:58:18.000Z","updated":"2021-06-07T10:49:08.317Z","comments":false,"path":"2021/02/09/DUOCS/DUOCS-Chapter2/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/09/DUOCS/DUOCS-Chapter2/","excerpt":"","text":"现代计算机存储和处理以二值信号表示的信息。这些普通的二进制数字，或者位(bit)，形成了数字革命的基础。大家熟悉地使用了1000多年的十进制(以10为基数，base-10)起源于印度，在12世纪被阿拉伯数学家所改进，并在13世纪被意大利数学家Leonardo Pisano(更有名的叫法是Fibonacci)带到西方。使用十进制表示法对于有十个手指头的人类来说是很自然的事情，但是当构造存储和处理信息的机器时，二进制值工作得更好。二值信号能够很容易地表示、存储和传输，例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者磁场引起的顺时针或逆时针。基于二值信号的存储和执行计算的电子电路非常简单和可靠，使得制造商能够在一个单独的硅片上集成百万个这样的电路； 单独地来说，单个的位不是非常有用。然而，当我们把位组合在一起，再加上某种解释(interpretation)，即给予不同的可能位模式以含义，我们就能够表示任何有限集合的元素。比如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的字符码，我们能够对一份文档中的字母和符号进行编码； 我们考虑三中最重要的数字编码。无符号(unsigned)编码是基于传统的二进制表示法的，表示大于或等于零的数字。二进制编码(two’s-complement)编码是表示有符号整数的最常见的方式，有符号整数就是为正或者为负的数字。浮点数(floating-point)编码是表示实数的科学计数法的以二为基数的版本。计算机用这些不同的表示方法实现算术运算，例如加法和乘法，类似于相应的整数和实数运算； 计算机的表示法用有限的位数来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会溢出(overflow)。这会导致某些令人吃惊的后果。例如，在大多数今天的计算机上，计算表达式200×300×400×500会得出-884,901,888。这违背了整数运算的属性——计算一组正数的乘积产生了一个为负的结果； 另一方面，整数的计算机运算满足了真正整数运算的许多普通的属性。例如，乘法是可结合的和可交换的，这样一来计算下面任何一个C表达式，都会得出884,901,888 (500×400)×(300×200) ((500×400)×300)×200 ((200×500)×300)×400 400×(200×(300×500)) 计算机可能没有产生这个预期的结果，但至少它是一致的！ 浮点运算有完全不同的数学属性。但是溢出会产生特殊的值+∞，但是一组正数的乘积总是正的。另一方面，由于表示的精度有限，浮点运算时不可结合的。例如，在大多数机器上，C表达式(3.14+1e20)-1e20求得的值会是0.0，而3.14+(1e20-1e20)求得的值会是3.14； 通过研究实际数字的表示，我们能够了解可以表示的值得范围和不同运算的属性。对于编写在全部数值范围内都能正常工作，而且可以跨越不同机器、操作系统和编译器组合的可移植的程序来说，这种了解是非常重要的； 计算机用几种不同的二进制表示来编码数值； 通过直接操作位级的数字表示，我们得到了几种进行算术运算的方式。理解这些技术对于理解编译算术表达式时产生的机器级代码是很重要的； 对这些内容的处理是非常精确的。我们从编码的基本定义开始，然后得出一些属性，例如可表示的数字的范围、它们的位级表示以及算术运算的属性。从这样一个抽象的观点来分析这些内容是很重要的，因为程序员需要对计算机运算和更为人熟悉的整数和实数运算之间的关系有牢固的理解。尽管这看起来很吓人，但精确的处理只需要了解基本的代数知识； C编程语言建立在C之上，使用完全相同的数字表示和运算。以下关于C的所有内容对C都有效。另一方面，Java语言创造了一套新的数字表示和运算标准。C标准被设计为允许多种实现方式，而Java标准在数据的格式和编码上是详细而精确的。 信息存储 大多数计算机使用8位的块，或叫做字节(byte)，来作为最小的可寻址的存储器单位，而不是访问存储器中单独的位。机器级程序将存储器视为一个非常大的字节数组，称为虚拟存储器(virtual memory)。存储器的每个字节都由一个唯一的数字来标识，称为它的地址(address)，所有可能地址的集合就称为虚拟地址空间(virtual address space)。正如它的名字表明的，这个虚拟地址空间只是一个展现给机器程序的概念性映像(image)。实际的实现使用的是随机访问存储器RAM、磁盘存储、特殊硬件和操作系统软件的结合，来为程序提供一个看上去统一的字节数组； 编译器和运行时系统的一个任务就是将这个存储器空间划分为更可管理的单元，来存放不同的程序对象(program object)，也就是，程序数据、指令和控制信息。有各种机制可以用来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。例如，C中一个指针的值(无论它指向一个整数、一个结构或是某个其他程序单元)都是某个存储块的第一个字节的虚拟地址。C编译器还把每个指针和类型信息联系起来，这样它就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管C的编译器维护着这个类型信息，但是它1生成的实际机器级程序并没有关于数据类型的信息。它简单地把每个程序对象视为一个字节块，而程序本身看做一个字节序列； 给C语言初学者：C中指针的角色 指针是C的一个重要特性，它提供了引用数据结构的元素(包括数组)的机制。就像一个变量，指针也有两个方面：它的值和它的类型，它的值表示的是某个对象的位置，而它的类型表示那个位置上所存储对象的类型(比如，整数或者浮点数)。 十六进制表示法 一个字节包括8位。在二进制表示法中，它的值域是00000000211111111&lt;sub&gt;2&lt;/sub&gt;。如果看成十进制整数，它的值域就是0&lt;sub&gt;10&lt;/sub&gt;25510。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而使用十进制表示法，与位模式的相互转化很麻烦。替代的方法是，我们以16为基数，或者叫做十六进制(hexadecimal)数，来书写位模式。十六进制(简写“Hex”)使用数字&quot;0&quot;“9”，以及字符“A”“F”来表示16个可能的值。下表展示了16个十六进制数字对应的十进制值和二进制值 十六进制数字 0 1 2 3 4 5 6 7 十进制值 0 1 2 3 4 5 6 7 二进制值 0000 0001 0010 0011 0100 0101 0110 0111 十六进制数字 8 9 A B C D E F 十进制值 8 9 10 11 12 13 14 15 二进制值 1000 1001 1010 1011 1100 1101 1110 1111 在C中，以0x或0X开头的数字常量被认为是十六进制的值。字符“A”~“F”既可以是大写，也可以是小写。例如，我们可以将数字FA1D37B16写作0xFA1D37B或者0xfa1d37b，甚至是大小写混合，比如0xFa1D37b； 编写机器级程序的一个常见任务就是手工地在位模式的十进制、二进制和十六进制表示之间转换。二进制和十六进制之间的转换是简单直接的，因为可以一次执行一个十六进制数字的转换。数字的转换可以参考上表。 字 每台计算机都有一个字长(word size)，指明整数和指针数据的标称大小(nominal size)。因为虚拟地址是以这样的字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为n位的机器而言，虚拟地址的范围为0~2n-1，程序最多访问2n字节； 今天大多数计算机的字长都是32位。这就限制了虚拟地址空间为4千兆字节(写作4GB)，也就是说，刚刚超过4×109字节。虽然对大多数应用而言，这个空间足够大了，但是现在已经有许多大型的科学和数据库应用需要更大的存储了。因此，随着存储器价格的降低，字长为64位的高端机器正逐渐变得普遍起来。 数据大小 计算机和编译器使用不同的方式来编码数字，比如不同长度的整数和浮点数，从而支持多种数字格式。比如，许多机器都有处理单个字节的指令，也有处理表示为两字节、四字节或者八字节整数的指令，还有些指令表示为四字节和八字节的浮点数； C语言支持整数和浮点数的多种数据格式。C的数据类型char表示一个单独的字节。尽管“char”这个名字是由于它被用来存储文本串中的单个字符这一事实而来的，但它也能被用来存储整数值。C的数据类型int之前还能加上限定词long和short，提供各种大小的整数表示。下表展示了为各种C数据类型分配的字节数 C声明 典型的32位机器 Compaq Qlpha机器 char 1 1 short int 2 2 int 4 4 long int 4 8 char * 4 8 float 4 4 double 8 8 准确的字节数依赖于机器和编译器。我们展示了两个有代表性的例子：典型的32位机器和Compaq Alpha体系结构，其中Compaq Alpha是针对高端应用的64位机器，大多数32位机器使用“典型”的分配方式。可以观察到，“短”整数分配有两字节，而不加限制的int为四字节，“长”整数使用机器的全字长； 上表也说明了指针(例如，一个被声明为类型为“char *”的变量)使用机器的全字长。大多数机器还支持两种不同的浮点格式：单精度(在C中声明为float)和双精度(在C中声明为double)。这些格式分别使用四字节和八字节； 程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。C标准对不同数据类型的数字范围设置了下界，但是却没有上界。因为32位机器在过去20年里一直是标准，许多程序的编写都是以上表中“典型的32位机器”列出的分配原则为假设的。在不久的将来，随着64位机器越来越重要，在将这些程序移植到新机器上时，许多隐藏的对字长的依赖就会呈现出来，成为错误。比如，许多程序员假设一个声明为int类型的程序对象能被用来存储一个指针。这在大多数32位的机器上工作正常，但是在一台Alpha机器上却会导致问题。 寻址和字节顺序 对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么和我们在存储器中如何对这些字节排序。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节序列中最小的地址。例如，假设一个类型为int的变量x的地址为0x100，也就是说，地址表达式&amp;x的值为0x100.那么，x的四字节将被存储在存储器的0x100、0x101、0x102和0x103位置； 对表示一个对象的字节序列排序，有两个通用的规则。考虑一个w位的整数，有位表示[xw-1,xw-2,…,x1,x0]，其中xw-1是最高有效位，而x0是最低有效位。假设w是8的倍数，这些位就能被分组成为字节，其中最高有效字节包含位[xw-1,xw-2,…,xw-8]，而最低有效字节包含位[x7,x6,…,x0]，其他字节包含中间的位。某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则——最低有效字节在最前面的方式称为小端法(little endian)。大多数源自以前的Digital Equipment公司(现在是Compaq公司的一部分)的机器，以及Intel的机器都采用这种规则。后一种规则——最高有效字节在最前面的方式称为大端法(big endian)。IBM、Motorola和Sun Microsystem的大多数机器都采用这种规则。注意我们说的是“大多数”。这些规则并没有严格按照企业界限来划分。比如，IBM制造的个人计算机使用的是Intel兼容的处理器，因此就是小端法。许多微处理器芯片，包括Alpha和Motorola和PowerPC，能够运行在任一种模式中，其取决于芯片加电启动时确定的字节顺序规则； 继续我们前面的示例，假设变量x类型为int，位于地址0x100处，有一个十六进制值为0x01234567.地址范围0x100~0x103的字节顺序依赖于机器的类型 大端法 0x100 0x101 0x102 0x103 … 01 23 45 67 … 小端法 0x100 0x101 0x102 0x103 … 67 45 23 01 … 注意，在字0x01234567中，高位字节的十六进制值为0x01，而低位字节值为0x67； 令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上，术语&quot;little endian(小端)&quot;和&quot;big endian(大端)&quot;来自于Jonathan Swift的《格利弗游记(Gulliver’s Travels)》，其中交战的两个派别无法就应该从哪一端——小端还是大端——打开一个半熟的鸡蛋达成一致。就像鸡蛋的问题一样，没有技术原因来选择字节顺序规则，因此争论退化成为关于社会政治论题的口角。对于哪种字节排序的选择是任意的； 对于大多数应用程序员来说，他们机器的字节顺序是完全不可见的。无论为哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题，首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反之时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示； 字节顺序变得重要的第二种情况是当阅读表示整数数据的字节序列时。这通常发生在检查机器级程序时。作为一个示例，从某个文件中摘出了下面这行代码，该文件给出了一个针对Intel处理器的机器级代码的文本表示 180483bd：01 05 64 94 04 08 add %eax，0x8049464 这一行是由反汇编器(disassembler)生成的，反汇编器是一种确定可执行程序文件所表示的指令序列的工具。现在，我们只是注意这行表述了十六进制字节串01 05 64 94 04 08是一条指令的字节级表示，这条指令是增加一个字宽的数据到存储在主存地址0x8049464的值上，如果我们取出这个序列的最后四字节：64 94 04 08，并且按照相反的顺序写出，我们得到08 04 94 64，去掉开头的零，我们就得到值0x8049464，就是右边写着的数值。当阅读像此例中一样的小端法机器生成的机器级程序表示时，经尝会将字节按照相反的顺序显示。书写字节序列的自然方式是最低位字节在左边，而最高位字节在右边，但是这和书写数字时最高有效位在左边，最低有效位在右边的通常方式是相反的； 字节顺序变得可见的第三种情况是当编写规避正常的类型系统的程序时。在C语言中，可以通过使用**强制类型转换(cast)**来允许以一种不同于它被创造时的数据类型来引用一个对象。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必须的； 下面展示了一段C代码 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;typedef unsigned char *byte_pointer;void show_bytes(byte_pointer start,int len)&#123; int i; for(i=0;i&lt;len;i++) printf(&quot;%.2x&quot;,start[i]); printf(&quot;\\n&quot;);&#125;void show_int(int x)&#123; show_bytes((byte_pointer)&amp;x,sizeof(int));&#125;void show_float(float x)&#123; show_bytes((byte_pointer)&amp;x,sizeof(float));&#125;void show_pointer(void *x)&#123; show_bytes((byte_pointer)&amp;x,sizeof(void *));&#125; 它使用强制类型转换来访问和打印不同程序对象的字节表示。 整数表示 整数运算 浮点 小结","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"DUOCS","slug":"DUOCS","permalink":"https://cheeseburgerim.github.io/tags/DUOCS/"}]},{"title":"Chapter1 计算机系统漫游","slug":"DUOCS/DUOCS-Chapter1","date":"2021-02-03T08:28:40.000Z","updated":"2021-06-07T10:48:59.475Z","comments":false,"path":"2021/02/03/DUOCS/DUOCS-Chapter1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/03/DUOCS/DUOCS-Chapter1/","excerpt":"","text":"信息就是位+上下文 1234567//Programm hello#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello,world\\n&quot;); return 0;&#125; 我们的hello程序的生命是从一个源程序(或者说源文件)开始的，该源程序由程序员通过编辑器创建并保存为文本文件，文件名就是hello.c，源程序实际上就是一个由0和1组成的位(又称为比特)序列，这些位被组织成8个一组，称为字节。每个字节都表示程序中某个文本字符； 大部分的现代系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的字节大小的整数值来表示每个字符； 比如，hello.c程序是以字节序列的方式存储在文件中的。每个字节都有一个整数值，对应于某个字符。例如，第一个字节的整数值是35，它对应的就是字符&quot;#&quot;。第二个字节整数值为105，它对应的字符是&quot;i&quot;，以此类推； 注意，每行文本都是以一个看不见的换行符&quot;\\n&quot;来结束的，它所对应的整数值为10。像hello.c这样只由ASCII字符构成的文件称为文本文件，所有其他文件则称为二进制文件； hello.c的表示方法说明了一个基本的思想：系统中所有的信息——包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由一串比特表示的； 区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令； 作为程序员，我们需要了解数字的机器表示方式，因为它们与常见的整数和实数是不同的。它们有些相似，但这种相似并不为人知。 程序被其他程序翻译成不同的格式 在hello程序生命周期的一开始时是一个高级C程序，因为当处于这种形式时，它是能够被人读懂的。然而，为了在系统上运行hello.c程序。每条C语句必须被其他程序转化为一系列的低级机器语言指令，然后这些指令按照一种称为可执行目标程序(executable object program)的格式打好包，并以二进制磁盘文件的形式存放起来，目标程序也成为可执行目标文件(executable object file)； 在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序(complier driver)完成的 1unix&gt; gcc -o hello hello.c 在这里，gcc编译器驱动程序读取源文件hello.c，并把它翻译成一个可执行目标文件hello，这个翻译的过程是分为四个阶段完成的，如下所示 执行这四个阶段的程序(预处理器、编译器、汇编器和链接器)一起构成了编译系统 预处理阶段：预处理器(cpp)根据以字符#开头的命令(directives)，修改原始的C程序。比如hello.c中第一行的#include &lt;stdio.h&gt;指令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入到程序文本中去。结果就得到了另一个C程序，通常是以.i作为文件扩展名； 编译阶段：编译器(ccl)将文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言； 汇编阶段：接下来，汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成为一种叫做可重定位(relocatable)目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它的字节编码是机器语言指令而不是字符。如果我们在文本编辑器中打开hello.o文件，呈现的是一对乱码； 链接阶段：请注意，我们的hello程序调用了printf函数，它是标准C库中的一个函数，每个C编译器都提供，printf函数存在于一个名为printf.o的单独的预编译目标文件中，而这个文件必须以某种方式并入到我们的hello.o程序中。链接器(id)就负责处理这种并入，结果就得到hello文件，它是一个可执行目标文件(或者简称为可执行文件)。可执行文件加载到存储器后，由系统负责执行。 了解编译系统如何工作是大有益处的 ​ 对于像hello.c这样简单的程序，我们可以依靠编译系统生成正确有效的机器代码，但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。 优化程序性能。现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在我们的C程序中做出好的代码选择，我们确实需要对汇编语言以及编译器如何将不同的C语句转化为汇编语言有一些基本的了解。比如，一个switch语句是不是总比一系列的if-then-else语句高效得多？一个函数调用的代价有多大？while循环比do循环更有效吗？指针引用比数组索引更有效吗？相对于通过引用传递过来得参数求和，为什么用本地变量求和得循环，其运行就会快得多呢？为什么两个功能相近得循环的运行时间会有很大差异？ 理解链接时出现的错误。根据我们的经验，一些最令人困扰得程序错误往往都与链接器操作有关，尤其是当你试图建立大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？如果你在不同的C文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？为什么我们在命令行上排列库的顺序是有影响的？最为烦人的是，为什么有些链接错误直到运行时才出现？ 避免安全漏洞，近年来，缓冲区溢出错误造成了大多数网络和Internet服务器上的安全漏洞。这些错误的存在是因为太多的程序员忽视了编译器用来为函数产生代码的堆栈规则。 处理器读并解释储存在存储器中的指令 ​ 此刻，我们的hello.c源程序已经被编译系统转换成了可执行目标文件hello，并被存放在磁盘上。为了在Unix系统上运行该可执行文件，我们将它的文件名输入到称为shell的应用程序中： 123unix&gt; ./hellohello, worldunix&gt; ​ shell是一种命令行解释器，它输出一个提示符，等待你输入一行命令，然后执行这个命令。如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，要加载和执行该文件。所以在此例中，shell将加载和执行hello程序，然后等待程序终止。hello程序在屏幕上输出它的信息，然后终止。shell随后输出一个提示符，等待下一个输入的命令行。 系统的硬件组成 ​ 为了了解运行时hello程序发生了什么，我们需要理解一个典型系统的硬件组织，如下图所示 CPU：中央处理单元； ALU：算术/逻辑单元； PC：程序计数器； USB：通用串行总线 总线 贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字(word)，字中的字节数(即字长)是一个基本的系统参数，各个系统中也不尽相同。比如，Intel Pentium系统的字长为4字节，而服务器类的系统，例如Intel Itaniums和高端的Sun公司的SPARCS的字长为8字节。用于汽车和工业中的嵌入式控制器之类较小的系统的字长往往只有1或2字节。为了便于描述，我们假设字长为4字节，并且假设总线一次只传一个字。 I/O设备 I/O(输入/输出)设备是系统与外界的联系通道。我们的示例系统包括四个I/O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器(简单地说就是磁盘)。最开始，可执行程序hello就放在磁盘上； 每个I/O设备都是通过一个控制器或适配器与I/O总线连接起来的。控制器和适配器之间的区别主要在于它们的组成方式。控制器是I/O设备本身中或是系统的主印制电路板(通常被称作主板)上的芯片组，而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。 主存 主存是一个临时存储设备，在处理器执行程序时，它被用来存放程序和程序处理的数据。物理上来说，主存是由一组DRAM(动态随机存取储存器)芯片组成的，。逻辑上来说，存储器是由一个线性的字节数组组成的，每个字节都有自己唯一的地址(数组索引)，这些地址是从零开始的。一般来说，组成程序的每条机器指令都有不定量的字节构成。与C程序变量相对应的数据项的大小是根据类型变化的。比如，在运行Linux的Intel机器上，short类型的数据需要2字节，int、float和long类型则需要4字节，而double类型需要8字节； 处理器 中央处理单元(CPU)简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个被称为程序计数器(PC)的字长大小的存储设备(或寄存器)。在任何一个时间点上，PC都指向主存中的某条机器语言指令(内含其地址)； 从系统通电开始，直到系统断电，处理器一直在不假思索地重复执行相同的基本任务：从程序计数器(PC)指向地存储器处读取指令，解释指令中的位，执行指令指示的简单操作，然后更新程序计数器指向下一条指令，而这条指令并不一定在存储器中和刚刚执行的指令相邻； 这样的简单操作的数目并不多，它们在主存、寄存器文件(register file)和算数逻辑单元(ALU)之间循环。寄存器文件是一个小的存储设备，由一些字长大小的寄存器组成，这些寄存器每个都有唯一的名字。ALU计算新的数据和地址值。下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作 加载：从主存拷贝一个字节或者一个字到寄存器，覆盖寄存器原来的内容； 存储：从寄存器拷贝一个字节或者一个字到主存的某个位置，覆盖这个位置上原来的内容； 更新：拷贝两个寄存器的内容到ALU，ALU将两个字相加，并将结果存放到一个寄存器中，覆盖该寄存器中原来的内容； I/O读：从一个I/O设备中拷贝一个字节或者一个字到一个寄存器； I/O写：从一个寄存器中拷贝一个字节或者一个字到一个I/O设备； 转移：从指令本身抽取一个字，并将这个字拷贝到程序计数器(PC)中，覆盖PC中原来的值。 运行hello程序 通过对系统的硬件组成和操作的简单学习，我们开始能够了解当我们运行示例程序时发生了什么。在这里我们必须忽略很多细节，稍后会做一些补充，但是现在我们将很满意这种粗略的描述。 首先，shell程序执行它的指令，等待我们输入命令。当我们在键盘上输入字符串“./hello”后，shell程序就逐一读取字符到寄存器，再把它放到存储器中，如下图所示 当我们在键盘上敲回车键时，shell就知道我们已经结束了命令的输入。然后shell执行一系列指令。这些指令将hello目标文件中的代码和数据从磁盘拷贝到主存，从而加载hello文件。数据包括最终会被输出的字符串“hello，world\\n”。 利用称为DMA(直接存储器存取)的技术，数据可以不通过处理器而直接从磁盘到达主存，这个步骤如下图所示 一旦hello目标文件中的代码和数据被加载到了存储器，处理器就开始执行hello程序的主程序中的机器语言指令，这些指令将“hello，world\\n”串中的字节从存储器中拷贝到寄存器文件，再从寄存器中文件拷贝到显示设备，最终显示在屏幕上，这个步骤如下图所示 高速缓存 通过这个简单的示例我们了解到重要的一课，那就是系统花费了大量时间把信息从一个地方挪到另一个地方。hello程序的机器指令最初是存放在磁盘上的。当程序加载时，它们被拷贝到主存，当处理器运行程序时，指令又从主存拷贝到处理器。相似地，数据串“hello，world\\n”开始时在磁盘上，再被拷贝到主存，然后从主存上拷贝到显示设备。从一个程序员的角度来看，大量的拷贝减慢了程序的实际工作。因此，系统设计者的一个主要目标就是使这些拷贝操作尽可能的快； 根据机械原理，较大的存储设备要比较小的存储设备运行德慢，而快速设备的造价远高于低俗设备。比如说，一个典型系统上的磁盘驱动器可能比主存大100倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大1000万倍； 类似地，一个典型的寄存器文件只存储几百字节的信息。与此相反，主存里可存放几百万字节。然而，处理器从寄存器文件中读数据比从主存中读取快几乎100倍。更麻烦的是，随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。加快处理器的运行速度比加快主存的处理速度要容易和便宜得多； 针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器(cache memories，简称高速缓存)，它们被用来作为暂时的集结区域，存放处理器在不久的将来可能会需要的信息。下图展示了一个典型系统中的高速缓存存储器 形成层次结构的存储设备 在处理器和一个较大较慢的设备(例如主存)之间插入一个更小更快的存储设备(例如高速缓存)的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成立一个存储器层次结构，如下图所示 在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是0级或记为L0。这里我们展示的是三层高速缓存L1到L3，占据存储器层次结构的第1层到第3层。主存在第4层，以此类推； 存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是L1的高速缓存，L1是L2的高速缓存，L2是L3的高速缓存，L3是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存； 正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个储存器层次结构的理解来提高程序性能。 操作系统管理硬件 让我们回到hello程序的例子。当shell加载和运行hello程序时，以及hello程序输出自己的消息时，shell和hello程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是，它们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，如下图所示 所有应用程序对硬件的操作尝试都必须通过操作系统； 操作系统有两个基本功能：防止硬件被失控的应用程序滥用；在控制复杂而又通常广泛不同的低级硬件设备方面，为应用程序提供简单一致的方法。操作系统通过下图中显示的几个基本的抽象概念(进程、虚拟存储器和文件)实现这两个功能 如上图所示，文件是对I/O设备的抽象表示，虚拟存储器是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。 进程 像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去独占地使用处理器、主存和I/O设备，而处理器看上去就像在不间断地一条接一条地执行程序中的指令。该程序都代码和数据就好像是系统存储器中唯一地对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一； 进程是操作系统对运行程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像独占地使用硬件。我们称之为并发运行，实际上是说一个进程的指令和另一个进程的指令时交错执行的。操作系统实现这种交错执行的机制称为上下文切换(context switching)； 操作系统保存进程运行所需的所有状态信息。这种状态，也就是上下文(context)，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，系统上都只有一个进程正在运行。当操作系统决定从当前进程转移控制权到某个新进程时，它就会进行上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权转移到新进程。新进程就会从它上次停止的地方开始。下图展示了我们的示例hello运行的基本场景 在我们的示例场景中有连个同时运行的进程：shell进程和hello进程。最开始，只有shell进程在运行，等待命令行上的输入。当我们让它运行hello程序时，shell通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及上下文，然后将控制权传给新的hello进程。在hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给它，它会继续等待下一命令行输入； 实现进程这个抽象概念需要低级硬件和操作系统软件的紧密合作。进程这个抽象的概念还暗示着由于不同的进程交错执行，打乱了时间的概念，使得程序员很难获得运行时间的准确和可重复测量。在现代系统中，拥有各种时间的概念以及用来获得准确测量值的技术。 线程 尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据； 由于网络服务器中对并行处理的要求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般都比进程更高效。 虚拟存储器 虚拟存储器是一个抽象概念，它为每个进程提供了一个假象，好像每个进程都在独占地使用主存。每个进程看到的存储器都是一致的，称之为虚拟地址空间。下图所示的时=是Linux进程的虚拟地址空间(其他Unix系统的设计也与此类似) 在Linux中，最上面的四分之一的地址空间是预留给操作系统中的代码和数据的，这对所有进程都一样。底部的四分之三的地址空间用来存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的； 每个进程看到的虚拟地址空间由大量准确定义的区(area)构成，每个区都有专门的功能。从最低的地址开始，逐步向上研究将是非常有益的 程序代码和数据：代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据区。代码和数据区是由可执行目标文件直接初始化的。在我们的示例中就是可执行文件hello； 堆：代码和数据区后紧跟随着的是运行时堆。代码和数据区是在进程一旦开始运行时就被指定了大小的，与此不同。作为调用像malloc和free这样的C标准库函数的结果，堆可以在运行时动态地扩展和收缩； 共享库：在地址空间的中间附近是一块用来存放像C标准库和数学库这样共享库的代码和数据的区域。共享库的概念非常强大，但是也是个相当难懂的概念； 栈：位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长。每次我们从函数返回时，栈就会收缩； 内核虚拟存储器：内核是操作系统总是驻留在存储器中的部分。地址空间顶部的四分之一部分是为内核预留的。应用程序不允许读写这个区域的内容或者直接调用内核代码定义的函数。 虚拟存储器的运作需要硬件和操作系统软件间的精密复杂的相互合作，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟存储器的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。 文件 文件只不过就是字节序列。每个I/O设备，包括磁盘、键盘、显示器，甚至于网络，都可以被看成是文件。系统中的所有输入输出都是通过使用称为UnixI/O的一小组系统函数调用读写文件来实现的； 文件这个简单而精致的概念是非常强大的，因为它使得应用程序能够统一地看待系统中可能含有的所有各式各样的I/O设备。例如，处理磁盘文件内容的应用程序员可以非常幸福地无需了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。 利用网络系统和其它系统通信 系统漫游行之至此，我们一直是把系统视为一个孤立地硬件和软件的集合体。实际上，现代系统经常是通过网络和其他系统连接到一起的。从一个单独的系统来看，网络可视为又一个I/O设备，如下图所示 当系统从主存拷贝一串字符到网络适配器时，数据流经过网络到达另一台机器，而不是到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据拷贝到自己的主存； 随着像Internet这样的全球网络的出现，从一台主机拷贝信息到另外一台主机已经成为计算机系统最重要的用途之一。比如，像电子邮件、即时消息传送、万维网、FTP和telnet这样的应用都是基于网络拷贝信息的功能的； 回到我们hello示例，我们可以使用熟悉的telnet应用在一个远程主机上运行hello程序。假设我们用本地主机上的telnet服务器。在我们登录到远程主机并运行shell后，远端的shell就在等待接收输入的命令。从这点上来看，在远端运行hello程序包括下图的五个基本步骤 当我们在客户端键入“hello”串并敲下回车键后，客户端软件就会将这个字符串发送到telnet的服务器。在telnet服务器从网络上接收到这个串后，会把它传递给远端shell程序，接下来，远端shell运行hello程序，并将输出返回给telnet服务器。最后，telnet服务器通过网络把输出串转发给telnet客户端，客户端就将输出串输出到我们的本地终端上； 这种在客户端和服务器之间交互的类型在所有的网络应用中是非常典型的。 下一步 我们旋风式的系统漫游到此就结束了。从这次讨论中要得出一个很重要的观点，那就是系统不仅仅是硬件。系统是相互交织的硬件和系统软件的集合体，他们必须共同协作以达到运行应用程序的最终目的。 小结 计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据不同的上下文又有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ASCII文本，然后被编译器和链接器翻译成二进制可执行文件； 处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在存储器、I/O设备和CPU寄存器之间拷贝数据，所以系统中的存储设备就被按层次排列，CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存储器和磁盘存储器。在层次模型中位于更高层的存储设备比低层的存储设备要快，单位比特造假也更高，程序员通过理解和运用这种存储层次结构的知识，可以优化他们C程序的性能； 操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象概念： 文件时对I/O设备的抽象概念 虚拟存储器是对主存和磁盘的抽象概念 进程是处理器、主存和I/O设备的抽象概念 最后，网络提供了计算机系统之间通信的手短。从某个系统的角度看，网络就是一种I/O设备。","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"DUOCS","slug":"DUOCS","permalink":"https://cheeseburgerim.github.io/tags/DUOCS/"}]},{"title":"PTA","slug":"CodeExercise/PTA","date":"2021-02-02T12:22:06.000Z","updated":"2021-03-29T14:00:09.511Z","comments":false,"path":"2021/02/02/CodeExercise/PTA/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/02/CodeExercise/PTA/","excerpt":"","text":"PTA 基础编程题目集 7-23 币值转换 From here **Question：**输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“cWdQbBai”元。 **Input Format：**输入在一行中给出一个不超过9位的非负整数。 **Output Format：**在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void Transform(string m,int l);int main()&#123; string money; while(cin&gt;&gt;money) &#123; int l=money.length(); Transform(money,l); &#125; system(&quot;pause&quot;); return 0;&#125;void Transform(string m,int l)&#123; char str[10]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;&#125;; // 0 1 2 3 4 5 6 7 8 9 //012345678 //813227345 if(l==9) &#123; cout&lt;&lt;str[m[0]-48]&lt;&lt;&quot;Y&quot;; for(int i=1;i&lt;l-4;i++) &#123; cout&lt;&lt;str[m[i]-48]; if(l-i-4==4&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;Q&quot;; if(l-i-4==3&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;B&quot;; if(l-i-4==2&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;S&quot;; &#125; //cout&lt;&lt;&quot;W&quot;; if(m[1]==48&amp;&amp;m[2]==48&amp;&amp;m[3]==48&amp;&amp;m[4]==48); else cout&lt;&lt;&quot;W&quot;; for(int i=l-4;i&lt;l;i++) &#123; cout&lt;&lt;str[m[i]-48]; if(l-i==4&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;Q&quot;; if(l-i==3&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;B&quot;; if(l-i==2&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;S&quot;; &#125; cout&lt;&lt;endl; &#125; else if(l&lt;9&amp;&amp;l&gt;=5) &#123; bool isZero=0; for(int i=0;i&lt;l-4;i++) &#123; bool isEnd=1; for(int j=i;j&lt;l-4;j++) &#123; if(m[j]!=48) &#123; isEnd=0; break; &#125; &#125; if(isEnd) break; if(m[i]!=48) isZero=0; if(isZero) continue; cout&lt;&lt;str[m[i]-48]; if(i&gt;0&amp;&amp;m[i]-48==0) &#123; isZero=1; continue; &#125; if(l-i-4==4) cout&lt;&lt;&quot;Q&quot;; if(l-i-4==3&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;B&quot;; if(l-i-4==2&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;S&quot;; &#125; cout&lt;&lt;&quot;W&quot;; isZero=0; for(int i=l-4;i&lt;l;i++) &#123; bool isEnd=1; for(int j=i;j&lt;l;j++) &#123; if(m[j]!=48) &#123; isEnd=0; break; &#125; &#125; if(isEnd) break; if(m[i]!=48) isZero=0; if(isZero) continue; cout&lt;&lt;str[m[i]-48]; if(i&gt;0&amp;&amp;m[i]-48==0) &#123; isZero=1; continue; &#125; //if(i&gt;0&amp;&amp;m[i]-48==0) if(l-i==4&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;Q&quot;; if(l-i==3&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;B&quot;; if(l-i==2&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;S&quot;; &#125; cout&lt;&lt;endl; &#125; else//l&lt;5 &#123; if(l==1) cout&lt;&lt;str[m[0]-48]; bool isZero=0; for(int i=0;i&lt;l;i++) &#123; bool isEnd=1; for(int j=i;j&lt;l;j++) &#123; if(m[j]!=48) &#123; isEnd=0; break; &#125; &#125; if(isEnd) break; if(m[i]!=48) isZero=0; if(isZero) continue; cout&lt;&lt;str[m[i]-48]; if(i&gt;0&amp;&amp;m[i]-48==0) &#123; isZero=1; continue; &#125; if(l-i==4) cout&lt;&lt;&quot;Q&quot;; if(l-i==3&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;B&quot;; if(l-i==2&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;S&quot;; &#125; cout&lt;&lt;endl; &#125;&#125; 源码地址 7-24 约分最简分式 From Here **Question：**分数可以表示为分子/分母的形式。编写一个程序，要求用户输入一个分数，然后将其约分为最简分式。最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8；而当分子分母相等时，仍然表达为1/1的分数形式。 **Input Format：**输入在一行中给出一个分数，分子和分母中间以斜杠/分隔，如：12/34表示34分之12。分子和分母都是正整数（不包含0，如果不清楚正整数的定义的话）。 **提示：**在scanf的格式字符串中加入/，让scanf来处理这个斜杠。 **Output Format：**在一行中输出这个分数对应的最简分式，格式与输入的相同，即采用分子/分母的形式表示分数。如 5/6表示6分之5。 Code 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int GCD(int s,int m);//Greatest Common Divisorint main()&#123; int son, mom; while (scanf(&quot;%d/%d&quot;, &amp;son, &amp;mom)) &#123; cout&lt;&lt;son/GCD(son,mom)&lt;&lt;&#x27;/&#x27;&lt;&lt;mom/GCD(son,mom)&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125;int GCD(int s,int m)&#123; if(s&lt;m) &#123; int temp=m; m=s; s=temp; &#125; int r=s%m; while(r!=0) &#123; s=m; m=r; r=s%m; &#125; return m;&#125; 源码地址 以上代码运行时超时，但没有找到原因，答案代码如下 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; int numerator,denominator,temp,a,b; char c; scanf(&quot;%d%c%d&quot;,&amp;numerator,&amp;c,&amp;denominator); a=numerator; b=denominator; while(b!=0)&#123; temp=a%b; a=b; b=temp; &#125; numerator/=a; denominator/=a; printf(&quot;%d/%d&quot;,numerator,denominator); system(&quot;pause&quot;); return 0;&#125; 源码地址","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"CodeExercise","slug":"CodeExercise","permalink":"https://cheeseburgerim.github.io/tags/CodeExercise/"},{"name":"PTA","slug":"PTA","permalink":"https://cheeseburgerim.github.io/tags/PTA/"}]},{"title":"Marxism","slug":"Marxism","date":"2021-01-30T02:34:51.000Z","updated":"2021-06-17T06:35:33.150Z","comments":false,"path":"2021/01/30/Marxism/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/30/Marxism/","excerpt":"","text":"导论 马克思主义基本原理构成 马克思注意哲学； 马克思主义政治经济学； 科学社会主义。 马克思主义的诞生 1848年《共产党宣言》标志着马克思注意的诞生。 马克思主义服务阶级与学说类别 马克思主义申明为无产阶级服务； 是关于人类解放的学说。 马克思主义理论来源 英国古典政治经济学； 德国古典哲学； 英法空想社会主义。 马克思一生两大发现 《唯物史观》和《剩余价值学说》分别在《德意志意识形态》和《资本论》中有充分阐述。 马克思主义理论特点 科学性； 革命性； 实践性； 人民性； 发展性。 世界的物质性及发展规律 世界多样性与物质统一性 马克思主义哲学的四部分内容 唯物主义； 辩证法； 认识论； 唯物史观。 哲学的基本问题 思维和存在的关系问题 哲学派别 划分标准一：思维和存在谁是本原 存在：唯物主义； 思维：唯心主义。 划分标准二：思维与存在是否统一/同一 是：可知论； 否：不可知论。 物质的特点 物质的根本特点：客观实在性。 物质与感觉的关系 物质不依赖于我们的感觉而存在，但可以被我们的感觉所复写，射影和反映。 事物的联系和发展 辩证法总特征 联系和发展 联系的特点 客观性 普遍性 多样性 条件性 发展的实质 新事物的产生，旧事物的灭亡(新事物可适应变化的环境) 发展是前进上升的运动 辩证法规律 对立统一 质量互变 否定之否定 对立统一规律 对立统一规律是事物发展的根本规律，是客观现实的矛盾双方既对立又统一，通常用既是…又是…表达既是同一性，又是斗争性 同一性 这是辩证的矛盾，不同于逻辑矛盾。既独立又依赖，指矛盾双方的相互依存和贯通的性质 在事物发展中的作用： 在统一体中，双方互为存在条件； 双方在相互作用中得到发展； 规定了事物转化的趋势。 斗争性 是矛盾双方相互排斥和分离 在事物发展中的作用： 在量变中：促成矛盾双方的变化造成发展的不平衡性； 在质变中：突破事物存在的限度，实现事物的质变，使旧事物发展为新事物。 矛盾的普遍性和特殊性的辩证关系 例：白马非马 普遍性是共性，特殊性是个性，两者是有机的统一体 共性寓于个性之中(寓于：A~B，A蕴含在B中)(有个性的事物一定包含共性，有共性的事物不一定包含个性，所以共性寓于个性之中，可根据JAVA中父类子类的定义理解) 没有离开个性的共性，共性是通过个性来表现的，也没有离开共性的个性 质量互变规律 揭示了事物发展的渐进性和飞跃性的统一 质量度 质是认识事物的开始，是事物区别其他事物的依据和特质； 量是认识事物的深化； 度是质和量的统一，是保持事物性质稳定性的数量界限。 质变和量变的辩证关系 量变是质变的必要准备，质变是量变的必然结果，两者互相渗透 否定之否定规律 揭示了事物发展的前进性和曲折性的统一 辩证否定的内容 是自我否定 是发展的环节 是联系的环节 实质是扬弃，既保留又客服 在现实中的作用 反对形而上学的否定观，既肯定一切，又否定一切 例： 对待传统文化 肯定一切：复古主义 否定一切：空想主义 对待西方文化 肯定一切：全盘西化 否定一切：民族主义，民粹思想 应坚持取其精华，去其糟粕 实践与认识及其发展规律 实践与认识 认识论首要的基本观点 认识论首要的基本观点是实践观 实践的特点 直接现实性 自觉能动性 社会历史性 实践的种类 物质生产实践 社会政治实践 科学文化实践 实践在认识中的作用 实践是认识的来源 实践是认识的动力 实践是认识的目的 实践是检验认识正确性的唯一标准 认识的本质 在实践基础上，主体对客体的能动反映 两条认识路线 唯物主义认识路线：从物到感觉或思想 唯心主义认识路线：从感觉或思想到物 辩证唯物主义与唯物主义在认识上的区别 旧唯物主义离开实践看问题，把认识看成是消极被动的反应 离开辩证法看问题，把认识的复杂过程简单化 辩证唯物主义认识论的特点 摹写性 创造性 认识的总过程 起点：实践→认识→实践→认识… 认识的第一次飞跃 实践→认识，其中认识有两个层面：感性认识和理性认识 认识的第二次飞跃 认识→实践 感性认识和理性认识(第一次飞跃) 感性认识 特点：直接性 三种形式：感觉(对个别属性)，直觉(多个属性的综合，对外部整体反应的综合)，表象(眼前，脑海，回忆) 理性认识 特点：间接性 三种形式：概念，判断，推理 两者的辩证关系 从辩证法角度看：感性认识有待于发展为理性认识 从唯物论的角度看：理性认识依赖于感性认识 综合来看，两者是相互渗透的 怎样获得正确的认识 或者说，怎样从感性认识过渡到理性认识 勇于实践，获得丰富的感性材料 对感性材料进行加工，去伪存真 理论为什么要回到实践中(第二次飞跃) 认识世界的目的是为了改变世界，理论回到实践是指导实践的过程，也是实现理论价值的过程 在实践中且只有在实践中，正确的理论才能被证实，错误的理论才能被发现，纠正，推翻 真理与价值 什么是真理 真理标志着相符合，一致或接近，是对客观事物及其规律的正确反映 真理的特点 客观性是真的的本质属性 在真理问题上坚持唯物主义就体现了真理的客观性 真理的客观性决定了真理的一元性 要坚持真理是在同一条件下，真理只有一个，反对主观真理和实用主义真理观 从辩证法的角度看，真理具有绝对性和相对性 绝对性 任何真理都是包含着同客观对象相符合的客观内容，与谬误只有原则的界限 从认识的本性来说，人能正确认识无限发展的物质世界，认识每前进一步，都是对客观事实的接近 相对性 真理的相对性是人的认识的有限性和不完善性，主要是在认识的广度和深度上有待于扩展和深化 真理和谬误的辩证关系 两者是对立统一的关系 对立性：真理就是真理，谬误就是谬误，两者有本质差别，但两者又是统一的 统一性：真理在一定条件下能转化为谬误(原因：真理是具体的，有条件的，有范围的。超出界限，真理就可能转化为谬误。真理是全面的，由若干部分组成，忽视其中任何一点，真理都可能转化为谬误) 结论：真理和谬误相比较而存在，相斗争而发展 在现实中的意义：我们要坚持百花齐放，百家争鸣，坚持真理，纠正错误的正确方针 逻辑证明不是检验真理的标准 逻辑证明只能回答前提是否符合结论的问题，不能回答结论是否符合实践的问题 已经被逻辑证明的东西最终必须经过实践检验，实践是检验真理的唯一标准，逻辑证明只起到重要的补充作用 人类社会及其发展规律 两种对立的历史观 唯物历史观 唯心历史观 根据社会存在与社会意识的关系为标准 唯物史观认为，社会存在决定社会意识，人民群众是历史的创造者； 唯心史观认为，社会意识决定社会存在，少数英雄是历史的创造者，唯心史观也成为英雄史观。 社会存在与社会意识的关系 社会意识是社会生活的精神方面 它包括两个层次： 社会心理，如：习俗、心态、情绪，是以感性认识为基础的，自发的，不系统的，低层次的精神表现； 社会意识形式，是以理性认识为基础的，自觉的，系统的思想认识，如：政治、法律、道德、艺术、宗教、哲学。 社会存在是社会生活的物质方面 它包括三部分： 地理环境； 人口因素； 物质生产方式。 物质生产方式是社会历史发展的决定力量 人—劳动 人与自然的关系→生产力(工具) 人与人的关系→生产关系(经济) 二者统称为生产方式 为什么物质生产方式是社会历史发展的决定力量 人类社会赖以存在和发展的基础是物质生产方式； 物质生产方式决定社会的结构，性质和面貌，制约着人们的政治、经济、文化、生活； 物质生产方式的变化决定整个社会历史的发展，使社会形态从低级向高级更替。 人类社会发展规律——生产关系适应生产力发展状况的规律 生产力 是一种物质力量，包括三个要素 劳动资料(工具) 劳动对象(新材料) 劳动者(人) 生产力状况决定生产关系的性质 生产关系 广义的生产关系包括四个方面：生产、交换、分配、消费 侠义的生产关系的内容包括三部分 生产资料归谁所有，它是判断社会性质的客观依据； 生产中人与人的关系：平等/受雇佣； 产品分配关系。 生产力和生产关系的矛盾、运动、内容 从内容上看 生产力决定生产关系 生产力状况决定生产关系的性质 生产关系对生产力具有能动的反作用，生产关系若适应生产力，就可促进它的发展，反之阻碍其发展。 从过程上看 生产关系对生产力从基本适应到不适应再到相适应，从相对稳定到新旧更替再到相对稳定的过程。 什么是社会基本矛盾，它与社会主要矛盾的区别？ 生产力和生产关系的矛盾； 两者是不同层次的矛盾，社会基本矛盾是其它一切矛盾的根源，社会主要矛盾是社会基本矛盾的具体表现，每个时代都具有与社会基本矛盾的性质、状况相对应的社会主要矛盾。 科学技术在社会发展中的作用 科技是生产力的重要标志，是推动经济和社会发展的强大杠杆； 每次科技革命引起了生产方式、生活方式和思维方式的改变； 要正确把握科技的社会作用； 科技的作用是双刃剑，人类要趋利避害，坚持科技为人类造福的思想。 人的本质 人的本质是一切社会关系的总和，是社会性，不是自然属性 人民群众在历史中的作用表现 人民群众是物质财富的创造者； 人民群众是精神财富的创造者； 人民群众是社会变革的决定力量。 资本主义的本质及规律 商品经济和价值规律 商品经济和自然经济的区别 自然经济的特点：自给自足 商品经济的特点：是以交换为目的的生产 商品经济产生的历史条件 社会分工：农业和手工业的分工使得交换成为必然； 私有制：私有制的出现称为交换的基础。 什么是商品 商品是用来交换的满足人们需要的劳动产品 商品中有两个要素 使用价值 价值 使用价值和价值的辩证关系 两者是对立的，两者不可兼得 使用价值是指商品的有用性； 价值是指凝结在商品中的无差别的人类劳动。 两者是统一的，两者缺一不可 商品必须同时具有使用价值和价值两个要素。 劳动二重性学说 劳动二重性学说是马克思对《劳动价值论》的贡献 同一个劳动具有两种属性 具体劳动 抽象劳动 具体劳动创造了商品的使用价值； 抽象劳动是无差别的人类劳动，形成了商品的价值。 劳动创造的价值是可以被量化的 由时间计量 社会必要劳动时间决定了价值量的大小 货币是长期商品交换过程中形成的 商品的价值不能自己表现出来，是由另一种商品的使用价值表现出来 货币的阶段 物物交换，买卖同一(买就是卖，卖就是买)； 一对多交换； 一般等价物，多对一交换； 金银的出现→货币的出现。 货币的职能 价值尺度：值…钱； 流通手段：购买，交换媒介； 贮藏手段； 支付手段：赊； 世界货币：美元。 价值规律(内容，表现，作用) 价值规律是关于商品生产和商品交换的规律 内容：商品的价值量是由社会必要劳动时间决定的；商品交换按等价原则(等价交换)； 表现：价格受供求影响，价格围绕着价值上下波动； 作用(积极方面)：自发地调节生产资料在不同部门的分配比例；自发地刺激生产力发展；自发地调节社会收入的分配； 作用(消极方面，后果)：造成社会资源的浪费；造成两极分化；阻碍技术进步。 以私有制为基础的商品经济的基本矛盾 是私人劳动与社会劳动的矛盾 资本主义制度的本质 资本的本质 资本不是物，不是货币、设备、商品等 是物掩盖下的一种社会生产关系 是资本雇佣劳动的剥削关系 资本的原始积累 英国的圈地运动 贩卖黑奴运动 过程 是生产者和生产资料相分离的过程 资本迅速集中在少数人手中 开始于15世纪后30年 16世纪达到鼎盛 一直到19世纪初才结束 手段 暴力掠夺农民的土地 暴力掠夺货币的财富 劳动力成为商品的条件 劳动者是自由人，可以把自己当作商品来支配 劳动者除了自己的劳动力之外，没有别的商品可以卖出 美国芝加哥工人运动→8小时工作制 劳动力商品的价值构成 维持自己生存的费用 维持家属生活的费用 受教育的费用 劳动力的使用价值是价值的圆圈 劳动力在使用过程中能创造出新价值(即劳动力价值(工资)和剩余价值) 剩余价值的来源？ Points 高频词 特点； 本质； 关系。 人物 亚当斯密，《国富论》，分工 生产分工→经济增长； 康德，《纯粹理性批判》 人知道什么； 人应该知道什么； 人希望知道什么； 什么是人。 黑格尔，《逻辑学》，《精神现象学》 重点 社会的物质性(为什么人类社会是物质的？) 社会存在是社会生活的物质方面 它包括三部分： 地理环境； 人口因素； 物质生产方式。 物质生产方式是社会历史发展的决定力量 人类社会赖以存在和发展的基础是物质生产方式； 物质生产方式决定社会的结构，性质和面貌，制约着人们的政治、经济、文化、生活； 物质生产方式的变化决定整个社会历史的发展，使社会形态从低级向高级更替。 意识的能动作用(和表现) 意识的能动作用：意识对客观存在的反映,是一个积极能动的过程.人的意识按照一定的目的性和选择性,在实践的基础上,对大量感性材料进行分析综合、抽象判断,从认识事物的表面现象进而揭示了事物的内在本质和规律,预见事物的发展趋势。 三个表现： 人能够能动的认识世界,意识活动具有目的性和计划性,主动创造性和自觉选择性； 人能够能动的改造世界.意识对改造客观世界具有指导作用,正确的意识促进客观事物的发展,错误的意识阻碍客观事物的发展； 意识对人体生理活动具有调节和控制作用。 方法论：要树立正确的意识，克服错误的意识。 实践在认识中的作用 实践是认识的来源 实践是认识的动力 实践是认识的目的 实践是检验认识正确性的唯一标准 怎样获得正确的认识(怎样从感性认识过渡到理性认识) 勇于实践，获得丰富的感性材料 对感性材料进行加工，去伪存真 理论为什么要回到实践中 认识世界的目的是为了改变世界，理论回到实践是指导实践的过程，也是实现理论价值的过程 在实践中且只有在实践中，正确的理论才能被证实，错误的理论才能被发现，纠正，推翻 价值规律的表现形式和作用(积极) 价值规律是关于商品生产和商品交换的规律 内容：商品的价值量是由社会必要劳动时间决定的；商品交换按等价原则(等价交换)； 表现：价格受供求影响，价格围绕着价值上下波动； 作用(积极方面)：自发地调节生产资料在不同部门的分配比例；自发地刺激生产力发展；自发地调节社会收入的分配； 作用(消极方面，后果)：造成社会资源的浪费；造成两极分化；阻碍技术进步。 科学技术对人们产生的影响 科技是生产力的重要标志，是推动经济和社会发展的强大杠杆； 每次科技革命引起了生产方式、生活方式和思维方式的改变； 要正确把握科技的社会作用； 科技的作用是双刃剑，人类要趋利避害，坚持科技为人类造福的思想。 垄断没有消除竞争的原因 没有消除竞争的经济条件，即生产资料私有制； 垄断必须通过竞争来维持，以竞争增加实力，巩固垄断地位； 垄断组织不可能包罗万象，在垄断企业内部，在垄断和非垄断企业间，都存在着激烈的竞争。 社会基本矛盾和社会主要矛盾的区别 生产力和生产关系的矛盾； 两者是不同层次的矛盾，社会基本矛盾是其它一切矛盾的根源，社会主要矛盾是社会基本矛盾的具体表现，每个时代都具有与社会基本矛盾的性质、状况相对应的社会主要矛盾。","categories":[{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/categories/Postgraduate/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Marxism","slug":"Marxism","permalink":"https://cheeseburgerim.github.io/tags/Marxism/"},{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/tags/Postgraduate/"},{"name":"SophomoreFirstSemester","slug":"SophomoreFirstSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreFirstSemester/"}]},{"title":"Git Intro","slug":"GitIntro","date":"2021-01-27T05:25:12.000Z","updated":"2021-05-10T12:51:29.055Z","comments":false,"path":"2021/01/27/GitIntro/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/27/GitIntro/","excerpt":"","text":"Git Intro Git教程 Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目； Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件； Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git安装 Linux 12345678//Ubuntu$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev$ apt-get install git$ git --versiongit version 1.8.1.2 Windows 在官网下载即可 Git配置 Git提供了一个叫做git config的工具，专门用来配置或读取相应的工作环境变量； 可用于配置个人的用户名称和电子邮件地址 12$ git config --global user.name &quot;Your username&quot;$ git config --global user.email &quot;Your email&quot; 如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息; 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 Points 提交代码至远程仓库 git add . git commit -m “message” git push 同时提交到多个仓库 打开要提交代码所在的本地仓库，右键+git bash； 接下来查看隐藏文件夹。对于Windows系统，在文件夹的上方，点击查看，勾选隐藏的项目即可； 打开隐藏项目中的.git文件夹，找到里面的config文件，添加代码如下 123456789#before[remote &quot;origin&quot;] url = https://...git(repo1) fetch = +refs/heads/*:refs/remotes/origin/*#after[remote &quot;origin&quot;] url = https://...git(repo1) fetch = +refs/heads/*:refs/remotes/origin/* url = https://...git(repo2) 添加完成后再次提交即可。 远程克隆仓库 123git clone [repo address]#branchgit clone -b [branch name] [repo address]","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Git","slug":"Git","permalink":"https://cheeseburgerim.github.io/tags/Git/"}]},{"title":"Rubik's Cube","slug":"RubikCube","date":"2021-01-26T10:40:14.000Z","updated":"2021-03-22T15:31:14.612Z","comments":false,"path":"2021/01/26/RubikCube/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/26/RubikCube/","excerpt":"","text":"Rubik's Cube 三阶教程 选择一个颜色拼成一面并作为底面； 完成从底面数第一行以及第二行中间的颜色； 在顶层做出十字 顶层棱中间块归位 顶层顶角半归位 完成","categories":[{"name":"Rubik'sCube","slug":"Rubik-sCube","permalink":"https://cheeseburgerim.github.io/categories/Rubik-sCube/"}],"tags":[{"name":"Rubik'sCube","slug":"Rubik-sCube","permalink":"https://cheeseburgerim.github.io/tags/Rubik-sCube/"},{"name":"Fun","slug":"Fun","permalink":"https://cheeseburgerim.github.io/tags/Fun/"},{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"}]},{"title":"C&C++","slug":"LanguageC","date":"2021-01-25T03:12:44.000Z","updated":"2021-03-22T15:28:36.993Z","comments":false,"path":"2021/01/25/LanguageC/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/25/LanguageC/","excerpt":"","text":"C&amp;C++ Points 简易进制转换 C 123printf(&quot;%05o\\n&quot;,35); //按八进制格式输出，保留5位高位补零printf(&quot;%03d\\n&quot;,35); //按十进制格式输出，保留3位高位补零printf(&quot;%05x\\n&quot;,35); //按十六进制格式输出，保留5位高位补零 C++ 123456789101112#include &lt;bitset&gt; #include&lt;iostream&gt;using namespace std; int main() &#123; cout &lt;&lt; &quot;35的8进制:&quot; &lt;&lt; oct &lt;&lt; 35&lt;&lt; endl; cout &lt;&lt; &quot;35的10进制&quot; &lt;&lt; dec &lt;&lt; 35 &lt;&lt; endl; cout &lt;&lt; &quot;35的16进制:&quot; &lt;&lt; hex &lt;&lt; 35 &lt;&lt; endl; cout &lt;&lt; &quot;35的2进制: &quot; &lt;&lt; bitset&lt;8&gt;(35) &lt;&lt; endl; //&lt;8&gt;：表示保留8位输出 return 0; &#125; 保留X位小数/有效数字 123456789101112//C++#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; double a; cin&gt;&gt;a; cout&lt;&lt;setprecision(x)&lt;&lt;a&lt;&lt;endl;//保留x位有效数字 cout&lt;&lt;fixed&lt;&lt;setprecision(x)&lt;&lt;a&lt;&lt;endl;//保留x位小数 return 0;&#125; sort函数 12345678910111213141516171819202122//头文件#include &lt;algorithm&gt;void sort(start,end,cmp);/*start表示要排序数组的起始地址end表示数组结束地址的下一位cmp用于规定排序的方法，可不填，默认升序*///Example#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]=&#123;9,6,3,8,5,2,7,4,1,0&#125;; for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; sort(a,a+10);//指针 for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;&#125; 进制转换函数 itoa atoi strtol string类函数","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"}]},{"title":"英雄联盟","slug":"Game/LeagueOfLegends","date":"2021-01-21T02:05:24.000Z","updated":"2021-05-31T10:54:35.223Z","comments":false,"path":"2021/01/21/Game/LeagueOfLegends/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/21/Game/LeagueOfLegends/","excerpt":"","text":"League of Legends Related Websites Official Developer Championship Highlights 2021年第一个五杀 2021/2/6 赛娜第一个五杀 2021/2/7~2021/2/8 第一次上黄金 2021/2/12 男枪五杀 2021/2/25 赛娜五杀 Videos 更多视频请前往B站投稿以及英雄联盟个人收藏观看 Skins 2020/9/5 原计划：雷 卢锡安 2020/11/11 源计划：联合 艾希 2020/11/17 战斗学院 杰斯 202012/14 西部天使 赛娜 2020/12/18 IG 卡莎 2021/1/21 银河魔装机神 兰博 2021/2/9 龙的传人 李青 2021/2/27 弹幕天使 卡莎 2021/3/23 神龙烈焰 金克斯 2021/4/30 驯龙炮手 崔丝塔娜 &amp; 武装战姬 厄运小姐 2021/5/7 战地机甲 维克兹 2021/5/30 KDA二代 卡莎 &amp; 未来战士 卢锡安","categories":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"}],"tags":[{"name":"Fun","slug":"Fun","permalink":"https://cheeseburgerim.github.io/tags/Fun/"},{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"LOL","slug":"LOL","permalink":"https://cheeseburgerim.github.io/tags/LOL/"}]},{"title":"部落冲突","slug":"Game/ClashOfClans","date":"2021-01-20T02:57:57.000Z","updated":"2021-04-14T13:25:55.245Z","comments":false,"path":"2021/01/20/Game/ClashOfClans/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/20/Game/ClashOfClans/","excerpt":"","text":"Clash of Clans Related Websites Official Developer Tool ClanWorld","categories":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"}],"tags":[{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"COC","slug":"COC","permalink":"https://cheeseburgerim.github.io/tags/COC/"},{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"fun","slug":"fun","permalink":"https://cheeseburgerim.github.io/tags/fun/"}]},{"title":"仙境传说","slug":"Game/Ragnarok","date":"2021-01-15T03:32:34.000Z","updated":"2021-04-27T14:29:56.187Z","comments":false,"path":"2021/01/15/Game/Ragnarok/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/15/Game/Ragnarok/","excerpt":"","text":"Ragnarok Related Websites Official Developer Tool Mentor 凩","categories":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"}],"tags":[{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"fun","slug":"fun","permalink":"https://cheeseburgerim.github.io/tags/fun/"},{"name":"RO","slug":"RO","permalink":"https://cheeseburgerim.github.io/tags/RO/"}]},{"title":"Markdown Symbols","slug":"MarkdownSymbols","date":"2021-01-07T04:14:27.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2021/01/07/MarkdownSymbols/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/07/MarkdownSymbols/","excerpt":"","text":"符号 Symbol Code Ω ω \\Omega or \\omega ρ \\rho Φ φ \\Phi or \\phi Δ δ \\Delta or \\delta π \\pi λ \\lambda ⇒ → \\Rightarrow or \\rightarrow Θ θ \\Theta \\theta Γ γ \\Gamma \\gamma ∞ \\infty Σ σ \\Sigma \\sigma E ε \\Epsilon \\epsilon M μ \\Mu \\mu N ν \\Nu \\nu Ψ ψ \\Psi \\psi 计算 Function Code 分数 \\frac{}{} 根号 \\sqrt{} 恒等于≡ \\equiv 正负± \\pm 约等于≈ \\approx 远大于 远小于 \\gg \\ll 积分∫ 用上下标表示上限和下限 \\int * \\ast 点乘 · \\cdot 叉乘 × \\times 除以 ÷ \\div 不等于≠ \\not= \\neq 标记 Symbol Code 上划线 \\overline{} 下划线 \\underline{} 上标 ^ 下标 _ 删除线，中划线 \\sout 左下到右上 \\cance 左上到右下 \\bcance 叉 \\xcance 操作 Operation Code 换行 \\ 空格，空格长度递增 , ; \\quad \\qquad 加粗 \\pmb{} 加粗倾斜 \\boldsymbol{} 字体 1&lt;font color=red&gt;我是红色&lt;/font&gt; 我是红色 1&lt;font size=5&gt;我是红色&lt;/font&gt; 我是红色 1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=blue&gt; 背景色是蓝色&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 背景色是蓝色 1&lt;center&gt;居中文本&lt;/center&gt; 居中文本 1&lt;b&gt;加粗字体&lt;/b&gt; 加粗字体","categories":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/categories/Introduction/"}],"tags":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/tags/New/"},{"name":"Markdown","slug":"Markdown","permalink":"https://cheeseburgerim.github.io/tags/Markdown/"}]},{"title":"NEMU-PA3","slug":"NEMU-PA3","date":"2021-01-06T03:40:53.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2021/01/06/NEMU-PA3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/06/NEMU-PA3/","excerpt":"","text":"Phase1：Cache 阅读实验手册后，根据任务1中描述的性质实现cache，创建cache.h，定义块大小，位数，以及缓存相应的结构体 1234567891011121314151617181920#define BLOCK_SIZE 64#define STORAGE_SIZE_L1 64*1024#define STORAGE_SIZE_L2 4*1024*1024#define EIGHT_WAY 8#define SIXTEEN_WAY 16void init_cache();struct Cache&#123; bool valid; int tag; uint8_t data[BLOCK_SIZE];&#125;cache[STORAGE_SIZE_L1/BLOCK_SIZE];struct SecondaryCache&#123; bool valid,dirty; int tag; uint8_t data[BLOCK_SIZE];&#125;cache2[STORAGE_SIZE_L2/BLOCK_SIZE]; 构造cache初始化函数init_cache()，代码如下 根据要求把给valid，tag以及dirty赋值并在monitor.c文件中的restart()函数中添加相应代码对缓存进行初始化 1234567891011121314151617void init_cache()&#123; int i; for (i = 0;i &lt; STORAGE_SIZE_L1/BLOCK_SIZE;i ++) &#123; cache[i].valid = false; cache[i].tag = 0; memset (cache[i].data,0,BLOCK_SIZE); &#125; for (i = 0;i &lt; STORAGE_SIZE_L2/BLOCK_SIZE;i ++) &#123; cache2[i].valid = false; cache2[i].dirty = false; cache2[i].tag = 0; memset (cache2[i].data,0,BLOCK_SIZE); &#125;&#125; 修改memory.c中的hwaddr_read()和hwaddr_write()函数，实现读写cache的功能，并当cache缺失时才读写DRAM 1234567891011121314151617181920212223242526272829303132333435uint32_t hwaddr_read(hwaddr_t addr, size_t len) &#123; int index = is_mmio(addr); if ( index &gt;= 0) &#123; return mmio_read(addr, len, index); &#125; uint32_t offset = addr &amp; (BLOCK_SIZE - 1); // inside addr uint32_t block = cache_read(addr); uint8_t temp[4]; memset (temp,0,sizeof (temp)); if (offset + len &gt;= BLOCK_SIZE) &#123; uint32_t _block = cache_read(addr + len); memcpy(temp,cache[block].data + offset, BLOCK_SIZE - offset); memcpy(temp + BLOCK_SIZE - offset,cache[_block].data, len - (BLOCK_SIZE - offset)); &#125; else &#123; memcpy(temp,cache[block].data + offset,len); &#125; int zero = 0; uint32_t tmp = unalign_rw(temp + zero, 4) &amp; (~0u &gt;&gt; ((4 - len) &lt;&lt; 3)); return tmp;&#125;void hwaddr_write(hwaddr_t addr, size_t len, uint32_t data) &#123; int index = is_mmio(addr); if ( index &gt;= 0) &#123; mmio_write(addr, len, data, index); return ; &#125; cache_write(addr, len, data);&#125; 至此完成第一阶段。 做第二阶段之前虚拟机发生了一个小小的意外，卡在下图开不了机，只能用新建一个虚拟机重新写第一阶段，再写第二阶段，git log也无法恢复 Phase2：Segment 在kernal/include/common.h中定义宏IA32_SEG 1#define IA32_SEG 修改CPU_state，在reg.h和reg.c文件中增加如下代码，添加并实现GDTR,CR0和各种段寄存器 123456789101112131415161718192021//reg.h#include &quot;../lib-common/x86-inc/cpu.h&quot;//definition of CR0enum &#123;R_CS,R_DS,R_ES,R_SS&#125;//R_GS,R_FS//在CPU_state中//GDTRstruct GDTR&#123; uint32_t base_addr; uint16_t seg_limit;&#125;gdtr;//CR0CR0 cr0;//registersunion&#123; struct SREG sr[6]; struct&#123; struct SREG cs,ds,es,ss; &#125;;&#125;;////reg.cconst char *regss[]=&#123;&quot;cs&quot;,&quot;ds&quot;,&quot;es&quot;,&quot;ss&quot;&#125;; 添加 lgdt 指令 12345678910111213141516//lgdt.h#ifndef __LGDT_H__#define __LGDT_H__make_helper(lgdt_rm_v);#endif//lgdt.c#include &quot;cpu/exec/helper.h&quot;#define DATA_BYTE 2#include &quot;lgdt-template.h&quot;#undef DATA_BYTE#define DATA_BYTE 4#include &quot;lgdt-template.h&quot;#undef DATA_BYTEmake_helper_v(lgdt_rm) 修改swddr_read()和swaddr_write()函数，实现段级地址转换 123456789101112131415uint32_t swaddr_read(swaddr_t addr, size_t len) &#123;#ifdef DEBUG assert(len == 1 || len == 2 || len == 4);#endif lnaddr_t lnaddr = seg_translate(addr, len, current_sreg); return lnaddr_read(lnaddr, len);&#125;void swaddr_write(swaddr_t addr, size_t len, uint32_t data) &#123;#ifdef DEBUG assert(len == 1 || len == 2 || len == 4);#endif lnaddr_t lnaddr = seg_translate(addr, len, current_sreg); return lnaddr_write(lnaddr, len, data);&#125; 定义segment.c，实现seg_translate()函数 1234567#include &quot;nemu.h&quot;lnaddr_t seg_translate(swaddr_t addr, size_t len, uint8_t sreg) &#123; if (cpu.cr0.protect_enable == 0)return addr; Assert(addr+len &lt; cpu.sr[sreg].seg_limit, &quot;cs segment out limit&quot;); return cpu.sr[sreg].seg_base + addr; &#125; 在Operand结构体中添加成员sreg 123456789101112131415typedef struct &#123; uint32_t type; size_t size; union &#123; uint32_t reg; struct &#123; swaddr_t addr; uint8_t sreg; &#125;; uint32_t imm; int32_t simm; &#125;; uint32_t val; char str[OP_STR_SIZE];&#125; Operand; 修改read_ModR_M()中的代码, 以确定是和DS, SS中的哪一个进行捆绑, 然后设置 rm-&gt;sreg, 这样 swaddr_read()和 swaddr_write()就可以使用正确的 段寄存器了 1234567891011121314151617//nemu/src/cpu/decode/modrm.c//read_ModR_M()//elseelse &#123; int instr_len = load_addr(eip, &amp;m, rm); if(rm-&gt;reg == R_ESP || rm-&gt;reg == R_EBP) &#123; current_sreg = R_SS; &#125; else &#123; current_sreg = R_DS; &#125; rm-&gt;val = swaddr_read(rm-&gt;addr, rm-&gt;size); return instr_len; &#125; 出现了报错，重复定义，找了一段时间但是没有解决 尝试做一下任务3 Phase3：Page 添加CR3寄存器，并相应对CR0寄存器进行初始化 12//reg.hCR3 cr3; 修改lnaddr_read()和lnaddr_write()函数 1234567891011121314151617181920212223242526272829uint32_t lnaddr_read(lnaddr_t addr, size_t len) &#123;#ifdef DEBUG assert(len == 1 || len == 2 || len == 4);#endif size_t max_len = ((~addr) &amp; 0xfff) + 1; if (len &gt; max_len) &#123; uint32_t low = lnaddr_read(addr, max_len); uint32_t high = lnaddr_read(addr + max_len, len - max_len); return (high &lt;&lt; (max_len &lt;&lt; 3)) | low; &#125; hwaddr_t hwaddr = page_translate(addr); return hwaddr_read(hwaddr, len);&#125;void lnaddr_write(lnaddr_t addr, size_t len, uint32_t data) &#123;#ifdef DEBUG assert(len == 1 || len == 2 || len == 4);#endif size_t max_len = ((~addr) &amp; 0xfff) + 1; if (len &gt; max_len) &#123; lnaddr_write(addr, max_len, data &amp; ((1 &lt;&lt; (max_len &lt;&lt; 3)) - 1)); lnaddr_write(addr + max_len, len - max_len, data &gt;&gt; (max_len &lt;&lt; 3)); return; &#125; hwaddr_t hwaddr = page_translate(addr); hwaddr_write(hwaddr, len, data);&#125; 实现page_translate()函数 123456789101112131415161718192021222324252627//memory.chwaddr_t page_translate(lnaddr_t);//新建page.c文件//page.c#include &quot;nemu.h&quot;#define DIR(addr) ((addr)&gt;&gt;22)#define PAGE(addr) (((addr)&gt;&gt;12) &amp; 0x3ff)#define OFFSET(addr) ((addr) &amp; 0xfff)hwaddr_t TLB_read(uint32_t);void TLB_write(uint32_t ,uint32_t);hwaddr_t page_translate(lnaddr_t addr) &#123; PAGE_descriptor dir; PAGE_descriptor page; hwaddr_t hwaddr; if (!cpu.cr0.paging || !cpu.cr0.protect_enable)return addr; if ((hwaddr = TLB_read(addr)) != -1)return hwaddr + OFFSET(addr); dir.page_val = hwaddr_read((cpu.cr3.page_directory_base&lt;&lt;12)+(DIR(addr)&lt;&lt;2), 4); Assert(dir.p, &quot;pagevalue = %x eip = %x&quot;, dir.page_val,cpu.eip); page.page_val = hwaddr_read((dir.addr&lt;&lt;12)+(PAGE(addr)&lt;&lt;2), 4); Assert(page.p, &quot;page do not exist at %x&quot;, cpu.eip); hwaddr = (page.addr&lt;&lt;12)+OFFSET(addr); TLB_write(addr, hwaddr); return hwaddr;&#125; Problems 使用PA2答案做PA3，做完PA1后尝试运行。不知道什么原因，发现kernal无法运行，更改opcode_table中的一些指令后即可运行； From 2021/1/6 to 2120/1/17","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"NEMU","slug":"NEMU","permalink":"https://cheeseburgerim.github.io/tags/NEMU/"}]},{"title":"Physics","slug":"PhysicsChapter","date":"2021-01-05T08:18:38.000Z","updated":"2021-04-11T05:20:16.781Z","comments":false,"path":"2021/01/05/PhysicsChapter/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/05/PhysicsChapter/","excerpt":"","text":"Chapter1：振动 一、简谐振动 简谐振动方程 x=Acos(ωt+Φ)x=Acos(ωt+Φ) x=Acos(ωt+Φ) 在水平方向上的弹簧振子简谐运动中，有 ω=kmω=\\sqrt{\\frac{k}{m}} ω=mk​​ x对t求导得到v函数 v=dxdt=−Aωsin(ωt+Φ)=Aωcos(ωt+Φ+π2)v=\\frac{dx}{dt}=-Aωsin(ωt+Φ)=Aωcos(ωt+Φ+\\frac{\\pi}{2}) v=dtdx​=−Aωsin(ωt+Φ)=Aωcos(ωt+Φ+2π​) v对t求导得到a的函数 a=dvdt=(dx)2dt2=−Aω2cos(ωt+Φ)=−ω2xa=\\frac{dv}{dt}=\\frac{(dx)^2}{dt^2}=-Aω^2cos(ωt+Φ)=-ω^2x a=dtdv​=dt2(dx)2​=−Aω2cos(ωt+Φ)=−ω2x 观察上式可得出结论： 最大位移为Xm，最大速度为Vm，最大加速度为am 则有|Xm|=A，|Vm|=Aω，|am|=Aω² 描述简谐振动特征的物理量 振幅A：振幅是振动物体离开平衡位置的最大位移，反映振动强弱程度的物理量； 角频率ω： ω=2πf=2πTω=2\\pi f=\\frac{2\\pi}{T} ω=2πf=T2π​ 相位ωt+Φ：称为振动系统在时刻t的相位，其中Φ是振动系统在t=0时刻的相位，称为初相位。 相位每变化2π，振动的物体就完成一次全振动； t=0时，有 x0=x∣t=0=AcosΦv0=v∣t=0=−ωAsinΦx_0=x|t=0=AcosΦ\\\\v_0=v|t=0=-ωAsinΦ x0​=x∣t=0=AcosΦv0​=v∣t=0=−ωAsinΦ 由上式可得出 A=(x0)2+(v0ω)2,tanΦ=−v0ωx0A=\\sqrt{(x_0)^2+(\\frac{v_0}{ω})^2},tanΦ=-\\frac{v_0}{ωx_0} A=(x0​)2+(ωv0​​)2​,tanΦ=−ωx0​v0​​ 简谐振动的图示法——旋转矢量法 简谐振动的能量 弹性势能Ep Ep=12kx2=12kA2cos2(ωt+Φ)E_p=\\frac{1}{2}kx^2=\\frac{1}{2}kA^2cos^2(ωt+Φ) Ep​=21​kx2=21​kA2cos2(ωt+Φ) 动能Ek Ek=12mv2=12mω2A2sin2(ωt+Φ)=12kA2sin2(ωt+Φ)E_k=\\frac{1}{2}mv^2=\\frac{1}{2}mω^2A^2sin^2(ωt+Φ)=\\frac{1}{2}kA^2sin^2(ωt+Φ) Ek​=21​mv2=21​mω2A2sin2(ωt+Φ)=21​kA2sin2(ωt+Φ) 因此，弹簧谐振子的总机械能为E E=Ek+Ep=12kA2=12mω2A2E=E_k+E_p=\\frac{1}{2}kA^2=\\frac{1}{2}mω^2A^2 E=Ek​+Ep​=21​kA2=21​mω2A2 由此可知，弹簧谐振子的总机械能是一个不随时间变化的常量，即系统的机械能守恒。这也是简谐振动的一个显著的特征； 振幅不仅给出了简谐振动的运动范围，而且还反应了振动系统总能量的大小，或者说反应了振动的强度； 此外，弹簧谐振子的势能平均值和动能平均值(可以分别称为平均势能和平均动能)相等并且等于总机械能的一半。这一结论同样适用于其他简谐振动。 二、简谐振动的合成 两个同方向同频率简谐振动的合成 设某物体同时参与两个同方向，同频率的简谐振动，其表达式分别为 x1=A1cos(ωt+Φ1)x2=A2cos(ωt+Φ2)x_1=A_1cos(ωt+Φ_1)\\\\ x_2=A_2cos(ωt+Φ_2) x1​=A1​cos(ωt+Φ1​)x2​=A2​cos(ωt+Φ2​) 根据叠加原理，该物体在任意时刻的合振动的位移为 x=x1+x2=A1cos(ωt+Φ1)+A2cos(ωt+Φ2)x=x_1+x_2=A_1cos(ωt+Φ_1)+A_2cos(ωt+Φ_2) x=x1​+x2​=A1​cos(ωt+Φ1​)+A2​cos(ωt+Φ2​) 合振动的表达式为 x=Acos(ωt+Φ)x=Acos(ωt+Φ) x=Acos(ωt+Φ) 其中可以利用余弦定理得到合振幅 A=A12+A22+2A1A2cos(Φ2−Φ1)A=\\sqrt{A_1^2+A_2^2+2A_1A_2cos(Φ_2-Φ_1)} A=A12​+A22​+2A1​A2​cos(Φ2​−Φ1​)​ 初相位Φ满足 tanΦ=A1sinΦ1+A2sinΦ2A1cosΦ1+A2cosΦ2tanΦ=\\frac{A_1sinΦ_1+A_2sinΦ2}{A_1cosΦ_1+A_2cosΦ_2} tanΦ=A1​cosΦ1​+A2​cosΦ2​A1​sinΦ1​+A2​sinΦ2​ 合振幅不仅与两个分振幅有关，还与两个分振动的相位差有关； 合振幅的值将介于最大值A1+A2和最小值|A1-A2|之间。 Chapter2：波动 一、波动方程、平面简谐波 一维简谐波的波函数 y(x,t)=Acos(ωt−kx+Φ),k=2πλ波沿x轴正向传播y(x,t)=Acos(ωt+kx+Φ),k=2πλ波沿x轴负向传播y(x,t)=Acos(ωt-kx+Φ),k=\\frac{2\\pi}{λ} 波沿x轴正向传播\\\\ y(x,t)=Acos(ωt+kx+Φ),k=\\frac{2\\pi}{λ} 波沿x轴负向传播 y(x,t)=Acos(ωt−kx+Φ),k=λ2π​波沿x轴正向传播y(x,t)=Acos(ωt+kx+Φ),k=λ2π​波沿x轴负向传播 利用式中各物理量之间的关系，波函数还可以改写成 y(x,t)=Acos[2π(tT−xλ+ϕ)]y(x,t)=Acos[2\\pi(\\frac{t}{T}-\\frac{x}{λ}+\\phi)] y(x,t)=Acos[2π(Tt​−λx​+ϕ)] 速度与加速的的函数同样是用求导的方法得到 v(x,t)=∂y∂t=−ωAsin[ω(t−xu)+ϕ],u为波速a=∂v∂t=∂y∂t2=−ω2Acos[ω(t−xu)+ϕ]v(x,t)=\\frac{∂y}{∂t}=-\\omega Asin[\\omega (t-\\frac{x}{u})+\\phi],u为波速\\\\ a=\\frac{∂v}{∂t}=\\frac{∂^y}{∂t^2}=-\\omega^2Acos[\\omega (t-\\frac{x}{u})+\\phi] v(x,t)=∂t∂y​=−ωAsin[ω(t−ux​)+ϕ],u为波速a=∂t∂v​=∂t2∂y​=−ω2Acos[ω(t−ux​)+ϕ] 通过波函数判断振动方向 上坡下振，下坡上振 二、波的能量、能流密度 在简谐波的传播过程中，任意质元的动能和势能都随时间而变化，但是在任何时刻，势能和动能都是同相位的，其值也是完全相等的； 动能达到最大值时，势能也达到最大值；动能为零时，势能也为零； 在波的传播过程中，任意质元的总机械能不是一个常量，而是随时间做周期性变化的； 质元从比自己相位超前的部分接受能量，又向比自己相位滞后的部分输出能量； 能量伴随波动过程而传播，波动是能量传输的一种方式； 质元运动到平衡位置时能量最大。 波的能量密度 单位体积中波的能量称为波的能量密度，简称波能密度，用w表示； w=dEdV=ρω2A2sin2[ω(t−xu)+ϕ]w=\\frac{dE}{dV}=\\rho\\omega^2A^2sin^2[\\omega(t-\\frac{x}{u})+\\phi] w=dVdE​=ρω2A2sin2[ω(t−ux​)+ϕ] 波的平均能量密度与介质的密度ρ，角频率ω的平方以及振幅A的平方成正比。这一结论虽然是由平面简谐波导出的，但是对于各种机械波都是适用的。w‾=12ρω2A2\\overline{w}=\\frac{1}{2}\\rho\\omega^2A^2 w=21​ρω2A2 波的能流密度 波动的过程是波的能量“流动的过程”，因此要引入表征波的能量流动的物理量——波的能流密度，用I表示； 单位时间内通过截面S的波的能量称为波的平均能流，用Q表示 通过单位面积的波的平均能流用I表示 Q=w‾SuI=w‾u=12ρω2A2uQ=\\overline{w}Su\\\\I=\\overline{w}u=\\frac{1}{2}\\rho\\omega^2A^2u Q=wSuI=wu=21​ρω2A2u I称为平均能流密度矢量或波的强度。 对于平面简谐波，沿波线方向，即波的传播方向，波的振幅是不变的，因而波的强度也是不变的； 而对于球面简谐波而言，沿波线方向，振幅是变化的，因而波的强度也是变化的； 如果取距波源(也就是球面波的球心)单位距离处的振幅为A0，于是球面波在距波源r处的振幅可以表示为A=A0/r，从而球面简谐波的波函数可以表示为 y(r,t)=A0rcos[ω(t−ru)+ϕ]y(r,t)=\\frac{A_0}{r}cos[\\omega(t-\\frac{r}{u})+\\phi] y(r,t)=rA0​​cos[ω(t−ur​)+ϕ] 以上讨论都认定介质是无吸收的理想介质。 三、电磁波 电磁波的性质 电磁波是横波； 电场强度E与磁场强度H同相位； 在真空中,电磁波的传播速度大小表示为c=1ϵ0μ0≈3×108m/s而在介质中电磁波的传播速度大小则表示为u=1ϵ0ϵrμ0μr=1ϵμ式中,ϵr,μr分别为介质的相对介电常量和相对磁导率在真空中,电磁波的传播速度大小表示为c=\\frac{1}{\\sqrt{\\epsilon_0\\mu_0}}\\approx3\\times10^8m/s\\\\ 而在介质中电磁波的传播速度大小则表示为u=\\frac{1}{\\sqrt{\\epsilon_0\\epsilon_r\\mu_0\\mu_r}}=\\frac{1}{\\sqrt{\\epsilon\\mu}}\\\\ 式中,\\epsilon_r,\\mu_r分别为介质的相对介电常量和相对磁导率\\\\ 在真空中,电磁波的传播速度大小表示为c=ϵ0​μ0​​1​≈3×108m/s而在介质中电磁波的传播速度大小则表示为u=ϵ0​ϵr​μ0​μr​​1​=ϵμ​1​式中,ϵr​,μr​分别为介质的相对介电常量和相对磁导率 电磁波的能量密度与能流密度； 电场的能量密度可以表示为we=12ϵ0E2磁场的能量密度可以表示为wm=12μ0H2所以电磁场的能量密度w=we+wm在电磁波传播过程中,理论和实验都证明,在任何时刻空间中的任何地点电场的能量密度与磁场的能量密度都相等‾由此可得ϵ0E=μ0H电磁场的能量密度又可以表示为w=1cEH电场的能量密度可以表示为w_e=\\frac{1}{2}\\epsilon_0E^2\\\\ 磁场的能量密度可以表示为w_m=\\frac{1}{2}\\mu_0H^2\\\\ 所以电磁场的能量密度w=w_e+w_m\\\\ 在电磁波传播过程中,理论和实验都证明,在任何时刻空间中的任何地点\\\\ \\underline{电场的能量密度与磁场的能量密度都相等}\\\\ 由此可得\\sqrt{\\epsilon_0}E=\\sqrt{\\mu_0}H\\\\ 电磁场的能量密度又可以表示为w=\\frac{1}{c}EH\\\\ 电场的能量密度可以表示为we​=21​ϵ0​E2磁场的能量密度可以表示为wm​=21​μ0​H2所以电磁场的能量密度w=we​+wm​在电磁波传播过程中,理论和实验都证明,在任何时刻空间中的任何地点电场的能量密度与磁场的能量密度都相等​由此可得ϵ0​​E=μ0​​H电磁场的能量密度又可以表示为w=c1​EH 电磁波在空间传播时,在某一时刻,单位时间内通过与电磁场传播方向相垂直的单位面积的能量称为电磁波的瞬时能流密度,通常用S来表示d电磁波的瞬时能流密度可以表示为S=wc=E×H上式表明,能流密度与电场强度和磁场强度之间符合右手螺旋的关系电磁波在空间传播时,在某一时刻,单位时间内通过与电磁场传播方向相垂直的单位面积的能量\\\\ 称为电磁波的瞬时能流密度,通常用S来表示\\\\ d电磁波的瞬时能流密度可以表示为S=wc=E\\times H\\\\ 上式表明,能流密度与电场强度和磁场强度之间符合右手螺旋的关系\\\\ 电磁波在空间传播时,在某一时刻,单位时间内通过与电磁场传播方向相垂直的单位面积的能量称为电磁波的瞬时能流密度,通常用S来表示d电磁波的瞬时能流密度可以表示为S=wc=E×H上式表明,能流密度与电场强度和磁场强度之间符合右手螺旋的关系 为方便起见,引入电磁波的平均能流密度,即电磁波的强度,用I表示； 平均而言，在单位时间内，通过与电磁波传播方向垂直的单位面积的能量，或者说，通过与电磁波传播方向相垂直的单位面积的平均功率，就是电磁波的平均能流密度，也就是电磁波的强度； 若电磁波的平均能量密度用w‾表示,电场强度和磁场强度的平均值分别用E‾和H‾表示则电磁波的平均能流密度,即电磁波的强度可以表示为I=S‾=w‾c=EH‾在介质中传播时,I=S‾=12ϵμE02=12μϵH02若电磁波的平均能量密度用\\overline{w}表示,电场强度和磁场强度的平均值分别用\\overline{E}和\\overline{H}表示\\\\ 则电磁波的平均能流密度,即电磁波的强度可以表示为I=\\overline{S}=\\overline{w}c=\\overline{EH}\\\\ 在介质中传播时,I=\\overline{S}=\\frac{1}{2}\\sqrt{\\frac{\\epsilon}{\\mu}}E_0^2=\\frac{1}{2}\\sqrt{\\frac{\\mu}{\\epsilon}}H_0^2 若电磁波的平均能量密度用w表示,电场强度和磁场强度的平均值分别用E和H表示则电磁波的平均能流密度,即电磁波的强度可以表示为I=S=wc=EH在介质中传播时,I=S=21​μϵ​​E02​=21​ϵμ​​H02​ 四、波的干涉 波的叠加 波的叠加问题实际上是振动的合成问题； Example：有波源S1，S2距P点距离分别为r1，r2，则两波在P点引起的振动分别为 y1=A1cos[ω1(t−r1u)+ϕ1]y2=A2cos[ω2(t−r2u)+ϕ2]y_1=A_1cos[\\omega_1(t-\\frac{r_1}{u})+\\phi_1]\\\\ y_2=A_2cos[\\omega_2(t-\\frac{r_2}{u})+\\phi_2] y1​=A1​cos[ω1​(t−ur1​​)+ϕ1​]y2​=A2​cos[ω2​(t−ur2​​)+ϕ2​] 式中，u为介质中的波速 P点在时刻t合振动振幅的二次方为 A2=A12+A22+2A1A2cosΔϕΔϕ=(ω2−ω1)t−ω2r2−ω1r1u+ϕ2−ϕ1A^2=A_1^2+A_2^2+2A_1A_2cos\\Delta\\phi\\\\ \\Delta\\phi=(\\omega_2-\\omega_1)t-\\frac{\\omega_2r_2-\\omega_1r_1}{u}+\\phi_2-\\phi_1 A2=A12​+A22​+2A1​A2​cosΔϕΔϕ=(ω2​−ω1​)t−uω2​r2​−ω1​r1​​+ϕ2​−ϕ1​ P点合成波的强度为I I=I1+I2+2I1I2cosΔϕ‾在当前所学情况下，有cosΔϕ‾≡0于是，P点的合成波强度为I=I1+I2I=I_1+I_2+2\\sqrt{I_1I_2}\\overline{cos\\Delta\\phi}\\\\ 在当前所学情况下，有\\overline{cos\\Delta\\phi}\\equiv0\\\\ 于是，P点的合成波强度为I=I1+I2 I=I1​+I2​+2I1​I2​​cosΔϕ​在当前所学情况下，有cosΔϕ​≡0于是，P点的合成波强度为I=I1+I2 综上所述，当两列波的振动方向相互垂直，或两列波的角频率不相等，或两列波的初相位差不恒定(即随时间变化)时，合成波的强度等于每个波的强度之和。这种波的叠加称为非相干叠加。 波的干涉 当两列波的振动方向相同，并且角频率也相同，以及两波源相位差恒定(也就是两列波的初相位差恒定)时，这两列简谐波称为相干波。这是两列波的叠加称为相干叠加。无论在理论上，还是在实践中相干叠加都具有非常重要的意义。相干叠加的结果可以产生干涉现象。 干涉情况下，有 Δϕ=(ϕ2−ϕ1)−ωu(r2−r1)=(ϕ2−ϕ1)−2πλ(r2−r1)A=A12+A22+2A1A2cosΔϕI=I1+I2+2I1I2cosΔϕ\\Delta\\phi=(\\phi_2-\\phi_1)-\\frac{\\omega}{u}(r_2-r_1)=(\\phi_2-\\phi_1)-\\frac{2\\pi}{\\lambda}(r_2-r_1)\\\\ A=\\sqrt{A_1^2+A_2^2+2A_1A_2cos\\Delta\\phi}\\\\ I=I_1+I_2+2\\sqrt{I_1I_2}cos\\Delta\\phi Δϕ=(ϕ2​−ϕ1​)−uω​(r2​−r1​)=(ϕ2​−ϕ1​)−λ2π​(r2​−r1​)A=A12​+A22​+2A1​A2​cosΔϕ​I=I1​+I2​+2I1​I2​​cosΔϕ Δϕ={±2kπk=0,1,2,...⇒振幅和强度最大，干涉相长或相长干涉A=A1+A2,I=I1+I2+2I1I2±(2k+1)πk=0,1,2,...⇒振幅和强度最小，干涉相消或相消干涉A=∣A1−A2∣,I=I1+I2−2I1I2others在相位差为其他值的地方，其振幅和强度都介于上述两种极端情况之间\\Delta\\phi=\\begin{cases} \\pm2k\\pi &amp; k=0,1,2,... \\Rightarrow振幅和强度最大，干涉相长或相长干涉A=A_1+A_2,I=I_1+I_2+2\\sqrt{I_1I_2}\\\\ \\pm(2k+1)\\pi &amp; k=0,1,2,... \\Rightarrow振幅和强度最小，干涉相消或相消干涉A=|A_1-A_2|,I=I_1+I_2-2\\sqrt{I_1I_2}\\\\ others &amp; 在相位差为其他值的地方，其振幅和强度都介于上述两种极端情况之间 \\end{cases} Δϕ=⎩⎪⎨⎪⎧​±2kπ±(2k+1)πothers​k=0,1,2,...⇒振幅和强度最大，干涉相长或相长干涉A=A1​+A2​,I=I1​+I2​+2I1​I2​​k=0,1,2,...⇒振幅和强度最小，干涉相消或相消干涉A=∣A1​−A2​∣,I=I1​+I2​−2I1​I2​​在相位差为其他值的地方，其振幅和强度都介于上述两种极端情况之间​ 如果两波源的初相位相同，即Φ1=Φ2，则相干波的相位差ΔΦ只取决于波程差δ=r2-r1，上述结论简化为 δ=r2−r1={±kλk=0,1,2,...⇒干涉相长±(2k+1)λ2k=0,1,2,...⇒干涉相消\\delta=r_2-r_1=\\begin{cases} \\pm k\\lambda &amp; k=0,1,2,... \\Rightarrow干涉相长\\\\ \\pm(2k+1)\\frac{\\lambda}{2} &amp; k=0,1,2,... \\Rightarrow干涉相消 \\end{cases} δ=r2​−r1​={±kλ±(2k+1)2λ​​k=0,1,2,...⇒干涉相长k=0,1,2,...⇒干涉相消​ 由以上分析可知，只有相干波，即满足振动方向相同，频率相同，相位差恒定的简谐波，叠加才能产生干涉现象。因而把振动方向相同，频率相同，相位差恒定称为简谐波的相干条件。 驻波 驻波是波的干涉的特例。两列传播方向相反的相干波相干叠加的结果就形成驻波； 设有两列相干波，分别沿x轴正方向和负方向传播，为简单起见，进一步假设这两列波的振幅相同 他们的表达式分别为 y1=Acos(ωt−2πλx)y2=Acos(ωt+2πλx)其合成波为y=y1+y2=2Acos2πλxcosωt此式就是驻波的表达式式中,cosωt表示简谐振动,而∣2Acos2πλx∣就是该简谐振动的振幅各点都以相同的频率,不同的振幅做简谐振动振幅最大的各点称为驻波的波腹,振幅最小的各点称为波节相邻两个波腹或相邻两个波节之间的距离为Δx=λ2相邻波节之间各点的振动都是同相位的而波节两侧的振动都是反相位的y_1=Acos(\\omega t-\\frac{2\\pi}{\\lambda}x)\\\\ y_2=Acos(\\omega t+\\frac{2\\pi}{\\lambda}x)\\\\ 其合成波为y=y_1+y_2=2Acos\\frac{2\\pi}{\\lambda}xcos\\omega t\\\\ 此式就是驻波的表达式\\\\ 式中,cos\\omega t表示简谐振动,而|2Acos\\frac{2\\pi}{\\lambda}x|就是该简谐振动的振幅\\\\ 各点都以相同的频率,不同的振幅做简谐振动\\\\ 振幅最大的各点称为驻波的波腹,振幅最小的各点称为波节\\\\ 相邻两个波腹或相邻两个波节之间的距离为\\Delta x=\\frac{\\lambda}{2}\\\\ 相邻波节之间各点的振动都是同相位的\\\\ 而波节两侧的振动都是反相位的\\\\ y1​=Acos(ωt−λ2π​x)y2​=Acos(ωt+λ2π​x)其合成波为y=y1​+y2​=2Acosλ2π​xcosωt此式就是驻波的表达式式中,cosωt表示简谐振动,而∣2Acosλ2π​x∣就是该简谐振动的振幅各点都以相同的频率,不同的振幅做简谐振动振幅最大的各点称为驻波的波腹,振幅最小的各点称为波节相邻两个波腹或相邻两个波节之间的距离为Δx=2λ​相邻波节之间各点的振动都是同相位的而波节两侧的振动都是反相位的 Chapter3：波动光学 一、光的干涉 简介 定义光程L=nr，两类相干波的相位差可以转换为光程差。通过几何关系找到光程差，进而得到相位差； 波动最显著的特征之一，就是能产生干涉现象。光波也是如此，当空间中相遇的两个或两个以上的波彼此之间满足相干条件时，就会产生干涉现象； 光的干涉表现为，光强在空间出现具有一定规律的突变分布，且这种分布不随时间变化。然而，普通光源所发出的光，是不满足相干条件的； 为了实现光的干涉，就必须制备相干光源。总体上分为两种方法： 分波阵面发； 分振幅法。 分波阵面法制备相干光 1.杨氏双缝干涉实验 光程差δ=dsinθ由于θ角很小，所以有sinθ≈tanθ所以得到δ=dtanθ=dxD=xdD设实验所用的是波长为λ的单色光则有{干涉加强∣明条纹δ=xdD=±kλ,k=0,1,2,...⇒xk=±kDλd干涉减弱∣暗条纹δ=xdD=±(k+12)λ,k=0,1,2,...⇒xk=±(2k+1)Dλ2d名暗条纹都是等间距分布的，即无论是两条相邻的明条纹或是两条相邻的暗条纹条纹中心间距都为Δx=Dλd光程差\\delta=dsin\\theta\\\\ 由于\\theta角很小，所以有sin\\theta\\approx tan\\theta\\\\ 所以得到\\delta=dtan\\theta=d\\frac{x}{D}=\\frac{xd}{D}\\\\ 设实验所用的是波长为\\lambda的单色光\\\\则有 \\begin{cases} 干涉加强|明条纹 &amp;\\delta=\\frac{xd}{D}=\\pm k\\lambda,k=0,1,2,...\\Rightarrow x_k=\\pm k\\frac{D\\lambda}{d}\\\\ 干涉减弱|暗条纹 &amp;\\delta=\\frac{xd}{D}=\\pm (k+\\frac{1}{2})\\lambda,k=0,1,2,...\\Rightarrow x_k=\\pm (2k+1)\\frac{D\\lambda}{2d} \\end{cases}\\\\ 名暗条纹都是等间距分布的，即无论是两条相邻的明条纹或是两条相邻的暗条纹\\\\ 条纹中心间距都为\\Delta x=\\frac{D\\lambda}{d} 光程差δ=dsinθ由于θ角很小，所以有sinθ≈tanθ所以得到δ=dtanθ=dDx​=Dxd​设实验所用的是波长为λ的单色光则有{干涉加强∣明条纹干涉减弱∣暗条纹​δ=Dxd​=±kλ,k=0,1,2,...⇒xk​=±kdDλ​δ=Dxd​=±(k+21​)λ,k=0,1,2,...⇒xk​=±(2k+1)2dDλ​​名暗条纹都是等间距分布的，即无论是两条相邻的明条纹或是两条相邻的暗条纹条纹中心间距都为Δx=dDλ​ 2.多光束干涉 3.劳埃德镜 4.菲涅尔双棱镜 分振幅法制备相干光源——薄膜干涉 1.等倾条纹 相应的薄膜干涉的光程差方程式为δ=2ne+λ2,n为折射率,e为厚度相应的薄膜干涉的光程差方程式为\\delta=2ne+\\frac{\\lambda}{2},n为折射率,e为厚度 相应的薄膜干涉的光程差方程式为δ=2ne+2λ​,n为折射率,e为厚度 2.等厚干涉 1.劈尖形薄膜的干涉 由于薄膜各处的厚度e不同，光程差也不同，因而会产生明暗相间的干涉条纹光程差δ=2ne+λ2当劈尖上下表面的反射光间的光程差等于入射光波长的整数倍时，干涉会产生明条纹即δ=2nek+λ2=kλ,k=1,2,3,...第k级明条纹所在处的厚度为ek当劈尖上下表面的反射光间的光程差等于入射光半个波长的奇数倍时，干涉会产生暗条纹即δ=2nek+λ2=(k+12)λ=(2k+1)λ,k=0,1,2,3,...第k级暗纹所在处的厚度为ek由图中的几何关系可知，第k级条纹到棱边的距离lk=ekθ，式中，θ为劈尖夹角相邻明条纹或暗条纹中心之间的厚度差相等，值为Δe=λ2n通过几何关系可以得到相邻明条纹或暗条纹中心之间的距离也是相等的，值为Δl=Δeθ=λ2nθ由于薄膜各处的厚度e不同，光程差也不同，因而会产生明暗相间的干涉条纹\\\\ 光程差\\delta=2ne+\\frac{\\lambda}{2}\\\\ 当劈尖上下表面的反射光间的光程差等于入射光波长的整数倍时，干涉会产生明条纹\\\\ 即\\delta=2ne_k+\\frac{\\lambda}{2}=k\\lambda,k=1,2,3,...第k级明条纹所在处的厚度为e_k\\\\ 当劈尖上下表面的反射光间的光程差等于入射光半个波长的奇数倍时，干涉会产生暗条纹\\\\ 即\\delta=2ne_k+\\frac{\\lambda}{2}=(k+\\frac{1}{2})\\lambda=(2k+1)\\lambda,k=0,1,2,3,...第k级暗纹所在处的厚度为e_k\\\\ 由图中的几何关系可知，第k级条纹到棱边的距离l_k=\\frac{e_k}{\\theta}，式中，\\theta为劈尖夹角\\\\ 相邻明条纹或暗条纹中心之间的厚度差相等，值为\\Delta e=\\frac{\\lambda}{2n}\\\\ 通过几何关系可以得到相邻明条纹或暗条纹中心之间的距离也是相等的，值为\\Delta l=\\frac{\\Delta e}{\\theta}=\\frac{\\lambda}{2n\\theta} 由于薄膜各处的厚度e不同，光程差也不同，因而会产生明暗相间的干涉条纹光程差δ=2ne+2λ​当劈尖上下表面的反射光间的光程差等于入射光波长的整数倍时，干涉会产生明条纹即δ=2nek​+2λ​=kλ,k=1,2,3,...第k级明条纹所在处的厚度为ek​当劈尖上下表面的反射光间的光程差等于入射光半个波长的奇数倍时，干涉会产生暗条纹即δ=2nek​+2λ​=(k+21​)λ=(2k+1)λ,k=0,1,2,3,...第k级暗纹所在处的厚度为ek​由图中的几何关系可知，第k级条纹到棱边的距离lk​=θek​​，式中，θ为劈尖夹角相邻明条纹或暗条纹中心之间的厚度差相等，值为Δe=2nλ​通过几何关系可以得到相邻明条纹或暗条纹中心之间的距离也是相等的，值为Δl=θΔe​=2nθλ​ 2.牛顿环干涉 ek=r22R中间是暗纹第k级明条纹的半径为rk=(2k−1)Rλ2n=2k−12Rλn,k=1,2,3,...第k级暗条纹的半径为rk=kRλn=kRλn,k=0,1,2,3,...可以看出rk=ck,所以离中心越远条纹越密对于空气薄膜，保持玻璃片不动透镜向上平移，则可观察到牛顿环逐渐缩小并在中心处消失若透镜向下平移，牛顿环将自中心处冒出并变大只要数出从中心处冒出或消失的条纹数N，就可以计算出透镜移动的距离d=Nλ2e_k=\\frac{r^2}{2R}\\\\ 中间是暗纹\\\\ 第k级明条纹的半径为r_k=\\sqrt{\\frac{(2k-1)R\\lambda}{2n}}=\\sqrt{\\frac{2k-1}{2}}\\sqrt{\\frac{R\\lambda}{n}},k=1,2,3,...\\\\ 第k级暗条纹的半径为r_k=\\sqrt{\\frac{kR\\lambda}{n}}=\\sqrt{k}\\sqrt{\\frac{R\\lambda}{n}},k=0,1,2,3,...\\\\ 可以看出r_k=c\\sqrt{k},所以离中心越远条纹越密\\\\ 对于空气薄膜，保持玻璃片不动\\\\ 透镜向上平移，则可观察到牛顿环逐渐缩小并在中心处消失\\\\ 若透镜向下平移，牛顿环将自中心处冒出并变大\\\\ 只要数出从中心处冒出或消失的条纹数N，就可以计算出透镜移动的距离d=N\\frac{\\lambda}{2} ek​=2Rr2​中间是暗纹第k级明条纹的半径为rk​=2n(2k−1)Rλ​​=22k−1​​nRλ​​,k=1,2,3,...第k级暗条纹的半径为rk​=nkRλ​​=k​nRλ​​,k=0,1,2,3,...可以看出rk​=ck​,所以离中心越远条纹越密对于空气薄膜，保持玻璃片不动透镜向上平移，则可观察到牛顿环逐渐缩小并在中心处消失若透镜向下平移，牛顿环将自中心处冒出并变大只要数出从中心处冒出或消失的条纹数N，就可以计算出透镜移动的距离d=N2λ​ 3.迈克尔孙干涉仪 光程差为两倍 二、光的衍射 用激光照射障碍物，很容易演示光的衍射现象； 根据观察方式的不同，通常把衍射分为两类 一类如图a所示，光源和(或)观察屏离开衍射缝或衍射孔的距离有限，这种衍射称为菲涅尔衍射，或进场衍射； 一类如图b所示，光源和观察屏都距离衍射缝或衍射孔无限远处，这种衍射称为父琅禾费衍射，或远场衍射； 夫琅禾费衍射实际上时菲涅尔衍射的极限情形。 单缝夫琅禾费衍射 光程差δ=asinϕ光强分布I=I0(sinuu)2所以当u=πasinϕλ=±kπ,k=1,2,3,...,有I=0所以暗条纹出现的条件是asinϕ=±kλ,k=1,2,3,...在相邻两个暗条纹之间，有一次级大的条件为tanu=u次级大的光强比中央明条纹的光强小得多，并且随着级数增加而急剧减小综上所述{中央明条纹中心ϕ=0暗条纹中心asinϕ=±kλ,k=1,2,3,...次级大明条纹中心asinϕ=±(k+12)λ,k=1,2,3,...其中a为缝的宽度中心区非常亮对于非中心区域,ϕ≠0半波带数=光线条数N=δλ/2光程差\\delta=asin\\phi\\\\ 光强分布I=I_0(\\frac{sinu}{u})^2\\\\ 所以当u=\\frac{\\pi asin\\phi}{\\lambda}=\\pm k\\pi,k=1,2,3,...,有I=0\\\\ 所以暗条纹出现的条件是asin\\phi=\\pm k\\lambda,k=1,2,3,...\\\\ 在相邻两个暗条纹之间，有一次级大的条件为tanu=u\\\\ 次级大的光强比中央明条纹的光强小得多，并且随着级数增加而急剧减小\\\\ 综上所述\\\\ \\begin{cases} 中央明条纹中心 &amp; \\phi=0\\\\ 暗条纹中心 &amp; asin\\phi=\\pm k\\lambda,k=1,2,3,...\\\\ 次级大明条纹中心 &amp; asin\\phi=\\pm (k+\\frac{1}{2})\\lambda,k=1,2,3,... \\end{cases}\\\\ 其中a为缝的宽度\\\\ 中心区非常亮\\\\ 对于非中心区域,\\phi\\neq0\\\\ 半波带数=光线条数 N=\\frac{\\delta}{\\lambda/2}\\\\ 光程差δ=asinϕ光强分布I=I0​(usinu​)2所以当u=λπasinϕ​=±kπ,k=1,2,3,...,有I=0所以暗条纹出现的条件是asinϕ=±kλ,k=1,2,3,...在相邻两个暗条纹之间，有一次级大的条件为tanu=u次级大的光强比中央明条纹的光强小得多，并且随着级数增加而急剧减小综上所述⎩⎪⎨⎪⎧​中央明条纹中心暗条纹中心次级大明条纹中心​ϕ=0asinϕ=±kλ,k=1,2,3,...asinϕ=±(k+21​)λ,k=1,2,3,...​其中a为缝的宽度中心区非常亮对于非中心区域,ϕ​=0半波带数=光线条数N=λ/2δ​ 光栅衍射 所谓光栅，实际上是在空间具有周期性分布的透射光或反射光的光学元件； 亮纹条件:(a+b)sinϕ=kλk=0,±1,±2,...最小宽度a=(a+b)/第一次缺级级数最大衍射级=(a+b)/λ亮纹条件:(a+b)sin\\phi=k\\lambda k=0,\\pm1,\\pm2,...\\\\ 最小宽度a=(a+b)/第一次缺级级数\\\\ 最大衍射级=(a+b)/\\lambda\\\\ 亮纹条件:(a+b)sinϕ=kλk=0,±1,±2,...最小宽度a=(a+b)/第一次缺级级数最大衍射级=(a+b)/λ 三、光的偏振 自然光与偏振光 起偏和检偏 光第一次通过偏振片时，光强会减少一半，此时该偏振片称为起偏器，即用于产生偏振光； 当偏振片用来检验光的偏振状态时，叫做检偏器； 光透过偏振器后的光强为I=I0cos2θ光透过偏振器后的光强为I=I_0cos^2\\theta 光透过偏振器后的光强为I=I0​cos2θ Chapter4：狭义相对论 一、洛伦兹变换与侠义相对论的时空观 狭义相对论的两个基本假设 相对性原理：在任何一个惯性参考系中，物理规律的形式相同，简单地说就是所有的惯性系等价； 光速不变原理：真空中的光速在所有的惯性参考系中都相同，与观察者和光源的运动无关； 这一原理的一个直接结果是物体的运动速度不可能达到真空中的光速； 洛伦兹变换(狭义相对论的坐标变换) Example 两个观察者同时观察参考系K的坐标原点，坐标分别为x=0，x′=−vt′变换因子γ=11−v2c2&gt;1可以得到以下关系x′=γ(x−vt)y′=yz′=zt′=γ(t−vc2x)当v≪c时,变换因子γ=1用洛伦兹变换可以直接验证关系x2+y2+z2−c2t2=x′2+y′2+z′2−c2t′2两个观察者同时观察参考系K的坐标原点，坐标分别为x=0，x&#x27;=-vt&#x27;\\\\ 变换因子\\gamma=\\frac{1}{\\sqrt{1-\\frac{v^2}{c^2}}}&gt;1\\\\ 可以得到以下关系\\\\ x&#x27;=\\gamma(x-vt)\\\\ y&#x27;=y\\\\ z&#x27;=z\\\\ t&#x27;=\\gamma(t-\\frac{v}{c^2}x)\\\\ 当v\\ll c时,变换因子\\gamma=1\\\\ 用洛伦兹变换可以直接验证关系x^2+y^2+z^2-c^2t^2=x&#x27;^2+y&#x27;^2+z&#x27;^2-c^2t&#x27;^2 两个观察者同时观察参考系K的坐标原点，坐标分别为x=0，x′=−vt′变换因子γ=1−c2v2​​1​&gt;1可以得到以下关系x′=γ(x−vt)y′=yz′=zt′=γ(t−c2v​x)当v≪c时,变换因子γ=1用洛伦兹变换可以直接验证关系x2+y2+z2−c2t2=x′2+y′2+z′2−c2t′2 二、相对论力学 牛顿力学的核心规律牛顿第二定律F=dpdt,p=mv牛顿力学的核心规律\\\\ 牛顿第二定律 F=\\frac{dp}{dt},p=mv 牛顿力学的核心规律牛顿第二定律F=dtdp​,p=mv 相对论质量与动量 相对论质量m=m01−v2c2式中m0是与物体保持相对静止的观察者测得的物体质量，简称静止质量利用相对论质量，物体的相对论动量是p=mv=m0v1−v2c2相对论质量m=\\frac{m_0}{\\sqrt{1-\\frac{v^2}{c^2}}}\\\\ 式中m_0是与物体保持相对静止的观察者测得的物体质量，简称静止质量\\\\ 利用相对论质量，物体的相对论动量是p=mv=\\frac{m_0v}{\\sqrt{1-\\frac{v^2}{c^2}}} 相对论质量m=1−c2v2​​m0​​式中m0​是与物体保持相对静止的观察者测得的物体质量，简称静止质量利用相对论质量，物体的相对论动量是p=mv=1−c2v2​​m0​v​ 相对论动能 Ek=mc2−m0c2E_k=mc^2-m_0c^2 Ek​=mc2−m0​c2 相对论的总能量和质能关系 一个质点的相对论总能量为E=Ek+m0c2=mc2静止能量为E0=m0c2一个质点的相对论总能量为E=E_k+m_0c^2=mc^2\\\\ 静止能量为E_0=m_0c^2 一个质点的相对论总能量为E=Ek​+m0​c2=mc2静止能量为E0​=m0​c2 Chapter5：物质的波粒二象性 一、黑体辐射与能量子 为了描述物体发射电磁波的本领，定义辐出度e(T)； 其物理意义是单位时间内从辐射源表面单位面积发出的辐射能量，单位是W/m²； 对应某一特定波长的辐出度称为单色辐出度，用e(λ,T)表示； 其物理意义是单位时间内从辐射源表面单位面积发出的单位波长间隔的辐射能量； 总辐出度与单色辐出度有一下关系 e(T)=∫0∞e(λ,T)dλe(T)=\\int_0^\\infty e(\\lambda,T)d\\lambda e(T)=∫0∞​e(λ,T)dλ 黑体与黑体辐射 物体的吸收系数与物体的温度和入射波的波长都有关系，波长在λ~λ+dλ范围内的吸收数叫做单色吸收系数，用符号a(λ,T)表示； 通常，我们把能够完全反射所有波长光波的物体叫做白体，白体的吸收系数a(λ,T)=0； 能够完全吸收所有波长光波的物体叫做黑体，黑体的吸收系数a(λ,T)=1； 介于二者之间的物体叫灰体，灰体的吸收系数满足0＜a(λ,T)＜1； 有一些物体只对某些波长或者某段的光有明显的吸收，对其他波长吸收很少或者不吸收，这样的物体称为选择性吸收体； 实际中，那些有色反光物就属于选择性吸收体。 黑体是一个理想的物理模型，它并不等同于黑色的物体，因为黑色的物体也会有少量地反射电磁波，吸收系数不是绝对等于1； 现实生活中，绝对的白体或黑体并不存在； 研究表明，吸收能力越强的物体，辐射本领也越强相同温度条件下，任何物体的单色辐出度与吸收系数的比值都相同，且都等于黑体的单色辐出度即e1(λ,T)a1(λ,T)=e2(λ,T)a2(λ,T)=...=e0(λ,T)e0(λ,T)代表黑体的单色辐出度，只是波长和温度的函数研究表明，吸收能力越强的物体，辐射本领也越强\\\\ 相同温度条件下，任何物体的单色辐出度与吸收系数的比值都相同，且都等于黑体的单色辐出度\\\\ 即\\frac{e_1(\\lambda,T)}{a_1{(\\lambda,T)}}=\\frac{e_2(\\lambda,T)}{a_2{(\\lambda,T)}}=...=e_0(\\lambda,T)\\\\ e_0(\\lambda,T)代表黑体的单色辐出度，只是波长和温度的函数\\\\ 研究表明，吸收能力越强的物体，辐射本领也越强相同温度条件下，任何物体的单色辐出度与吸收系数的比值都相同，且都等于黑体的单色辐出度即a1​(λ,T)e1​(λ,T)​=a2​(λ,T)e2​(λ,T)​=...=e0​(λ,T)e0​(λ,T)代表黑体的单色辐出度，只是波长和温度的函数 黑体辐出度与温度关系式 e(T)=σT4式中,σ=5.670373∗10−8W⋅m−2⋅K−4,称为斯特藩常量e(T)=\\sigma T^4\\\\ 式中,\\sigma=5.670373\\ast10^{-8}W\\cdot m^{-2}\\cdot K^{-4},称为斯特藩常量\\\\ e(T)=σT4式中,σ=5.670373∗10−8W⋅m−2⋅K−4,称为斯特藩常量 黑体辐射能谱峰值对应的波长λm与黑体温度的关系 λmT=b式中,常量b=2.8977721×10−3m⋅K该结果成为维恩位移定律，常量b称为维恩位移常量不难发现，温度升高，能谱峰值对应的波长变短\\lambda_mT=b\\\\ 式中,常量b=2.8977721\\times10^{-3}m\\cdot K\\\\ 该结果成为维恩位移定律，常量b称为维恩位移常量\\\\ 不难发现，温度升高，能谱峰值对应的波长变短\\\\ λm​T=b式中,常量b=2.8977721×10−3m⋅K该结果成为维恩位移定律，常量b称为维恩位移常量不难发现，温度升高，能谱峰值对应的波长变短 维恩辐射公式e(λ,T)=c1λ−5e−c2/(λT)式中,c1和c2是两个常量维恩辐射公式e(\\lambda,T)=c_1\\lambda^{-5}e^{-c_2/(\\lambda T)}\\\\ 式中,c_1和c_2是两个常量\\\\ 维恩辐射公式e(λ,T)=c1​λ−5e−c2​/(λT)式中,c1​和c2​是两个常量 空腔辐射的辐出度按波长分布的瑞利—金斯公式e(λ,T)=2πcλ4kT式中,k是玻尔兹曼常量,c是真空中光速空腔辐射的辐出度按波长分布的瑞利—金斯公式\\\\ e(\\lambda,T)=\\frac{2\\pi c}{\\lambda^4}kT\\\\ 式中,k是玻尔兹曼常量,c是真空中光速\\\\ 空腔辐射的辐出度按波长分布的瑞利—金斯公式e(λ,T)=λ42πc​kT式中,k是玻尔兹曼常量,c是真空中光速 维恩公式在短波波段与实验符合较好，而瑞丽−金斯公式在长波波段与实验曲线相吻合德国物理学家普朗克得到了一个经验公式,现称为普朗克公式e(λ,T)=2πhc2λ51ehcλkT−1式中,h=6.626070040(81)×10−34J⋅s是一个常量，与黑体的材料，性质和温度都无关，叫做普朗克常量在波长很小的时候，普朗克公式成为维恩公式；波长很大时，普朗克公式可以得到瑞丽−金斯公式维恩公式在短波波段与实验符合较好，而瑞丽-金斯公式在长波波段与实验曲线相吻合\\\\ 德国物理学家普朗克得到了一个经验公式,现称为普朗克公式\\\\ e(\\lambda,T)=\\frac{2\\pi hc^2}{\\lambda^5}\\frac{1}{e^{\\frac{hc}{\\lambda kT}-1}}\\\\ 式中,h=6.626070040(81)\\times10^{-34}J\\cdot s是一个常量，与黑体的材料，性质和温度都无关，叫做普朗克常量\\\\ 在波长很小的时候，普朗克公式成为维恩公式；波长很大时，普朗克公式可以得到瑞丽-金斯公式\\\\ 维恩公式在短波波段与实验符合较好，而瑞丽−金斯公式在长波波段与实验曲线相吻合德国物理学家普朗克得到了一个经验公式,现称为普朗克公式e(λ,T)=λ52πhc2​eλkThc​−11​式中,h=6.626070040(81)×10−34J⋅s是一个常量，与黑体的材料，性质和温度都无关，叫做普朗克常量在波长很小的时候，普朗克公式成为维恩公式；波长很大时，普朗克公式可以得到瑞丽−金斯公式 光电效应的实验规律可以归纳为以下四条 光电子出现与否与照射金属所用光的强度没有直接关系。仅当照射物体的光频率不小于某个确定值时，物体才能发出光电子，这个频率叫做红限频率(或截止频率)，相应的波长叫做红限波长。不同物质的红限波长是不同的； 光电子脱出物体时的初速度或者出动能和照射光的频率有关而和光强无关，并且光电子的初始动能与入射光的频率有线性关系； 从实验知道,产生光电流的过程非常快,一般不超过10−9s;光照停止,光电流也随之停止。这表明,光电效应是瞬时的。从实验知道,产生光电流的过程非常快,一般不超过10^{-9}s;\\\\ 光照停止,光电流也随之停止。这表明,光电效应是瞬时的。 从实验知道,产生光电流的过程非常快,一般不超过10−9s;光照停止,光电流也随之停止。这表明,光电效应是瞬时的。 饱和电流与入射光的强度成正比，也就是说单位时间内从金属表面逸出的光电子数目与入射光的强度成正比。 爱因斯坦的光量子(光子)理论 爱因斯坦把量子性从辐射的机制引申到光本身上，认为光本身也不是连续的，光不仅在吸收和发射时是量子化的，而且光本身也是量子化的； 具体来说，爱因斯坦认为，一束频率为ν的光，是一束光子流每个光子具有ϵ=hν的能量光电效应就是光子与电子碰撞的结果根据能量守恒，可以写出以下等式hν=W+12mv2左边是入射光子的能量右边第一项W是将束缚在金属中的电子打出所需要的最小能量,成为逸出功右边第二项是出射光电子的初始动能Ek=12mv2,也是最大动能方程的物理意义为:入射光子的能量,一部分用来克服束缚电子的势场做功,余下的就变成了电子的动能该式也成为爱因斯坦方程根据遏止电压的定义,遏止电压满足eUa=Ek爱因斯坦方程本身就是光子频率与光电子初动能或者遏止电压的线性关系由于碰撞是瞬时的,只要光子的能量足够大,光电子就会马上出现,不需要时间的积累光强较强时,光子较多,光电子相应的也会增多,光电流也随之增大具体来说，爱因斯坦认为，一束频率为\\nu的光，是一束光子流\\\\ 每个光子具有\\epsilon=h\\nu的能量\\\\ 光电效应就是光子与电子碰撞的结果\\\\ 根据能量守恒，可以写出以下等式\\\\ h\\nu=W+\\frac{1}{2}mv^2\\\\ 左边是入射光子的能量\\\\ 右边第一项W是将束缚在金属中的电子打出所需要的最小能量,成为逸出功\\\\ 右边第二项是出射光电子的初始动能E_k=\\frac{1}{2}mv^2,也是最大动能\\\\ 方程的物理意义为:入射光子的能量,一部分用来克服束缚电子的势场做功,余下的就变成了电子的动能\\\\ 该式也成为爱因斯坦方程\\\\ 根据遏止电压的定义,遏止电压满足eU_a=E_k\\\\ 爱因斯坦方程本身就是光子频率与光电子初动能或者遏止电压的线性关系\\\\ 由于碰撞是瞬时的,只要光子的能量足够大,光电子就会马上出现,不需要时间的积累\\\\ 光强较强时,光子较多,光电子相应的也会增多,光电流也随之增大\\\\ 具体来说，爱因斯坦认为，一束频率为ν的光，是一束光子流每个光子具有ϵ=hν的能量光电效应就是光子与电子碰撞的结果根据能量守恒，可以写出以下等式hν=W+21​mv2左边是入射光子的能量右边第一项W是将束缚在金属中的电子打出所需要的最小能量,成为逸出功右边第二项是出射光电子的初始动能Ek​=21​mv2,也是最大动能方程的物理意义为:入射光子的能量,一部分用来克服束缚电子的势场做功,余下的就变成了电子的动能该式也成为爱因斯坦方程根据遏止电压的定义,遏止电压满足eUa​=Ek​爱因斯坦方程本身就是光子频率与光电子初动能或者遏止电压的线性关系由于碰撞是瞬时的,只要光子的能量足够大,光电子就会马上出现,不需要时间的积累光强较强时,光子较多,光电子相应的也会增多,光电流也随之增大 光的波粒二象性概念 爱因斯坦认为光是波动性和粒子性的复合体，光具有波粒二象性； 光子的波动性与粒子性是光子本性在不同条件下的表现； 波动性突出表现在其传播过程中，粒子性则突出表现在物体的电磁辐射与吸收，光子与物质的相互作用中； 需要指出的是，在同一条件下，光子或者表现出粒子性，或者表现出波动性，两者不可能同时都表现出来； 光子的粒子性:ϵ=hν光子的波动性:p=mc2c=hνc=hλ这两个关系也被称为爱因斯坦关系这里，起着桥梁作用的是普朗克常量h光子的粒子性:\\epsilon=h\\nu\\\\ 光子的波动性:p=\\frac{mc^2}{c}=\\frac{h\\nu}{c}=\\frac{h}{\\lambda}\\\\ 这两个关系也被称为爱因斯坦关系\\\\ 这里，起着桥梁作用的是普朗克常量h\\\\ 光子的粒子性:ϵ=hν光子的波动性:p=cmc2​=chν​=λh​这两个关系也被称为爱因斯坦关系这里，起着桥梁作用的是普朗克常量h 三、康普顿散射 利用光子的概念，爱因斯坦成功解释了光电效应的各项试验结果。但是，光电效应涉及的只是光子的能量，而没有涉及光子的动量。作为一个粒子，光子具有动量，应该能够得到实验的直接证实，而康普顿散射实验直接证实了光子动量的存在。 康普顿散射实验 光子与电子的碰撞 散射射线波长的改变量Δλ=λ−λ0=2hm0csin2θ2=hm0c(1−cosθ)式中,常量hm0c是一个具有长度量纲的量,称为电子的康普顿波长用符号λc表示,λc=0.00243nm散射射线波长的改变量\\\\ \\Delta\\lambda=\\lambda-\\lambda_0=2\\frac{h}{m_0c}sin^2\\frac{\\theta}{2}=\\frac{h}{m_0c}(1-cos\\theta)\\\\ 式中,常量\\frac{h}{m_0c}是一个具有长度量纲的量,称为电子的康普顿波长\\\\ 用符号\\lambda_c表示,\\lambda_c=0.00243nm\\\\ 散射射线波长的改变量Δλ=λ−λ0​=2m0​ch​sin22θ​=m0​ch​(1−cosθ)式中,常量m0​ch​是一个具有长度量纲的量,称为电子的康普顿波长用符号λc​表示,λc​=0.00243nm 四、物质波与德布罗意关系 德布罗意设想，具有波动性的光可以具有粒子性，那么对于实物粒子很可能也具有波动性。德布罗意进一步猜测，关于光子的亮哥哥爱因斯坦关系式，是否适用于实物粒子？通过电子在晶体上的衍射实验，直接证证实了电子的波动特性。此后，人们相继证实了原子，分子，中子等都具有波动性。德布罗意的设想最终都得到了完全的证实。这样，所有的物质都具有波粒二象性，这些波被称为德布罗意波，也叫做物质波。 德布罗意关系 德布罗意将爱因斯坦关系推广到一般情况，对于所有物质有如下关系:E=hν=h‾ωp=hλ=h‾k式中,h‾=h2π,园频率ω=2πν,波数k=2πλ此为德布罗意关系式子左边的动量和能量描述粒子特征,而式子右边的波长和频率描述波动特征德布罗意将爱因斯坦关系推广到一般情况，对于所有物质有如下关系:\\\\ E=h\\nu=\\overline{h}\\omega\\\\ p=\\frac{h}{\\lambda}=\\overline{h}k\\\\ 式中,\\overline{h}=\\frac{h}{2\\pi},园频率\\omega=2\\pi\\nu,波数k=\\frac{2\\pi}{\\lambda}\\\\ 此为德布罗意关系\\\\ 式子左边的动量和能量描述粒子特征,而式子右边的波长和频率描述波动特征\\\\ 德布罗意将爱因斯坦关系推广到一般情况，对于所有物质有如下关系:E=hν=hωp=λh​=hk式中,h=2πh​,园频率ω=2πν,波数k=λ2π​此为德布罗意关系式子左边的动量和能量描述粒子特征,而式子右边的波长和频率描述波动特征 五、氢原子和玻尔的量子论 α粒子的散射实验：原子的有核结构模型； 氢原子的光谱特性 任何原子的光谱都是线状的,而且每种原子都具有自己的特征光谱氢原子光谱是最简单的一种原子光谱σ=1λ=R(122−1n2),n=3,4,5,...式中,σ称为波数,即波长的倒数R称为氢原子的里德伯常量,等于1.0973731568508(65)×107m−1这一公式所表达的一组光谱线称为巴尔末系任何原子的光谱都是线状的,而且每种原子都具有自己的特征光谱\\\\ 氢原子光谱是最简单的一种原子光谱\\\\ \\sigma=\\frac{1}{\\lambda}=R(\\frac{1}{2^2}-\\frac{1}{n^2}),n=3,4,5,...\\\\ 式中,\\sigma称为波数,即波长的倒数\\\\ R称为氢原子的里德伯常量,等于1.0973731568508(65)\\times10^7m^{-1}\\\\ 这一公式所表达的一组光谱线称为巴尔末系\\\\ 任何原子的光谱都是线状的,而且每种原子都具有自己的特征光谱氢原子光谱是最简单的一种原子光谱σ=λ1​=R(221​−n21​),n=3,4,5,...式中,σ称为波数,即波长的倒数R称为氢原子的里德伯常量,等于1.0973731568508(65)×107m−1这一公式所表达的一组光谱线称为巴尔末系 之后发现分布在氢可见光区右侧的紫外及红外光谱区的若干谱线系他们可以用综合公式表示为σ=1λ=R(1m2−1n2)式中,m是正整数且m&lt;n之后发现分布在氢可见光区右侧的紫外及红外光谱区的若干谱线系\\\\ 他们可以用综合公式表示为\\\\ \\sigma=\\frac{1}{\\lambda}=R(\\frac{1}{m^2}-\\frac{1}{n^2})\\\\ 式中,m是正整数且m&lt;n\\\\ 之后发现分布在氢可见光区右侧的紫外及红外光谱区的若干谱线系他们可以用综合公式表示为σ=λ1​=R(m21​−n21​)式中,m是正整数且m&lt;n 玻尔的量子论 首先利用爱因斯坦的光子概念，得到了氢原子能量量子化的结果式 En=−Rhcn2E1=−13.6ev,这是氢原子的最低能量,对应的状态称为基态n≥2时的状态叫做激发态,例如n=2,3的状态分被称为第一激发态和第二激发态氢原子的能量是分离的,也称之为量子化的E_n=-\\frac{Rhc}{n^2}\\\\ E_1=-13.6ev,这是氢原子的最低能量,对应的状态称为基态\\\\ n≥2时的状态叫做激发态,例如n=2,3的状态分被称为第一激发态和第二激发态\\\\ 氢原子的能量是分离的,也称之为量子化的\\\\ En​=−n2Rhc​E1​=−13.6ev,这是氢原子的最低能量,对应的状态称为基态n≥2时的状态叫做激发态,例如n=2,3的状态分被称为第一激发态和第二激发态氢原子的能量是分离的,也称之为量子化的 然后假设电子绕原子核的运动仍然遵从牛顿运动定律,就得到了电子轨道半径和角动量的量子化结果式 电子圆周运动半径的量子化结果:rn=e28πϵ0Rhcn2与能量的下脚标一样,半径的下脚标表示半径与整数n有关这些半径统称为玻尔半径角动量为L=r×p=rmv=nh2π电子圆周运动半径的量子化结果:r_n=\\frac{e^2}{8\\pi\\epsilon_0Rhc}n^2\\\\ 与能量的下脚标一样,半径的下脚标表示半径与整数n有关\\\\ 这些半径统称为玻尔半径\\\\ 角动量为L=r\\times p=rmv=n\\frac{h}{2\\pi}\\\\ 电子圆周运动半径的量子化结果:rn​=8πϵ0​Rhce2​n2与能量的下脚标一样,半径的下脚标表示半径与整数n有关这些半径统称为玻尔半径角动量为L=r×p=rmv=n2πh​ 这些就是波尔理论的基本内容 综上所述，波尔理论包含以下三条假设 原子中电子运动轨道量子化假设：电子只能在一些特定的轨道上运行而不辐射电磁波。这时原子处于稳定状态，简称定态； 原子能级的跃迁假设：原子从一个定态跃迁到另一个定态时，原子辐射一定频率的光子，光子的能量由这两种定态的能量差决定； 角动量的量子化假设。 Chapter6：量子力学基础 一、物质波波函数的特性 自由粒子的波函数形式 在经典物理中,介质中沿某个方向传播的简谐波(平面波)的形式为y(x,t)=Acos[2π(νt−xλ)]也可以将其写成复数形式y(x,t)=Ae−i2π(νt−xλ)实际存在的波是复数形式的实部在经典物理中,介质中沿某个方向传播的简谐波(平面波)的形式为\\\\ y(x,t)=Acos[2\\pi(\\nu t-\\frac{x}{\\lambda})]\\\\ 也可以将其写成复数形式\\\\ y(x,t)=Ae^{-i2\\pi(\\nu t-\\frac{x}{\\lambda})}\\\\ 实际存在的波是复数形式的实部\\\\ 在经典物理中,介质中沿某个方向传播的简谐波(平面波)的形式为y(x,t)=Acos[2π(νt−λx​)]也可以将其写成复数形式y(x,t)=Ae−i2π(νt−λx​)实际存在的波是复数形式的实部 物质波的波函数用符号ψ(x,t)表示ψ(x,t)=Aei(px−Ekt)h‾物质波的强度代表粒子在空间出现的概率,所以波函数也因此称为概率幅将波函数推广到三维情况,有ψ(r,t)=Aei(p⋅r−Ekt)h‾物质波的波函数用符号\\psi(x,t)表示\\\\ \\psi(x,t)=Ae^{\\frac{i(px-E_kt)}{\\overline{h}}}\\\\ 物质波的强度代表粒子在空间出现的概率,所以波函数也因此称为概率幅\\\\ 将波函数推广到三维情况,有\\psi(r,t)=Ae^{\\frac{i(p\\cdot r-E_kt)}{\\overline{h}}}\\\\ 物质波的波函数用符号ψ(x,t)表示ψ(x,t)=Aehi(px−Ek​t)​物质波的强度代表粒子在空间出现的概率,所以波函数也因此称为概率幅将波函数推广到三维情况,有ψ(r,t)=Aehi(p⋅r−Ek​t)​ 不确定原理 ΔxΔpx=h值得注意的是,该乘积是一个绝对常量如果考虑到其他亮纹,电子动量不确定度会大于上式中给出的数值变为 ΔxΔpx≥h该关系称为海森伯不确定关系此外还有Δp=hλ2Δλ\\Delta x\\Delta p_x=h\\\\ 值得注意的是,该乘积是一个绝对常量\\\\ 如果考虑到其他亮纹,电子动量不确定度会大于上式中给出的数值\\\\ 变为\\,\\Delta x\\Delta p_x≥h\\\\ 该关系称为海森伯不确定关系\\\\ 此外还有\\Delta p=\\frac{h}{\\lambda^2}\\Delta\\lambda\\\\ ΔxΔpx​=h值得注意的是,该乘积是一个绝对常量如果考虑到其他亮纹,电子动量不确定度会大于上式中给出的数值变为ΔxΔpx​≥h该关系称为海森伯不确定关系此外还有Δp=λ2h​Δλ 二、薛定谔方程 波函数的标准条件 物质波的波函数为复数，因此在某一时刻在空间某处发现例子的概率正比于波函数ψ(r,t)与其共轭ψ*的乘积； 在体积dV=dxdydz内发现粒子的概率正比于|ψ|²dV=ψψ*dV； 对于某个粒子，要么出现在空间的这个区域，要么出现在另一个区域。换句话说，在整个空间找到这个自理的概率是100% 所以有∫∣ψ∣2dV=1此式称为波函数的归一化条件满足此式的波函数成为归一波函数归一化后,波函数的绝对值的平方是概率密度经典波的振幅具有实际意义,例如机械波的振幅代表位移等,因此不存在归一化问题所以有\\int|\\psi|^2dV=1\\\\ 此式称为波函数的归一化条件\\\\ 满足此式的波函数成为归一波函数\\\\ 归一化后,波函数的绝对值的平方是概率密度\\\\ 经典波的振幅具有实际意义,例如机械波的振幅代表位移等,因此不存在归一化问题\\\\ 所以有∫∣ψ∣2dV=1此式称为波函数的归一化条件满足此式的波函数成为归一波函数归一化后,波函数的绝对值的平方是概率密度经典波的振幅具有实际意义,例如机械波的振幅代表位移等,因此不存在归一化问题 在给定的时刻，粒子在空间某处出现的概率必须是一个确定的数值，因此波函数ψ(r,t)应该是单值和有限的； 此外，概率不会在某处发生突变，因此波函数也要求是连续的； 总之，物质波的波函数应该是单值，有限和连续的，这就是波函数要满足的标准条件。 量子力学的基本方程——薛定谔方程 对于做非相对论运动的粒子，动能与动量的关系为E=p22m对于自由粒子,动能就是其总能量,所以去掉了动能中的下脚标k下面主要讨论的是非相对论情况,习惯上我们仍然用E表示非相对论粒子的机械能,或者非相对论的总能量‾E=\\frac{p^2}{2m}\\\\ 对于自由粒子,动能就是其总能量,所以去掉了动能中的下脚标k\\\\ 下面主要讨论的是非相对论情况,习惯上我们\\pmb{\\underline{仍然用E表示非相对论粒子的机械能,或者非相对论的总能量}}\\\\ E=2mp2​对于自由粒子,动能就是其总能量,所以去掉了动能中的下脚标k下面主要讨论的是非相对论情况,习惯上我们仍然用E表示非相对论粒子的机械能,或者非相对论的总能量​​仍然用E表示非相对论粒子的机械能,或者非相对论的总能量​​​仍然用E表示非相对论粒子的机械能,或者非相对论的总能量​ 一维定态薛定谔方程的求解 三、一维定态系统 一维无限深方势阱 四、氢原子 薛定谔方程 描述氢原子状态的三个量子数 我们关注氢原子的三个物理量：能量，角动量和角动量的分量。在量子力学中，它们的取值都是分离的，或者说是量子化的； 氢原子的能级为 En=−mee42h‾(4πϵ0)2n2,n=1,2,3,...量子数n称为主量子数‾基态能量E1=−13.6ev上式也可以写成En=−13.6n2E_n=-\\frac{m_ee^4}{2\\overline{h}(4\\pi\\epsilon_0)^2n^2},n=1,2,3,...\\\\ 量子数n称为\\underline{\\pmb{主量子数}}\\\\ 基态能量E_1=-13.6ev\\\\ 上式也可以写成E_n=\\frac{-13.6}{n^2}\\\\ En​=−2h(4πϵ0​)2n2me​e4​,n=1,2,3,...量子数n称为主量子数主量子数主量子数​基态能量E1​=−13.6ev上式也可以写成En​=n2−13.6​ 角动量的二次方取值为 L2=l(l+1)h‾量子数l叫做角量子数‾的取值为l=0,1,2,3,...,n−1将角动量的二次方开方,在量子数l很大的情况下得到于玻尔理论相同的结果在光谱学中,用符号s,p,d,f,g,h表示量子数l=0,1,2,3,4,5的状态角动量的z分量或者第三分量的取值为Lz=mlh‾对于给定的l,量子数ml也叫磁量子数,其取值为:0,±1,±2,...,±lL^2=l(l+1)\\overline{h}\\\\ 量子数l叫做\\underline{\\pmb{角量子数}}的取值为l=0,1,2,3,...,n-1\\\\ 将角动量的二次方开方,在量子数l很大的情况下得到于玻尔理论相同的结果\\\\ 在光谱学中,用符号s,p,d,f,g,h表示量子数l=0,1,2,3,4,5的状态\\\\ 角动量的z分量或者第三分量的取值为L_z=m_l\\overline{h}\\\\ 对于给定的l,量子数m_l也叫磁量子数,其取值为:0,\\pm1,\\pm2,...,\\pm l\\\\ L2=l(l+1)h量子数l叫做角量子数角量子数角量子数​的取值为l=0,1,2,3,...,n−1将角动量的二次方开方,在量子数l很大的情况下得到于玻尔理论相同的结果在光谱学中,用符号s,p,d,f,g,h表示量子数l=0,1,2,3,4,5的状态角动量的z分量或者第三分量的取值为Lz​=ml​h对于给定的l,量子数ml​也叫磁量子数,其取值为:0,±1,±2,...,±l 磁量子数ms=±12,自旋量子数s=12磁量子数m_s=\\pm\\frac{1}{2},自旋量子数s=\\frac{1}{2}\\\\ 磁量子数ms​=±21​,自旋量子数s=21​ 电子的概率分布 电子云 五、电子的自旋 原子的壳层结构 电子的自旋 泡利不相容原理 1925年，泡利提出 在一个原子中，不可能有两个或两个以上地电子具有完全相同的量子态，即原子中的任何两个电子不可能有完全相同的一组量子数; 壳层结构 原子的电子组态 早在1916年，W.Kossel提出多电子原子中核外电子按壳层分布的形象化模型。他认为主量子数n相同的电子组成一个主壳层，对应于n=1,2,3,4,5,6,…的各个主壳层分别用大写字母K,l,M,N,O,P,…表示； 在每一主壳层内，又按角量子数l分为若干支壳层，l=0,1,2,3,4,5,…的支壳层分别用小写字母s,p,d,f,g,h,…表示； 对于确定的n和l，用nl表示，如1s,2s,2p,…； 泡利原理指出，每一支壳层和每一主壳层上可以占据的电子数是有限的，一些支壳层和主壳层可以容纳的电子数如下表所示 n\\l 0 s 1 p 2 d 3 f 4 g 5 h 6 i Zn 1 K 2 2 2 L 2 6 8 3 M 2 6 10 18 4 N 2 6 10 14 32 5 O 2 6 10 14 18 50 6 P 2 6 10 14 16 22 72 7 Q 2 6 10 14 16 22 26 98 电子在原子中的分布还符合能量最小原理：当原子处于正常状态时，原子中的电子尽可能地占据未被填充地最低能级。可见，能量较低的壳层首先被电子填充，只有当低能级地壳层被填充满后，电子才依次向高能级地壳层填充； 当一个原子中的每个电子状态n和l均被指定后，则称该原子具有一定的电子组态。","categories":[{"name":"Physics","slug":"Physics","permalink":"https://cheeseburgerim.github.io/categories/Physics/"}],"tags":[{"name":"Physics","slug":"Physics","permalink":"https://cheeseburgerim.github.io/tags/Physics/"}]},{"title":"文件管理","slug":"OperationSystem/OSChapter3","date":"2020-12-31T08:04:00.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2020/12/31/OperationSystem/OSChapter3/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/31/OperationSystem/OSChapter3/","excerpt":"","text":"文件管理 Points RAID 独立磁盘冗余阵列； 把硬盘组合在一起，组成一个磁盘阵列；实现对数据的可靠性，读写快速性，冗余性廉价性的存储； 功能： 提高I/O能力——磁盘并行读写； 提高耐用性——磁盘冗余来实现； 磁盘镜像，奇偶校验可提高RAID可靠性；","categories":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/categories/OS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"}]},{"title":"内存管理","slug":"OperationSystem/OSChapter2","date":"2020-12-29T11:04:51.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2020/12/29/OperationSystem/OSChapter2/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/29/OperationSystem/OSChapter2/","excerpt":"","text":"一、内存管理 1.内存的基础知识 逻辑地址与物理地址 Eg：编译时只需确定变量x存放的相对地址是100(也就是说相对于进程在内存中的起始地址的地址)。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可； 相对地址又称逻辑地址，绝对地址又称物理地址。 装入内存的三种方式 绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。 绝对装入由于逻辑与实际内存地址相同，故不需要对程序的数据的地址进行修改。 绝对装入只适用于弹道程序环境，绝对地址可由程序员在编译或者汇编时赋予。 可重定位装入：在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的，此时采用可重定位装入方式，根据内存的目前情况，将装入模块装入到内存的适当位置。装入时对目标程序中指令和数据的修改称为重定位，地址变换通常是在装入时一次完成的，所以又称静态重定位。 动态运行时装入：也称为动态重定位。程序在内存中如果发生移动，就素要采用动态的装入方式。编译，链接后的装入模块的地址都是从0开始的。装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换成绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持。动态重定位的特点是可以将程序分配到不连续的存储区中，在程序运行之前可以只装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配的内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。用于现代操作系统。 2.内存管理的概念 操作系统作为系统资源的管理者，当然也需要对内存进行管理 操作系统负责内存空间的分配与回收； 操作系统需要提供某种技术从逻辑上对内存空间进行扩充； 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换； 操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰。 内存空间的扩展 内存空间的扩充：利用虚拟存储技术或者自动覆盖技术，从逻辑上扩充内存。 Eg：游戏GTA5的大小约100G，按理来说运行这个游戏需要把100G的数据全部放入内存。然而，我的电脑实际内存只有8G(虚拟技术-操作系统的虚拟性)。 内存保护 保证各道作业在各自的存储空间内运行，互不干扰，有以下两种方式： CPU中设置一对上，下限寄存器，存放用户作业在主存中的上限和下限，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断是否越界； 通过采用重定位寄存器(或基址寄存器)和界地址寄存器(又称限长寄存器)来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值，每个逻辑地址值必须小于界地址寄存器，内存管理结构动态得将逻辑地址与界地址寄存器进行比较，如果未发生地址越界。则加上重定位寄存器的值后映射成物理地址，再送交内存单元。 内存的覆盖与交换 覆盖技术 由于程序运行时并非任何时候都要访问程序及数据的各个部分(尤其是大程序)，因此可以把用户空间分成一个固定区和若干个覆盖区。将经尝活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段； 特点：打破了必将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而需要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻保存。 交换技术 交换技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间的动态调度)； 换入：把准备好竞争CPU运行的程序从辅存移到内存； 换出：把处于等待状态(或CPU调度原则下被剥夺运行权力)的程序从内存移到辅存，把内存空间腾出来； 暂时换出外存等待的进程状态为挂起状态(suspend)，挂起态又可以进一步细分为就绪挂起，阻塞挂起两种状态； 3.连续分配管理方式 内部碎片：分配给某进程的内存区域中，没有用上的部分； 外部碎片：内存中的某些空闲分区由于太小而难以利用。 单一连续分配 内存在此方式下分为系统区和用户区； 系统区仅提供给操作系统使用，通常在低地址部分； 用户区是为用户提供的，除系统区外的内存空间，我们平常运行的软件都在用户区里分配空间； 优点：无外部碎片，可以采用覆盖技术，不需要额外技术支持； 缺点：只能用于单用户，单任务操作系统中，有内部碎片，存储器利用率极低。 固定分区分配 固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后背作业队列中，选择适当大小的作业装入该分区，如此循环； 优点：实现简单，无外部碎片； 缺点：程序可能太大而放不进任何一个分区中，这是用户不得不使用覆盖技术来使用内存空间。 动态分区分配 又称可变分区分配，是一种动态划分内存的分区方法； 这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态建立分区，并使分区的大小正好适合进程的需要； 因此系统分区的大小和数目是可变的； 缺点：外部碎片很多(通过紧凑消除，就是操作系统不时地对进程进行移动和整理。但是这是要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于Windows系统中的磁盘整理程序，只不过后者是对外存空间的紧凑)。 4.动态分区分配算法 首次适应算法 算法思想：每次都从低地址开始查找，找到一个能满足大小的空闲分区； 实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 最佳适应算法 算法思想：由于动态分区是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片地空闲区，即优先使用更小的空闲区； 实现：空闲区按容量递增地次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 最坏适应算法 又称最大适应算法 算法思想：为了解决最佳适应算法问题——留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用； 实现：空闲区按容量递减地次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 邻近适应算法 算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束地位置开始检索，就能解决上述问题； 实现：空闲分区以地址递增地顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束地位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 5.存储管理 分页式存储管理 如果允许将一个进程直接分散地装入到许多不相邻的分区中，则无须再进行“紧凑”。基于这一思想而产生了离散分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式。在分页存储管理方式中，如果不具备页面对换功能，则称为基本分页存储管理方式，或称为纯分页存储管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。 逻辑地址结构：页号+页内偏移量； 一个进程对应一张页表； 进程的每一页对应一个页表项； 每个页表项由页号和块号组成； 页表记录进程页面和实际存放的内块之间的对应关系； 每个页表项的长度是相同的，页号是隐含的。 分段式存储管理 引入分段存储管理方式，主要是为了满足用户和程序员地一系列需要 方便编程，信息共享，信息保护，动态增长，动态链接 原理：在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等，如图4-17所示。每个段都有自己的名字。为了实现简单起见，通常可用一个段号来代替段名，每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，亦即，其逻辑地址由段号(段名)和段内地址所组成。 逻辑地址结构：段号+段内地址； 段页式存储管理 段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。 在段页式系统中，一作业地址结构由段号、段内页号及页内地址三部分所组成。 段页式存储的实现结合了页式和段式管理的基本思想，即用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间。 逻辑地址结构：段号+页号+页内偏移量。 分段，分页管理对比 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理.上的需要，完全是系统行为，对用户是不可见的。段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。-一个段通常包含着一-组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。 在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。 分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的。 6.多级页表 根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面也可以正常运行了，因此没有必要让整个页表都常驻内存。 单级页表问题 页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框； 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需访问某几个特定的页面； 减少页表所占的内存空间。 7.快表 又称联想寄存器(TLB)，是一种访问速度比内存快很多的高速缓冲寄存器，用来存放当前访问的若干页表项，以加速地址变换的过程； 与此对应，内存中的页表称为慢表。 8.倒排页表 优点：减少占用的内存空间； 缺点：更长的查询时间；进程间共享内存实现更困难。 存储的时有关每个物理页框的信息，所以倒排页表项与物理内存页框有一一对应关系，它所包含的页表项数量较少。 Eample：物理地址空间4GB，页面长4KB，页表项大小为4B。故倒排页表共有4GB/4KB=1M个页表项，倒排页表大小为1M×4B=4MB。 系统维护一张倒排页表； 使用Hash散列，可以解决倒排页表不便于逻辑地址向物理地址转换的问题。 二、虚拟内存 1.虚拟内存的基本概念 虚拟内存只能基于非连续分配技术； 传统存储管理方式的特征，缺点 一次性(可用虚拟存储技术解决问题)：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题： 1.作业很大时，不能全部装入内存，导致大作业无法运行； 2.当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的，暂时用不到的数据，浪费了宝贵的内存资源。 局部性原理 时间局部性：如果执行力程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环) 空间局部性：一旦程序访问量某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中是连续存放的，并且程序的指令页式顺序的在内存中存放的) 虚拟地址的定义和特征 定义 在操作系统的管理下，用户看到似乎有一个比实际内存大得多的内存，就是虚拟内存。 特征 多次性：无需在作业运行时一次性全部装入内存，而是运行被分成多次调入内存； 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行的过程中，将作业换出，换入； 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量。 实现 请求分页存储管理； 请求分段式存储管理； 请求段页式存储管理。 请求分页系统建立在基本分页系统的基础上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种虚拟存储器方法。 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存(操作系统要提供请求调页或请求调段功能)，然后继续执行程序。 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存(操作系统要提供页面置换或段置换的功能)。 2.请求分页管理方式 缺页中断 定义：缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。 3.页面置换算法 最佳置换法(OPT) 先进先出置换算法(FIFO) 最近最久未使用置换算法(LRU) 时钟置换算法(CLOCK)(NRU:最近未使用) 改进型的时钟置换算法 老化算法 修改：第一是计数器在R位被加进来之前右移一位； 第二是将R位加到计数器的最左端； LRU的近似实现。 工作集置换算法 一个进程当前正在使用的页面集合称为它的工作集； 如果整个工作集都被装入到了内存中，那么进程在运行到下一运行阶段之前，不会产生很多缺页中断； 如果内存太小而无法容纳下整个工作集，那么进程的运行过程会产生大量的缺页中断，导致运行速度变得很缓慢； 原理： 进程设置一个虚拟时钟，执行一个时钟周期就加 1，不执行就不增加。 每个页面被访问时，记录最后访问的虚拟时间，R 位置 1。R 位定期 清除。 如果 R=1,则保留，将当前时间记录下来。 如果 R=0 对 比当前虚拟时间与页面最后访问时间差 age 与阈值 τ，如 age&gt;τ 则淘汰。如果 age &lt;= τ，则记录其访问时间，必要时淘汰其中最旧的。 总结 算法 算法规则 优缺点 OPT 优先淘汰最长时间内不会被访问的页面 缺页率最小，性能最好；但无法实现 FIFO 优先淘汰最先进入内存的页面 实现简单；但性能很差，可能出现Belady现象 LRU 优先淘汰最近最久没访问过的页面 性能很好；但需要硬件支持，算法开销大 CLOCK 循环扫描各页面，第一轮淘汰访问位=0的，并将扫描过的访问位改为1；若第一轮没选中，则进行第二轮扫描 实现简单，算法开销小；但未考虑页面是否被修改过 Improved CLOCK 若用(访问位，修改位)的形式表述，则第一轮淘汰(0,0)；第二轮淘汰(0,1)，并将扫描过的页面的访问位都置为0；第三轮淘汰(0,0)；第四轮淘汰(0,1) 算法开销较小，性能也不错 老化算法 4.页面分配 页面分配，置换策略 Points 增大块表(TLB)，让页表常驻内存能够加快虚实地址转换； TLB：转译后备缓冲区 段页式存储的实现结合了页式和段式管理的基本思想，即用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间； 交换区：存在于数据服务器上的一个共享文件夹。它的作用是为前台与后台数据交换提供一个场所； 当系统内存不足，特殊应用程序(如oracle，lotus notes等)有需求时，将挂载交换区空间； 主存==内存； Belady现象：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象； 系统抖动： - 解释为在请求分页存储管理中，从主存(DRAM)中刚刚患处某一页面后，根据请求马上又换入该页，这种反复换出换入的现象； - 主存与辅存间频繁的页面置换现象； - 产生该现象的主要原因是置换算法选择不当； 虚拟存储器只能基于非连续分配技术； 物理地址至少是：页表大小×物理存储区块数 Example：设有8页的逻辑空间，每页有1024B，它们被映射到32块的物理存储区中。 逻辑地址有效位：1024×8=23×210=2^13，即13位； 物理地址至少位数：1024×32=210×25=2^15，即15位； 无论用什么算法，缺页次数不会少于页面引用串中不同的页号的个数； 有些程序并不适合于按需调页，例如：二分法搜索； 可以被多个进程在任意时刻共享的代码必须是不能自身修改的代码； 若用户进程访问内存时产生缺页，则操作系统可能执行的操作是置换页或分配内存； 变址寄存器：至寄存器ESI,EDI,SI和DI的寄存器，它们主要用于存放存储单元在段内的偏移量； 变址寻址：把变址寄存器中的内容(通常是位移量)与指令地址码部分给出的地址(通常是首地址)之和作业操作数的地址来获得所需要的操作数； Example：假设变址寄存器 R 的内容为 1000H，指令中的形式地址为 2000 H；地址 1000H 中的内容为2000H，地址2000H中的内容为3000H，地址3000 H中的内容为4000H， 则变址寻址方式下访问到的操作数是： 4000H 解析：变址寻址方式下有效地址EA=R+A=1000H+2000H=3000H，操作数S=地址3000H中的内容，即4000H； 在请求分页系统中，页表中的辅存始地址是供页面调入参考的； 页表项中最多可以保存的标志位位数=页表项最大位数-页框号位数； Example：页表项大小为4B，页面大小为1KB，逻辑地址空间为32位，物理地址空间为4GB。 解：页表项共有4×8=32位；物理地址空间共32位；页内偏移量10位；页框号22位； ∴标志位位数=32-22=10位； 逻辑地址访问时间：设对主存的一次存取需要100ns，对TLB表查找的时间为10ns，缺页中断处理时间为10^8ns 逻辑地址对应的页号在内存中且在TLB表中：100+10=110ns； 逻辑地址对应的页号在内存中但不在TLB表中：10+100+100=210ns； 逻辑地址页号不在内存中：10^8+220ns。 页表项中有效位为0时，即不在内存中，缺页； 分段式内存管理解决了分页式内存管理中划分页时仅根据大小划分，这样可能将无关的内容分到一页中，此页不便设置权限与保护，也不利于共享。也有可能把密切相关的内容分到不同页中，当页面置换算法不当时，内存紧张时容易形成抖动现象。分段式内存管理带来的问题是段往往过大，多次分配释放后可能形成大量外部碎片，内存利用率不高； Intel IA32 的保护模式下内存管理方法不是段页式内存管理方法。因为段页式内存管理是分段时段内再分页，整个是一件事。而保护模式是通过分段将逻辑地址转换成线性地址，第二步通过分页将线性地址转成物理地址，这是两件事。 LRU 需求记录所有页面长期运行中被使用的时间和次数，需要大量的快速存 储空间，而且比较复杂，不容易实现。替代方案可以采用老化（aging）算法， 每个页面有一个长度有限的记数器，记录每个 tick 内 页面使用情况，记录信 息的权重逐次递减。这种算法与 LRU 相比，不能记录每个 tick 中内存使用情 况，而且记录的位数有限，但是实现方案较易实现。 分页式：逻辑地址空间划分只简单依靠页面大小，缺乏内在逻辑性，导致一方 面相关内容被分散 到多页上，页面置换不当时容易造成内存抖动，另一方面 不同性质的内容被分到同一页中，使得页面 权限保护设置困难。 分段式：段 体积大，在内存中无法不连续存储，易形成内存外碎片，降低内存利用率。 段页式：先分段再分页，以段为单位调入调出，以页为单位在内存中不连续存 储，既保证了相关内容 同时进出内存，便于设置权限保护，又可以充分利用 内存空间。 段页式结构复杂，实现起来效率低，所以没有被广泛采用。 最差适应分配最大空间的分区给进程使用，以期剩余外碎片空间较大，再 次利用的可能性较大。固定分区无外碎片，故不应采用这种算法。 交换技术交换的单位是进程，请求式分段技术交换的单位是段。 请求式分段是操作系统进行段调入调出，此过程对程序员透明，而覆盖技术需 要程序员自己完成调入调出。 页面置换应该在内存空余空间小于一个固定的下限阈值时开始，并在达到 另一个上限阈值时停止。 OPT 最理想但不可能实现。 LRU 要求比较最近最少 使用的页面，条件多，要存储的数据量大，比较的时间长，很难实现。 Belady 异常指的时当增加页框时缺页中断发生的数量反而升高的现象。 FIFO 存在 Belady 异常。 分段比分页更有逻辑性，将同类的或相关的内容放在一个段内，这样不会 由于页面置换算法选择不当而形成“抖动”现象。同类内容划分在一个 段内，可以实现段的保护，如代码段设置为只读，数据段设置为读写。公共代码段可以通过映射共享到多个进程。段页式既按照相关性划分 段，继承了分段的优势，又有分页管理可以不连续存储，能够充分利 用空间的好处。 缓存主要用于解决 CPU 和内存之间存在的速度差。一般来说，CPU 中寄 存器的速度要远快于内存，将 CPU 要用到的数据预先从内存中读到缓存，这 样 CPU 使用时就可以快速得到数据，写回内存的过程也类似。TLB 就是使用 缓存的一个典型例子。 在 64 位系统中，由于虚拟地址太大，普通页表会非常大，无法存储。另一方 面，实际内存 相对较小，所以建立一张从物理地址索引得到相对地址的倒排 页表。 最大的问题的难于从相对地址查找到绝对地址。可以采用 hash 表ᨀ高 查找效率，并使用 TLB 加速查找。 老化算法与 LRU 相比，主要有两点区别：（1）老化算法记录使用情况的 寄存器只有有限位， 比如 8 位，无法记录所有使用情况。（2）同一时间间隔 内只使用 0/1 区分页面使用情况，无法详 细区别间隔内的具体时间 内存分区管理中的交换技术与请求式分段技术的相同点与不同点：相同点都是为了在内存不足的情况下装入更多的进程，都是会产生外碎片。 不同点为交换 技术交换的对象是整个进程而请求式分段交换的进程中的一个段。","categories":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/categories/OS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"}]},{"title":"GTAV","slug":"Game/GTAV","date":"2020-12-27T01:52:24.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2020/12/27/Game/GTAV/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/27/Game/GTAV/","excerpt":"","text":"","categories":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"}],"tags":[{"name":"Fun","slug":"Fun","permalink":"https://cheeseburgerim.github.io/tags/Fun/"},{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"GTAV","slug":"GTAV","permalink":"https://cheeseburgerim.github.io/tags/GTAV/"}]},{"title":"进程管理","slug":"OperationSystem/OSChapter1","date":"2020-12-22T09:09:09.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2020/12/22/OperationSystem/OSChapter1/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/22/OperationSystem/OSChapter1/","excerpt":"","text":"信号量(Semaphore) 一个整型变量； 按取值范围分类： 1.Semaphore∈R Semaphore={positive可用资源数量Zero无可用资源，无等待进程Negative等待进程的数量Semaphore=\\begin{cases}positive 可用资源数量\\\\ Zero 无可用资源，无等待进程\\\\ Negative 等待进程的数量\\\\ \\end{cases} Semaphore=⎩⎪⎨⎪⎧​positive可用资源数量Zero无可用资源，无等待进程Negative等待进程的数量​ 2.非负数 3.0/1(mutex，互斥锁)-二进制信号量 PV操作 ：一种实现进程互斥与同步的有效方法，P表示通过，V表示释放； P：s–，if(s&lt;0) add to the semaphore’s queue and sleep； V：s++，if(s&lt;=0) wake up the waiting process in the semaphore’s queue； 进程状态 只有running和ready之间可以相互转换 Example： Ready： 进程正等待进入内存； 进程正等待分给它一个时间片； Running： 进程正等待中央处理机； Blocked： 进程正等待合作进程的一个消息； 进程间关系 同步 进程之间这种相互合作，协同工作的关系称为进程的同步； 直接制约 多个相关进程在执行次序上的协调； 互斥 临界资源：也称独占资源，是指在一段时间内只允许一个进程访问的资源。例如打印机，磁带机，也可以是进程共享的数据，变量等； 间接制约； 当多个进程因为争夺临界资源二互斥执行称为进程的互斥。 进程与线程 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位； 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线； 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间，包括代码段，数据集，堆等，及一些进程及的资源，某进程内的线程在其他进程不可见； 不管系统中是否有线程，进程都是拥有资源的独立单位； 在不支持线程的操作系统中，进程既是资源分配的基本单位，也是调度的基本单位； 在拥有线程的操作系统中，线程是调度的基本单位，而进程是资源分配的基本单位； 对于切换时是否需要内核的支持，系统级线程需要，用户级线程不需要； 同一进程中的线程共享同一物理内存空间。 线程 用户态线程与内核态线程 所谓用户态线程就是把内核态的线程在用户态实现了一遍而已，目的是更轻量化（更少的内存占用、更少的隔离、更快的调度）和更高的可控性（可以自己控制调度器）。用户态所有东西内核态都「看得见」，只是对于内核而言「用户态线程」只是一堆内存数据而已。 死锁 定义 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 当系统中供多个进程共享的资源如打印机，公共队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。 条件 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只有一个进程占用。如果此时还有其他进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放； 请求和保持条件：指进程已经保持至少一个资源，但是又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放； 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完成时自己释放； 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0,P1,P2,…,Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源,…,Pn正在等待已被P0占用的资源。 预防 采用按序分配资源策略可以防止死锁，这是因为它能破坏产生死锁的四个必要条件中的环路等待条件； 在操作系统中，常用以下方法应对死锁： 鸵鸟算法：因为处理死锁成本太高，而死锁出现的频率较低，故可以忽略死锁的发生； Spooling技术：假脱机技术。为临界资源增加一个等待队列，使其好像可以被共享使用，如打印机。 当死锁发生时，杀死运行时间较短的进程，损失较小，容易恢复。 用户态和内核态的转换 方式 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作； 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常； 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这是CPU会暂停执行吓一跳即将要执行的指令而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的转换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 银行家算法 定义 银行家算法是一个避免死锁的著名算法，它以银行贷款系统的分配策略为基础，判断并保证系统的安全运行。 银行家算法可避免死锁，但没有破坏死锁发生的四个必要条件中的任何一个。 安全状态 如果存在一个由系统中所有进程构成的安全序列P1,P2,…,Pn，则系统处于安全状态。安全状态一定是没有死锁发生。 不安全状态 不存在一个安全序列。不安全状态不一定导致死锁。 时间片轮换调度算法 定义 每次调度时，总是选择就绪队列的队首进程，让其在CPU上运行一个系统预先设置好的时间片。一个时间片内没有完成运行的进程，返回到队列末尾重新排队，等待下一次调度。 进程饥饿 定义 指当等待时间给进程推进和响应带来明显影响称为进程饥饿。当饥饿到一定程度的进程在等待到即使完成也无实际意义的时候称为饥饿死亡。 预防 公平的调度算法可以避免饥饿现象，例如时间片轮换算法，所有进程的地位相同； 例如静态优先级调度，非抢占式作业优先调度，抢占式短作业优先调度算法等可能导致饥饿现象。 非抢占式优先权调度算法 系统一旦把处理机分配给优先权最高的进程后，便一直执行下去至完成； 抢占式优先调度算法 只要系统中出现一个新的就绪进程，就进行优先权比较。若出现优先权更高的进程，则立即停止当前进程的执行，并将处理机分配给新到的优先权最高的进程。 处理机调度 处理机调度的层次 在多道程序系统中，调度实质是一种资源分配，处理机调度算法是指根据处理机分配策略随规定的处理机分配算法。一个作业从获得处理机执行到作业运行完毕，可能会经历多级处理机调度。 1.高级调度 高级调度又称为长程调度或者作业调度，它的调度对象是作业。主要功能是根据某种算法，决定将外村上处于后备队列中哪几个作业调入内存，为它们创建进程，分配必要的资源，并将它们放入就绪队列。高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度。作业调度的频率很低，周期很长，大约几分钟一次。 2.中级调度 中级调度又称为内存调度，引入中级调度的主要目的是，提高内存利用率和系统吞吐量。中级调度的作用就是将暂时不能运行的进程，调至外存等待(挂起转台)，和将外村上已满足条件的就绪进程调入内存中。内存调度的频率和周期处于作业调度和进程调度之间。 3.低级调度 低级调度又称进程调度或者短程调度，它的调度对象是进程。其主要功能是，根据某种算法，决定就绪队列中的哪个进程获得处理机。并由分派程序将处理机分派给选择的进程。进程调度是一种最基本的调度，在多道批处理，实时和分时三种类型的OS中，都必须配置这级调度。进程调度的频率很高，周期很短，在分时系统中大概仅10-100ms。 先来先服务(FCFS) 短作业优先(SJF) 时间片轮转调度算法(RR) 高响应比优先调度(HRRN)：响应比=周转时间/执行时间=1+等待时间/执行事件 read：参数只包含输入流 open：参数应包含文件的名称 fork()函数 复刻(英语：fork，又译作派生，分支)是UNIX或类UNIX中的分叉函数，fork函数将运行着的程序分成两个(几乎)完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。这两个进程中的线程继续执行，就像是两个用户同时启动了该应用程序的两个副本。 fork系统调用用于创建一个新进程，称为子进程，它与进程(称为系统调用fork的进程)同时运行，此进程称为父进程。创建新的子进程后，两个进程执行fork()系统调用之后的下一条指令。子进程使用相同的pc(程序计数器)，相同的CPU寄存器，在父进程中使用的相同打开文件。 它不需要参数并返回一个整数值 return={positive返回父进程或调用者。该值包含新创建的子进程的进程IDzero返回到新创建的子进程nagetive创建子进程失败return= \\begin{cases} positive &amp;{返回父进程或调用者。该值包含新创建的子进程的进程ID}\\\\ zero &amp;{返回到新创建的子进程}\\\\ nagetive &amp;{创建子进程失败} \\end{cases} return=⎩⎪⎨⎪⎧​positivezeronagetive​返回父进程或调用者。该值包含新创建的子进程的进程ID返回到新创建的子进程创建子进程失败​ exec系列函数 用exec函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID。 系统调用exec系列函数后，fork函数创建的子进程才拥有自己独立的新代码段。 该系统调用替换进程的正文段，如果成功，没有返回值，如果失败，返回值为-1。 周转时间 定义 等待时间+程序执行事件，执行完成时间点-进入系统时间 平均周转时间 =总周转时间/进程个数 平均带权周转时间(以执行时间为权值) =(Σ周转时间/执行时间)/进程个数 读者写者问题 读者优先 写者，读者互斥访问文件资源； 多个读者可以同时访问文件资源 只允许一个写者访问文件资源。 写者优先 写者线程的优先级高于读者线程； 当有写者到来时应该堵塞读者线程的队列； 当有一个写者正在写或在阻塞队列时应当阻塞读者进程的操作，直到所有写者进程完成写操作时开放读者进程； 当没有写者进程时读者进程能够同时读取文件。 公平竞争 优先级相同； 写者，读者互斥访问； 只能有一个写者访问临界区； 可以有多个读者同时访问临界资源。 Points 可以被多个进程在任意时刻共享的代码必须是不能自身修改的代码。 若代码可以被多个进程在任意时刻共享，则要求一个进程在调用此段代码时都以同样的方式运行；而且进程在运行过程中被中断后再继续执行，其执行结果也不受影响。这必然要求代码不能自身更改，否则无法满足共享的要求。这样的代码就是可重入代码，也叫纯代码，即允许多个进程同时访问的代码。 共有n台互斥使用的同类设备，m个并发进程，分别需要x1,x2,…,xm个设备，为确保系统不发生死锁，n最小为x1+x2+…+xm-m+1； 分析：当每个进程都差最后一个设备时，即x1-1,x2-1,…,xm-1，这是申请不到最后一个设备，因此造成死锁，所以再添加一个设备即可； 中断指令：CPU正常运行期间，停止当前操作，执行其他特殊操作的行为就叫做中断，负责跳转的指令就是中断指令。中断指令不能在用户态执行，只能在内核态执行。 系统中进程执行时，I/O时间比决定了进程优先级，I/O时间比越大，进程优先级越高。 中断处理过程与子程序调用压栈时的区别： 都不需要保存通用数据寄存器和通用地址寄存器； 子程序调用时，由于系统硬件限制，只保存程序计数器的内容； 中断处理一定会保存而子程序调用不需要保存的内容时程序状态字寄存器。 CPU与I/O可同时进行 Example：一个多道批处理系统中仅有P1和P2两个作业，P2比P1晚5 ms到达。它们的计算和 I/O操作顺序如下： P1：计算 60 ms，I/O 80 ms，计算 20 ms P2：计算 120 ms，I/O 40 ms，计算 40 ms 若不考虑调度和切换时间，则完成两个作业需要的时间最少是260ms。 I/O操作：指对设备与CPU连接的接口电路的操作。 临界区：指的是一个访问公共资源(例如：共用设备或是共用寄存器)的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待，有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用，例如：信号量semaphore。只能被单一线程访问的设备，例如：打印机。 临界区是一段程序； 在进程处于临界区时可以进行处理机调度； 在系统调用完成并返回用户态时能进行处理机调度。 Example：假设系统中有4个进程和一个可分配资源，当前分配和最大需求如下表所示，已知资源总量为100。系统采用银行家算法避免死锁。 进程 MAX ALLOCATION NEED 1 50 20 30 2 50 15 35 3 50 30 20 4 50 10 40 在当前时刻若进程2请求资源数量为10，是否能实施分配？若能，给出安全序列。 ***解：***资源数量：100，减去已分配的资源75，还剩25；这是进程2请求资源10＜25，但是当分配后资源数量剩余15，不存在一个安全序列。 ∴不能分配，因为分配后不存在安全序列。 当检测到死锁发生时，如果必须杀死一个进程以解除死锁，一般选择运行时间较短的进程，因为这样重新运行的代价较小，另外，程序需要可以多次运行不影响执行结果，还要考虑杀死优先级较低的进程等。 分时操作系统中的进程调度算法对普通进程常常采用的是优先级轮转法，采用动态调整进程优先级的方法，动态降低长时间占用CPU进程的优先级，低优先级进程的优先级则相对提高，最终得到运行。通过此方法，保证不会有进程因为优先级太低而饥饿。","categories":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/categories/OS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"}]},{"title":"LabOfOS1","slug":"OperationSystem/LabOfOS1","date":"2020-12-22T03:28:13.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2020/12/22/OperationSystem/LabOfOS1/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/22/OperationSystem/LabOfOS1/","excerpt":"","text":"","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"}]},{"title":"Exercise","slug":"Algorithm/LabOfAlgorithm1","date":"2020-12-21T06:54:11.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2020/12/21/Algorithm/LabOfAlgorithm1/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/21/Algorithm/LabOfAlgorithm1/","excerpt":"","text":"回溯法解决子集和数问题 思路 回溯法可以理解成用深度优先算法遍历状态空间树，所以可以使用深度优先递归算法得到解； 定义MAXN为30，即暂时考虑最多有29个元素的集合； 在DFS函数中传入需要的参数： TotalWeight：当前子集中所选的元素之和； RestWeight：除选出的元素外剩余元素之和； x[ ]：问题的一个解，由0和1组成，0代表xi不取，1代表取，1≤i≤n； i：当前元素位置； n，m，w[ ]：元素个数，和数，和所给集合； 在DFS函数中： 当TotalWeight与m相等时，输出一个解； 加上当前元素时还小于m，考虑下一位置元素，继续递归； 若加上剩余元素时大于m，则不选择当前位置元素，继续递归； 递归结束时，即可得到所有解。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#define MAXN 30using namespace std;void Solution_DFS(int TotalWeight, int RestWeight, int x[], int i, int n, int m, int w[]);//回溯法解决子集和数问题int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; int w[MAXN] = &#123;0&#125;; int RestWeight = 0; for (int i = 1; i &lt;= n; i++) &#123; int temp; cin &gt;&gt; temp; w[i] = temp; RestWeight += temp; &#125; int x[MAXN] = &#123;0&#125;; Solution_DFS(0, RestWeight, x, 1, n, m, w); &#125; system(&quot;pause&quot;); return 0;&#125;void Solution_DFS(int TotalWeight, int RestWeight, int x[], int i, int n, int m, int w[])&#123; if (i &gt; n) &#123; if (TotalWeight == m) &#123; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; x[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; &#125; else &#123; if (TotalWeight + w[i] &lt;= m) &#123; x[i] = 1; Solution_DFS(TotalWeight + w[i], RestWeight - w[i], x, i + 1, n, m, w); &#125; if (TotalWeight + RestWeight &gt; m) &#123; x[i] = 0; Solution_DFS(TotalWeight, RestWeight - w[i], x, i + 1, n, m, w); &#125; &#125;&#125; Examples 链接：link num\\ N M 1 8 53 2 10 5482 3 21 2463098 4 10 50 5 9 100 6 6 22 7 10 50 动态规划解决矩阵乘法链问题 思路 使用动态规划方法解决矩阵乘法链问题，需在不同大小的子问题的优化值之间建立递归关系，得到最优解； 同时满足优化原理，即优化解包含的子问题的解也是优化解。使用枚举法建立不同长度子问题的优化值之间的递归关系； 求此问题的优化解，即求c(1,n)，c(1,n)=min{c(1,k)+c(k+1,n)+r1×r(k+1)×rn}，利用此式得到问题的解，再根据每次得到的k值回溯找到优化的乘法顺序； 在代码中，可以使用二维数组存放每次递归关系式中大括号中的每个值，最后找到最小值，即可得到问题的优化解。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;//动态规划解决矩阵乘法链问题const int INT_MAX=2147483647;const int MAXN=10;void Solution(int *r,int Length,int m[][MAXN],int s[][MAXN]);void POMCWP(int s[][MAXN],int i,int j);//Acronyms Print Optimal Matrix Chain With Parenthesesint main()&#123; int n; while(cin&gt;&gt;n) &#123; int r[MAXN]=&#123;0&#125;; for(int i=0;i&lt;n+1;i++) &#123; int temp; cin&gt;&gt;temp; r[i]=temp; &#125; int m[MAXN][MAXN],s[MAXN][MAXN]; Solution(r,n+1,m,s); cout&lt;&lt;&quot;Minimum: &quot;; cout&lt;&lt;m[1][n]&lt;&lt;endl; cout&lt;&lt;&quot;Order: &quot;; POMCWP(s,1,n); &#125; system(&quot;pause&quot;); return 0;&#125;void Solution(int *r,int Length,int m[][MAXN],int s[][MAXN])&#123; int q,n=Length-1; for(int i=1;i&lt;=n;i++) m[i][i]=0; for(int l=2;l&lt;=n;l++) &#123; for(int i=1;i&lt;=n-l+1;i++) &#123; int j=i+l-1; m[i][j]=INT_MAX; for(int k=i;k&lt;=j-1;k++) &#123; q=m[i][k]+m[k+1][j]+r[i-1]*r[k]*r[j]; if(q&lt;m[i][j]) &#123; m[i][j]=q; s[i][j]=k; &#125; &#125; &#125; &#125;&#125;void POMCWP(int s[][MAXN],int i,int j)&#123; if(i == j) cout&lt;&lt;&quot;M&quot;&lt;&lt;i; else &#123; cout&lt;&lt;&quot;(&quot;; POMCWP(s,i,s[i][j]); POMCWP(s,s[i][j]+1,j); cout&lt;&lt;&quot;)&quot;; &#125;&#125; Examples Q：p[MAXN]={30,35,15,5,10,20,25}； A：程序输出 12Minimum: 15125Order: ((M1(M2M3))((M4M5)M6)) Q：p[MAXN]={10,20,50,1,100}; A：程序输出 12Minimum: 2200Order: ((M1(M2M3))M4)","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Branch and Bound","slug":"Algorithm/AlgorithmChapter8","date":"2020-12-17T07:26:29.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2020/12/17/Algorithm/AlgorithmChapter8/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/17/Algorithm/AlgorithmChapter8/","excerpt":"","text":"分枝-限界法 分枝(Branching) 分枝：一个节点成为E-节点后，它要展开它的所有子节点；并将这些子节点放在一个称为活节点表的数据结构中；在活节点表中的节点可以展开所有状态空间树的节点，即广度优先遍历状态空间树； 按一定的规则从活节点表中取出一个节点作为E-节点进行展开； 活节点表可以是FIFO,LIFO和优先级队列； 当使用优先级队列时必须对活节点表中的节点赋以一个权值； 下文将结合求解优化为题介绍一种使用优先级队列的分枝-限界法。 最小成本优化问题 设x=(x1,x2,…,xn)为可行解的元组； 对每一个可行解有一个成本值，cost(x)； 求使cost(x)达到最小的可行解x； 使用搜索算法求解最小成本优化问题。 任意节点的成本函数c(x) 定义状态空间树上任一节点x的成本函数c(x)如下； 如x为可行叶节点，则c(x)=cost(x)； 否则，定义c(x)=从x展开状态空间树能得到的最小成本值(状态空间树上以x为根的子树中可行解成本的最小值)； 如其子树中无可行解，则c(x)=∞。 LC-检索 如果活节点表中每个节点以c(x)为权值，每次从活节点表中取出最小权值节点作为E-节点，则算法能很快找到优化解； 但在展开x前不可能知道c(x)的值。但是有可能从历史信息获得c(x)的某一下界c^(x)； 以c(x)的下界估值c(x)作为活节点表中节点的权值，每次取出有最小c(x)的节点进行展开； 要求设计的c(x)满足：c(x)=cost(x)，当x为可行叶节点时。 限界 令U为当前获得的最优成本值； 设x=(x1,x2,…,xn)，如果c^(x)&gt;=U，则停止展开子节点x，即，不将其放入活节点表； U初始值为∞，其后每一次的到一个新的可行解，用其成本值对U加以修改：U⬅min{U,cost(x)}。 Example：带截止期的作业调度问题 n个作业，1台处理机，每个作业i对应一个三元组(pi,di,ti)； pi：罚款额； di：截止期； ti：需要的处理机时间； 求可行的作业子集J，使得罚款额最小，其中j为不在J中的作业； 定长元组表示可行作业子集：(x1,x2,…,xn)； 设X=(x1,x2,…,xk)为状态空间树的节点； 下界c^(x)可估计为展开到x时已得到的罚款额：Σ(1-xj)pj，求和范围为1&lt;=j&lt;=k。 例题 LC-分枝-限界产生的部分状态空间树 调度问题的另一种状态空间树 可行条件(截止期)作为一种限界方法； c^(x)&gt;=U为另一限界方法； 下图中每个节点标注了2个数，上边的数为c^(x)，下边的数为该节点对应的可行解的罚款额，作为u(x)； 方框节点是非可行节点； 打叉的节点是被限界掉的节点。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Traceback","slug":"Algorithm/AlgorithmChapter7","date":"2020-12-15T10:24:06.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2020/12/15/Algorithm/AlgorithmChapter7/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/15/Algorithm/AlgorithmChapter7/","excerpt":"","text":"回溯 Example：8-皇后问题 8皇后问题的解可以表示为一个8-元组(x1,x2,…,x8)，其中xi是放在第i行的皇后所在的列号，则8皇后问题可形式化为pow(8,8)个8-元组中找满足以下约束条件的元组： 对于任意的i≠j，有xi≠xj；|xi-xj|≠|i-j|； 这pow(8,8)个8-元组构成的集合成为8皇后问题的解空间-搜索范围； 如果将约束条件之一，任意两个皇后不在同一列，加入到元组的定义中，这是每个8-元组为(1,2,3,4,5,6,7,8)的一个排列，解空间的大小由pow(8,8)个元组减少到8！个元组； 解空间不是唯一的，取决于算法的设计； 设计解空间时还要考虑生成解空间的算法复杂度；在8皇后问题中，如果加入第二个条件，解空间很难形成。 搜索问题的形式化-解空间 假定问题的解能用n-元组(x1,x2,…,xn)表示，其中xi取自某个有穷集Si； 这些n-元组构成的集合成为问题的解空间；假设|Si|=mi，则解空间的大小为m=m1m2…*mn； 我们考虑两类问题： 存在性问题：求满足某些条件的一个或全部元组，如果存在返回Yes，否则返回No。这些条件称为约束条件； 优化问题：给定一组约束条件，在满足约束条件的元组中求使某目标函数达到最大(小)值的元组。满足约束条件的元组成为问题的可行解。 解决这类问题的最一般方法使使用搜索技术，即系统化地搜索解空间地技术。 Example：子集和数问题 已知n+1个整数：wi，1&lt;=i&lt;=n，和M。要求找出{wi|1&lt;=i&lt;=n}的所有子集，使得子集内元素之和等于M； 例如：n=4，(w1,w2,w3,w4)=(11,13,24,7)，M=31。则满足要求的子集是(11,13,7)和(24,7)； 我们可以用wi的下标i构成的元组表示一个解，则这两个解可表示为(1,2,4)和(3,4)； 元组(1,2,4)和(2,1,4)代表同一子集，此为限制元组分量按升序排列，即不考虑元组(2,1,4)； 还可用其他方式表示一个解，如下： 解空间的状态空间树 任何搜索算法都可以用建立在解空间上的状态空间树加以描述； 状态空间树是我们尝试选择元组的各个分量时产生的树结构； 搜索算法并非事先将状态空间树存在计算机内再进行遍历，而是通过展开状态空间树来找所求的解； 展开过程中通过使用启发式的限界方法(剪去状态空间树上的某些分支)使搜算算法只展开状态空间树的一部分，从而降低搜索算法的时间和空间复杂度。 Example：n-皇后问题 n-皇后问题是8-皇后问题的推广。n个皇后将被放置在n×n的棋盘上且使得没有两个皇后可以互相攻击，其解空间由n-元组(1,2,…,n)的n！个排列组成； 其状态空间树如下图所示(n=4)。树的边由xi的可能的取值标记。由i级到i+1级节点的边给出xi的值，这种树成为排列树； 从根节点到叶节点的一条路径对应解空间的一个元组。 有关状态空间树的术语 状态空间树的每个节点代表问题求解过程中达到的一个状态，根节点到它的路径代表对一些分量已作出的选择。状态空间树的所有节点构成的集合成为求解该问题的状态空间； 根节点到状态空间树的一个节点X的路径可以表示为(x1,x2,…,xk)，其中xi，1&lt;=i&lt;=k，为搜索过程中已经选择的分量。今后我们也用这个元组标识该节点：X=(x1,x2,…,xk)； (x1,x2,…,xk)也对应一个子问题，即在后n-k个元组分量所对应的子空间上找满足要求的解。该子空间是状态空间树中以X为根的子树。所以也称节点X为问题节点； 如果从根节点到节点S的那条路径确定了解空间的一个元组，则称S为状态空间树的一个解节点； 如果一个解节点S(代表的元组)满足所有约束条件，则称其为答案节点。 状态空间树的展开方法 每个搜索算法都是一种系统地展开状态空间树地算法； 活节点：已展开了部分节点，但所有子节点尚未全部展开的节点； 死节点：被限界或已展开了所有子节点地节点； E-节点：当前正在展开子节点的活节点。 深度优先展开方法：一个E-节点展开自己的一个子节点后，就让该子节点成为E-节点的展开方法(相当于对状态空间树做深度优先搜索)。 回溯法：加限界的深度优先展开状态空间树的方法； 分枝-限界法：一个节点一旦成为E-节点，它将展开其全部子节点，之后自己变成死节点； 在分枝-限界法中要维持一个活节点表的结构，存放已展开但还未成为E-节点的那些节点。 限界 用回溯法解4-皇后问题 回溯的一般方法 每个解用数组X(1,n)来表示； 假定X1，X2,…,X(k-1)的值已确定，T(X1,X2,…,X(k-1))代表xk的所有可能的取值； 限界函数B(X1,X2,…,XK)判断那些Xk的取值不能导致问题的解，从而停止展开该子节点。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Dynamic Programming","slug":"Algorithm/AlgorithmChapter6","date":"2020-12-15T09:55:46.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2020/12/15/Algorithm/AlgorithmChapter6/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/15/Algorithm/AlgorithmChapter6/","excerpt":"","text":"动态规划 应用 0/1背包问题 矩阵乘法链 最短路径 最长公共子序列 原理 从算法设计的角度看，动态规划是一种在各个不同大小(size)的子问题的优化值之间建立递归关系并求解的过程； 能用动态规划求解的问题必须满足优化原理：优化解包含的子问题的解也是优化的； 利用优化原理，使用枚举法建立不同长度子问题的优化值之间的递归关系——动态规划方程； 动态规划得到的是精确解； 子问题的数目决定算法的复杂性； 实现时要尽可能消去递归。 Example：多段图-最短路径 多段图问题满足优化原理：最短路(1-&gt;3-&gt;5-&gt;7)上的子路径(3-&gt;5-&gt;7)是3到目的节点7在子图上的最短路； 无论最短路的下一跳是{2，3，4}中的那个节点，其后的路径也应是最短路； 节点1到目的的节点的最短路长度c(1)可从2，3，4到目的节点的最短路c(i)+节点1到这些节点的边成本cost(1,i)经枚举得到：c(1)=min{c(i)+cost(1,i)}，i∈{2，3，4}。 但2，3，4到目的节点的最短长度c(2),c(3),c(4)还不知道； 我们需计算c(2),c(3),c(4)；仍使用优化原理； 一般情形：设c(i)为i到目的节点的最短路长度，A(i)为与i相邻的节点集合，有：c(i)=min{c(j)+cost(i,j)}，j∈A(i)； 但c(i)由i到目的节点的子图在决定，和节点1怎样走到i没关系。 多段图的动态规划算法 从c(7)开始向前计算； 初始c(7)=0； 依次计算c(6),c(5),…,c(1)； c(6)=1，c(5)=2； c(4)=8+c(6)； c(3)=min{1+c(5),5+c(6)}； c(2)=min{7+c(5),6+c(6)}； c(1)=min{1+c(2),4+c(3),6+c(4)}； 递归还可以从前向后。 Example：0/1背包问题 0/1背包问题的解指物品1,2,…,n的一种放法(x1,x2,…,xn的0/1赋值)，使得效益值最大； 假定背包容量不足以装入所有物品：面临选择； 因为目标函数是非负数之和； 优化原理：无论优化解是否放物品1，相对剩余背包容量，优化解对物品2,3,…,n的放法也是优化解。 优化值间的递归式 虽然我们不知道优化解是否放物品1，但我们可以利用优化原理，从枚举&quot;放&quot;和&quot;不放&quot;两种情形建立优化值之间的递归式： 设f(i,y)为以背包容量y，放物品i,i+1,…,n，得到优化效益值，一下递归关系成立： f(1,c)=max{f(2,c),f(2,c-w1)+p1}(不放1和放1)； 先求子问题的优化值(递归)，再从2种可能性中选出最优的； 需求解：任意给定容量y，任意i,i+1,…,n种物品的子问题。 动态规划法步骤 在应用动态规划法时，须先验证欲求解的问题是否满足优化原理； 应用优化原理建立子问题优化解的值(优化值)之间的递归式； 解优化值满足的递归式； 回溯从优化值构造优化解； 算法复杂性 直接用递归实现动态规划递归方程往往会引发大量重复计算，算法的计算量变得非常可观；最好使用迭代法实现动态规划算法； 迭代实现需要存贮所有子问题的优化解的值f(i,y)，以便避免重复计算，所以算法往往需要较大的存储空间； 算法的复杂性来自子问题的数目，通常子问题的数目很大。 0/1背包问题DP算法的实现 1.递归实现 f(n,y)={Pny≥wn00≤y&lt;wnf(n,y)=\\begin{cases} Pn &amp; y≥wn\\\\ 0 &amp; 0≤y&lt;wn \\end{cases} f(n,y)={Pn0​y≥wn0≤y&lt;wn​ f(i,y)={max(f(i+1,y),f(i+1,y−wi)+pi)y≥wif(i+1,y)0≤y&lt;wif(i,y)=\\begin{cases} max(f(i+1,y),f(i+1,y-wi)+pi) &amp; y≥wi\\\\ f(i+1,y) &amp; 0≤y&lt;wi \\end{cases} f(i,y)={max(f(i+1,y),f(i+1,y−wi)+pi)f(i+1,y)​y≥wi0≤y&lt;wi​ ​ 说明：f(i,y)中，y≥wi的情况中，前者为不放i，后者为放i Example： 2.权为整数的迭代实现 当物品重量为整数时，可设计一相当简单的算法来求解f(1,c)； 该实现用二维数组 f [i] [y] 来保存每个f(i,y)的值，并且只计算一次； 二维数组需Θ(nc)空间； 函数Traceback从 f [i] [y] 产生优化的xi值； Knapsack的复杂性Θ(nc)，似乎是多项式算法。但因c的二进制输入长度为logc(2为底)，所以nc仍是输入长度的指数函数； Traceback的复杂性为Θ(n)。 Example：n=5，p=[6,3,5,4,6]，w=[2,2,6,5,4]，且c=10，求f(1,10) i\\y 0 1 2 3 4 5 6 7 8 9 10 缺点： 要求物品重量为整数； 当背包容量c很大时，例如c&gt;2n，需要Ω(n*2n)。 下述元组法克服了上述缺点。 3.元组法实现 元组法将函数f(i,y)的跳跃点以元组(y,f(i,y))形式存储于一个线性表P(i)中； 表P(i)中的元组(y,f(i,y))按y的增序排列； P(i)中的元组(a,b)表示：存在一种装物品{i,i+1,…,n}的方案，能以容量y，a≤y＜a‘，a’为下一元组的横坐标，得到效益值b； 下面给出从f(i+1,y)的线性表P(i+1)得出f(i,y)的线性表P(i)的算法； 按f(i,y)的定义：f(i,y)=max{f(i+1,y),f(i+1,y-wi)+pi}，首先需要从P(i+1)得到函数f(i+1,y)=f(i+1,y-wi)+pi的元组集合Q； 设(a,b)∈Q，则(a-wi,b-pi)必为P(i+1)的元组，反之亦然。所以，P(i+1)的每个元组(w,p)对应Q的一个元组(w+wi,p+pi)； Q的元组(u,v)代表装物品{i,i+1,…,y}的元组(即P(i)的元组)； 从P(i+1)和Q得到P(i)的元组： 因P(i+1)和Q内元组均按w和p的增序排列，所以可以用以前学过的merge算法进行合并； 合并时使用以下支配(选优)规则： 设(a,b)和(u,v)是来自P(i+1)和Q的元组，若a≥u且b＜v，则称(a,b)受(u,v)支配； 因为(a,b)代表以容量a得到效益值b的方案； 而(u,v)代表以较少的容量u得到较大效益值v的方案； 在合并时舍弃被支配的元组(选优)。 P(i+1)于Q合并，并按支配规则舍弃被支配的元组即可得到P(i)； 在产生P(i)时丢弃w&gt;c的元组(w,v)； 得到P(2)后不再产生P(1)： P(2)的最后一个元组是f(2,c)对应的元组； 设线性表P(2)中满足w+w1≤c的最后一个元组为(w,v)； 将v+p1于P(2)的最后一个元组对应的效益值p做比较，效益值大的即为优化效益值f(1,c)。 Example：n=5，p=[6,3,5,4,6]，w=[2,2,6,5,4]，且c=10，求f(1,10) 方便起见，w=[2,2,6,5,4]，p=[6,3,5,4,6]，(横坐标为W，纵坐标为P) P(5)={(0,0),(4,6)}, Q={(5,4),(9,10)}; P(4)={(0,0),(4,6),(9,10)}, delete(5,4), Q={(6,5),(10,11)}; P(3)={(0,0),(4,6),(9,10),(10,11)}, delete(6,5), Q={(2,3),(8,8),(7,7),(6,9)}; P(2)={(0,0),(2,3),(4,6),(6,9),(9,10),(10,11)}; (w1,p1)=(2,6)，P2中满足w+w1≤c的最后一个元组为(6,9)； ∵ (2,6)+(6,9)&gt;(10,11) ∴15为最大效益值，通过回溯法找到解为[1,1,0,0,1] 矩阵乘法链 m×n矩阵A于n×p矩阵B相乘需要做mnp个元素乘法； 计算三个矩阵A，B和C的乘积ABC有两种方法：(AB)C和A(BC)； 结果相同，但所需元素乘法数不同； 问题：对任意给定长度q的矩阵乘法链M1×M2,…,Mq，求优化的乘法顺序使得计算该乘法链所用的乘法数最少； 长度为q的矩阵乘法链有指数量级Ω(2^q)的可能乘法顺序(有q个叶节点的二叉树的数目)； 动态规划解 用M(i,j)表示Mi×Mi+1×…×Mj(i≤j)的乘积。假设优化的矩阵乘法顺序最后计算乘积M(i,k)×M(k+1,j)； 则计算M(i,j)的优化乘法顺序在计算子链M(i,k)和M(k+1,j)时也是优化的； 设c(i,j)为计算M(i,j)的优化乘法数(优化值)，根据优化原理，优化值之间满足： c(i,j)=min{c(i,k)+c(k+1,j)+ri*r(k+1)*r(j+1)}，i≤k&lt;j； 令kay(i,j)为达到最小值的k； 可用上述递归式计算c(1,q)； 用kay(i,j)回溯找到优化的乘法顺序。 Example：q=5，r=(10,5,1,10,2,10) 递归 c(1,5)=min{c(1,1)+c(2,5)+500, c(1,2)+c(3,5)+100, c(1,3)+c(4,5)+1000, c(1,4)+c(5,5)+200}; c(2,5)=min{c(2,2)+c(3,5)+50, c(2,3)+c(4,5)+500, c(2,4)+c(5,5)+100}; c(3,5)=min{c(3,3)+c(4,5)+100,c(3,4)+c(5,5)+20}; c(4,5)=min{c(4,4)+c(5,5)+200}=200; c(3,5)=c(3,4)+c(5,5)+20=20+0+20=40; c(2,5)=c(2,2)+c(3,5)+50=0+40+50=90; c(1,5)=c(1,2)+c(3,5)+100=50+40+100=190; 解为M(1,2)×M(3,4)×M(5,5); 迭代：可避免大量重复计算，但需要O(q²)的存储空间，时间复杂度为Θ(q³)。 s=2，3，4； s=2，计算c(1,3),c(2,4),c(3,5); s=3，计算c(1,4),c(2,5); s=4，计算c(1,5). All-Pair最短路问题 最短路径：设G为有向图，其中每条边都有一个成本(cost)，图中每条有向路径的长度(或成本)定义为该路径上各边的成本之和； 对于没对顶点(i,j)，定义从i到j的所有路径中，具有最小长度的路径为从i到j的最短路； All-Pair最短路问题：求每对点间的最短路； 假定图上无负成本的环路，这是只需考虑简单路径，加上环路只会增加路径成本。 动态规划解： 将节点按1到n编号； 定义c(i,j,k)=i到j的中间节点编号不超过k的最短路长度，即包含节点i和j即节点1,2,…,k的子图上的最短路； c(i,j,n)是在原来的图上i到j的最短路长度，即我们要求的最短路长度； 因为只考虑简单路径，所以： c(i,k,k)=c(i,k,k-1); c(k,j,k)=c(k,j,k-1); c(i,i,k)=0 for all k; 特别地，c(i,j,0)=cost(i,j)或∞。 Example： 建立c(i,j,k)和c(i,j,k-1)之间的递归关系； 对于任意k＞0，i到j的中间节点编号不超过k的最短路上，或包含节点k或不包含节点k，所以有递归如下： c(i,j,k)=min{c(i,j,k-1),c(i,k,k-1)+c(k,j,k-1)}； 如果直接用递归程序求解上式，则计算c(i,j,n)的复杂度极高。利用迭代方法可将计算c值得时间减少到O(n)³。 迭代算法伪代码： n令C(k)代表矩阵(c(i,j,k))i,j=1,…,n,因c(i,i,k)=0 for all k,所以矩阵C(k)的对角线元素为0. n算法迭代计算C(k) ,k=0,…,n n初始C(0)=(c(i, j)),即图的邻接矩阵,无边相连的i和j 令c(i, j)=∞. n因c(i,k,k)=c(i,k,k-1),c(k,j,k)=c(k,j,k-1),所以,矩阵C(k)的k行、k列上的元素不变: C(k)(i,k)=C(k-1)(i,k), C(k)(k,j)=C(k-1)(k,j). n矩阵C(k)非k行、k列上的元素,按下式计算 C(k)(i,j)←min{C(k-1)(i, j), C(k-1)(i, k)+ ​ C(k-1)(k,j)}, 即C(k)(i,j)←min{C(k-1)(i, j), C(k)(i, k)+ ​ C(k)(k,j)}, n所以算法只需使用一个矩阵,每次迭代时, 用第k列的i行元素和第k行的j列元素之和去更新元素C(k-1)(i, j). n算法迭代至多n次，每次迭代需O(n2)时间，所以算法的时间复杂度为O(n3). Example：最短路径 解： C(3)(1,2)=min{C(2)(1,2), C(2)(1,3)+C(2)(3,2)}=min{4, 6+7}=min{4, 13}=4; C(3)(2,1)=min{C(2)(2,1), C(2)(2,3)+C(2)(3,1)}=min{6, 2+3}=min{6, 5}=5. 最长公共子序列问题 首先需要说明，子序列与字串不同 一个给定的序列的子序列，就是将给定序列中零个或多个元素去掉之后的结果； 字串指给定串中任意个连续的字符组成的子序列； 可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中，可以避免大量的重复计算； 递归方程如下： C(i,j)={0,ifi=0orj=0C[i−1，j−1],ifi,j&gt;0andxi=yimax{C[i,j−1],c[i−1,j]}ifi,j&gt;0andxi≠yiC(i,j)=\\begin{cases} 0,&amp;if&amp;i=0orj=0\\\\ C[i-1，j-1],&amp;if&amp;i,j&gt;0andx_i=y_i\\\\ max\\{C[i,j-1],c[i-1,j]\\}&amp;if&amp;i,j&gt;0andx_i≠y_i \\end{cases} C(i,j)=⎩⎪⎨⎪⎧​0,C[i−1，j−1],max{C[i,j−1],c[i−1,j]}​ififif​i=0orj=0i,j&gt;0andxi​=yi​i,j&gt;0andxi​​=yi​​ Example：s1=[1,3,4,5,6,7,7,8]，s2=[3,5,7,4,8,6,7,8,2] 下标j 0 1 2 3 4 5 6 7 8 9 下标i s2 3 5 7 4 8 6 7 8 2 0 s1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 2 3 0 1 1 1 1 1 1 1 1 1 3 4 0 1 1 1 2 2 2 2 2 2 4 5 0 1 2 2 2 2 2 2 2 2 5 6 0 1 2 2 2 2 3 3 3 3 6 7 0 1 2 3 3 3 3 4 4 4 7 7 0 1 2 3 3 3 3 4 4 4 8 8 0 1 2 3 3 4 4 4 5 5 右下角元素即为最长公共子序列长度，得到问题的解。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Divide and Conquer","slug":"Algorithm/AlgorithmChapter5","date":"2020-12-15T02:18:48.000Z","updated":"2021-04-10T02:55:24.539Z","comments":false,"path":"2020/12/15/Algorithm/AlgorithmChapter5/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/15/Algorithm/AlgorithmChapter5/","excerpt":"","text":"分治法 分治法思想 分治法设计算法的思想是： 将问题分成(divide)多个子问题； 递归地解决(conquer)每个子问题； 将子问题的解合并(combine)成原问题的解。 分治法常常得到递归算法； Merge-Sort是用分治法设计算法的范例 算法复杂性分析 Master method Substitution method 适用条件 分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定程度就可以容易地解决； 该问题可以分解为若干个规模较小的子问题； 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 最后一条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用动态规划较好。 基本步骤 12345678910divide-and-conquer(P)&#123; if(P&lt;=n0) adhoc(P); //解决小规模的问题 divide P into smaller subinstances P1,P2,...,Pk; //分解问题 for(int i=1;i&lt;=k;i++) &#123; yi=divide-and-conquer(Pi); //递归地解决各子问题 return merge(y1,...,yk); //将各子问题地解合并成为原问题的解 &#125;&#125; 人们从大量实践中发现，在用分治法设计算法时，最好使子问题的规模大致相同。即将一个字问题分成大小相等的k个子问题的处理方法是行之有效的。这种使子问题规模大致相等的做法好是出自一种平衡子问题的思想，它几乎总是比子问题规模不等的做法要好。 应用 1.Defective Chessboard n=pow(4,k)； 需要(n-1)/3个3-方块填满棋盘； 算法的时间复杂度：t(n)=4t(n/4)+c，a=4，b=4，loga=1。∴t(n)=Θ(n)。 2.归并排序(Merge Sort) 我们采用平衡分割法来分割n个元素，即将n个元素分为A和B两个集合，其中A集合中含有n/k个元素，B中包含其余的元素； 然后递归地使用分治法对A和B进行排序； 当A或B内元素&lt;k时使用插入排序； 然后采用一个成为归并(merge)的过程，将已排好序的A和B合并成一个集合。 123456789101112131415template&lt;class T&gt;void sort(T E,int n)&#123;//对E中的n个元素进行排序，k为全局变量 if(n&gt;=k) &#123; i=n/k; j=n-i; 令A包含E中的前i个元素 令B包含E中余下的j个元素 sort(A,i); sort(B,j); merge(A,B,E,i,j); //把A和B合并到E &#125; else 使用插入排序算法对E进行排序&#125; 算法复杂度： 设t(n)为分治排序算法，则有以下递推公式 当n/k≈n-(n/k)时，t(n)的值最小(balance原理) 因此，当k=2时，分治法通常具有最佳性能：当k&gt;2时递归展开的深度超过 以2为底n的对数。 k=2时，有 3.快速排序(Quick Sort) 分治法还可以用于实现另一种完全不同的排序方法：快速排序； 在这种方法中，n个元素被分成三段，左短left，中段middle，右段right； 中段仅包含一个元素；左段中各元素都小于等于中段元素；右段中各元素都大于等于中段元素。因此left和right中的元素可以独立排序，并且不必对left和right的排序结果进行合并，middle中的元素被成为支点(pivot)。 1234567//伪代码//使用快速排序方法对a[0:n-1]排序//从a[0:n-1]中选择一个元素作为middle，该元素为支点//把余下的元素分割成为两段，left和right，使得left中的元素都小于等于支点，right中的元素都大于等于支点//递归地使用快速排序方法对left进行排序//递归地使用快速排序方法对right进行排序//所得结果为left+middle+right 快速排序的平均复杂性是Θ(nlogn)。 各种排序算法的比较 排序方法 比较次数 移动次数 稳定性 附加存储 最好 最差 最好 最差 最好 最差 直接插入排序 n n² 0 n² √ 1 1 折半插入排序 nlogn nlogn 0 n² √ 1 1 冒泡排序 n n² 0 n² √ 1 1 快速排序 nlogn n² nlogn n² × logn n² 简单选择排序 n² n² 0 n × 1 1 锦标赛排序 nlogn nlogn nlogn nlogn √ n n 堆排序 nlogn nlogn nlogn nlogn × 1 1 归并排序 nlogn nlogn nlogn nlogn √ n n 4.选择(Selection Problem) 定义：对于给定的n个元素的数组a[0:n-1]，要求从中找出第k小的元素； 选择问题可在O(nlogn)时间内解决，方法是首先对这n个元素进行排序(如使用堆排序或归并排序)，然后取出a[k-1]中的元素； 若使用快速排序，可以获得更好的平均性。尽管该算法在最坏情形下有一个比较差的渐进复杂性O(n²)。 123456789101112131415161718192021222324252627282930313233343536template&lt;class T&gt;T Select(T a[],int n,int k)&#123; //返回a[0:n-1]中第k小的元素 //假定a[n]是一个伪最大元素 if(k&lt;1||k&gt;n) throw OutOfBound(); return select(a,0,n-1,k);&#125;template&lt;class T&gt;T select(T a[],int l,int r,int k)&#123; //在a[l:r]中选择第k小的元素 if(l&gt;=r) return a[l]; int i=l;//从左至右的游标 int j=r+1;//从右到左的游标 T pivot=a[l]; //把左侧&gt;=pivot的元素与右侧&lt;=pivot的元素进行交换 while(1) &#123; do&#123;//在左侧寻找&gt;=pivot的元素 i=i+1; &#125;while(a[i]&lt;pivot)； do&#123;//在右侧寻找&lt;=pivot的元素 j=j-1; &#125;while(a[j]&gt;pivot) if(i&gt;=j) break;//未发现交换对象 Swap(a[i],a[j]); &#125; if(j-l+1==k) return pivot; //设置pivot a[l]=a[j]; a[j]=pivot; //对一个段进行调用 if(j-l+1&lt;k) return select(a,j+1,r,k-j+l-1); else return select(a,l,j-1,k);&#125; 上述程序复杂度分析： 最坏情况下复杂性是Θ(n²)； 如果left和right总是同样大小或者相差不超过一个元素，那么可以得到以下递归式： 如果n是2的幂，则通过使用迭代方法，可以得到t(n)=Θ(n)； 提示：选择较好的pivot可得到较好的性能。 中间的中间规则： 若仔细地选择支点元素，则最坏情况下的时间开销也可以变成Θ(n)； 一种选择支点元素的方法是使用“中间的中间(median-of-median)”规则：首相将数组a中的n个元素分成n/r组，r为某一整常数，除了最后一组外，每组都有r个元素。然后通过在每组中对r个元素进行排序来寻找每组中位于中间位置的元素。最后对所得到的n/r个中间元素，递归使用选择算法，求得“中间之中间”作为支点元素。 Example： 距离最近的点对 问题描述：给定平面上n个点，找其中的一对点，使得在n个点所组成的所有点对中，该点对距离最小； 严格来讲，最接近点对可能多于一对，为简便起见，我们只找其中的一对作为问题的解； 一个简单的做法是将每一个点于其他n-1个点的句里算出，找出最小距离的点对即可。该方法的时间复杂性是T(n)=n(n-1)/2 + n = O(n²)，效率较低； 一维空间中的情形 为了使问题易于理解和分析，先来考虑一维的情形。此时，S中的n个点退化为x轴上的n个实数x1，x2，…，xn。最接近的点对即为这n个实数中相差最小的两个实数； 一个简单的办法就是先把x1，x2，…，xn排好序，再进行一次线性扫描就可以找出最接近点对，T(n)=O(nlogn)。然而这种方法无法推广到二维情形； 假设我们用x轴上某个点m将S划分为2个子集S1和S2，基于平衡子问题的思想，用S中各点坐标的中位数来作分割点； 递归地在S1和S2上找出最接近点对{p1，p2}和{q1，q2}，并设d=min{|p1-p2|，|q1-q2|}，S中的最接近点对或者是{p1，p2}，或者是{q1，q2}，或者是某个{p3，q3}，其中p3∈S1且q3∈S2； 可以用线性时间就可以找到问题的解； 分割点m的选取不当，会造成|Si|=1，|Sj|=n-1的情形，使得T(n)=T(n-1)+O(n)=O(n²)。这种情形可以通过“平衡子问题”方法加以解决：选取各坐标的中位数作分割点。 二维空间中的情形 选取一垂直线l：x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1和S2； 递归地在S1和S2上找出其最小距离d1和d2，并设d=min{d1，d2}，S中的最接近点1对或者是d，或者是某个{p，q}，其中p∈S1且q∈S2； 复杂度分析 算法分析 任何求最大最小的算法从起始状态到完成状态所用比较次数不可少于 (3n/2)(上取整)-2； (3n/2)(上取整)-2是所有基于比较的求最大最小算法所需比较次数的下界； 堆排序，归并排序在最坏情况下有较好的性能(针对渐进复杂性而言)； 堆排序，归并排序，快速排序在平均情况下性能较优。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Greedy","slug":"Algorithm/AlgorithmChapter4","date":"2020-12-11T12:10:21.000Z","updated":"2021-04-21T03:25:00.225Z","comments":false,"path":"2020/12/11/Algorithm/AlgorithmChapter4/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/11/Algorithm/AlgorithmChapter4/","excerpt":"","text":"贪心法 引言 优化问题：贪心法常用于解优化问题 应用： 货箱装船问题 背包问题 拓扑排序问题 哈夫曼编码问题 最短路径问题 最小代价生成树 偶图覆盖问题 优化解即指始目标函数极大化(或极小化)的可行解，对应的目标函数值成为优化值。 很多优化问题时NP-难度问题，迄今找不到他们的多项式算法。所以计算上可行的方法就是求其近似解。贪心法是求近似算法的主要途径。 贪心法：一种多步求解的方法 每步按一种局部优化的策略选择解(元组)的一个分量； 算法以第n步结束时构造出的对象(元组)作为问题的解； 这种局部优化的策略又称为“贪心标准”。 贪心法主要特点 不回溯：选定一个分量后，不重试其他可能。 使用局部优化策略的主要原因是减小计算开销。但局部优化策略不保证得到精确优化解，可能得到的是近似解。特别是对NP-难度问题。 不同的“贪心”策略得到不同的算法。 常常采纳使目标函数有最大增量的策略为贪心策略；增量是局部性概念。 遗传算法，神经网络等等都是具有这类贪心性质的启发式算法。 贪心算法性能 贪心算法并不总能求得问题的整体最优解。但对于活动安排问题，机器调度问题，上述贪心算法却总能求得整体最优解。 K-优化算法 K-优化算法是上述密度贪心算法的改进，改进后误差可控制在1/(k+1)*100%之内 算法得时间复杂度随k的增大而增加： 需要测试的子集数目为O(pow(n,k))； 每一个子集做贪心法需时间O(n)； 因此当k&gt;0时总的时间开销为O(pow(n,k+1))； 内容： 先对物品按密度从大到小排序； 先将一些物品装入背包，然后对其余物品使用贪心法； 预先装入的物品数不超过k； 对所有物品数不超过k的物品子集执行上述过程，并从中找到有最大效益值得解作为k-优化算法得解。 哈夫曼编码问题 前缀码：对每一个字符规定一个0，1串作为其代码，并要求任一字符的代码都不是其他字符代码的前缀，这种编码成为前缀码。 使平均码长达到最小的前缀码编码方案成为未定编码字符集C的最优前缀码。 哈夫曼提出构造最优前缀码的贪心算法，由此产生的编码方案成为哈夫曼编码。 具体算法： 根据n个权值{w1, w2, …, wn}构成n棵二叉树的集合F={T1，T2,… Tn}，其中每棵二叉树Ti中只有一个带权值为wi的根节点，其左右子树均为空。 在F中选取两棵根节点权值最小的树作为左右子树来构造一棵新的二叉树，且置新的二叉树的根节点的权值为其左右子树的根节点权值之和。 在F中删除这两棵树，同时将新得到的二叉树加入F中。 重复step2，3，直到F中只含一棵树时为止。称这棵树为最优二叉树或哈夫曼树。 如果约定将每个节点的左分支表示字符‘0’，右分支表示字符‘1’，则可以把从根节点到某叶子节点的路径上分支字符组成的字符串作为该叶子节点的编码。 哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。 算法以|C|个叶节点开始，执行|C|-1次的“合并”运算后产生最终所要求的树T。 关于n个字符的哈夫曼算法的计算时间为O(nlogn)。 拓扑排序 邻接矩阵与邻接表 拓扑排序定义：根据任务的有向图建立拓扑序列的过程。 贪心策略：从当前尚不在拓扑排序序列的顶点中选择一项顶点w，其所有先行节点v都在已产生的拓扑序列中(或无先行顶点)并将其加入到拓扑序列中。 使用栈的伪代码： 计算每个顶点的入度 将入度为0的顶点入栈 While(栈不空){ ​ 任取一入度为0的顶点放入拓扑序列中； ​ 将与其相邻的顶点的入度减1； ​ 如有新的入度为0的顶点出现，将其放入栈中； } 如有剩余的顶点则该图有环路 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243bool Network::Topological(int v[])&#123; //计算有向图中顶点的拓扑次序 //如果找到了一个拓扑次序，则返回true，此时，在v[0:n-1]中记录拓扑次序 //如果不存在拓扑次序，则返回false int n=Vertices(); //计算入度 int *InDegree=new int[n+1]; InitializePos();//图遍历器数组 for(int i=1;i&lt;=n;i++)//初始化 InDegree[i]=0; for(int i=1;i&lt;=n;i++)//从i出发的边 &#123; int u=Begin(i); while(u) &#123; InDegree[u]++; u=NextVertex(i); &#125; &#125; //把入度为0的顶点压入堆栈 LinkedStack&lt;int&gt; S; for(int i=1;i&lt;=n;i++) if(!InDegree[i]) S.Add(i); //产生拓扑次序 i=0;//数组v的游标 while(!S.IsEmpty())//从堆栈中选择下一个顶点 &#123; int w; S.Delete(w); v[i++]=w; int u=Begin(w); while(u)//修改入度 &#123; InDegree[u]--; if(!InDegree[u]) S.Add[u]; u=NextVertex(w); &#125; &#125; DeactivatePos(); delete [] InDegree; return (i==n);&#125; 上述算法的时间复杂度： Θ(n²)：使用邻接矩阵；Θ(n+e)：使用邻接表 单源最短路径 任给一有向图G，它的每条边都有一个非负的权值，路径的长度定义为路径上边的权值之和。 单源最短路径问题：给定的源节点s，找出从s到图中所有其他节点(成为目的)的最短路径(优化解)及其长度(优化值) Dijkstra‘s最短路算法 如果链路权值非负，则最短路的子路径也是最短路，其长度小于原来路径的长度。所以，长度较小的最短路容易找到。 贪心策略：按最短路长度从小到大依次求解。 Dijkstra’s最短路算法使用上述贪心策略，是图论算法中应用最为广泛的算法，主要原因是其计算复杂度低且容易实现。 基本步骤： 维护一个集合S，该集合中源节点到其他节点的最短路已知，初始时该集合为空； 从V-S结合中找一节点v，满足源节点到该节点距离最小； 更新v的临界点的到源节点的距离值。 Example：1 S：{A,C,E,B,D} 源节点为A，所以S：{A}； 在S中的节点中找到于之有关的最短路径，将另一节点放入S中； 即AC=min，所以S：{A,C}； CE=min，所以S：{A,C,E}； CB=min，所以S：{A,C,E,B}； BD=min，所以S：{A,C,E,B,D} ∴S：{A,C,E,B,D} Example：2 Example of breadth-first search： Bellman-Ford算法 介绍：Dijkstra算法无法判断含负权边的图的最短路。如果遇到负权，在没有负权回路（回路的权值和为负，即便有负权的边）存在时，也可以采用Bellman - Ford算法正确求出最短路径。 Bellman-Ford算法能在更普遍的情况下（存在负权边）解决单源点最短路径问题。对于给定的带权（有向或无向）图 G=(V,E), 其源点为s，加权函数 w是 边集 E 的映射。对图G运行Bellman - Ford算法的结果是一个布尔值，表明图中是否存在着一个从源点s可达的负权回路。若不存在这样的回路，算法将给出从源点s到 图G的任意顶点v的最短路径d[v]。 Floyd算法 时间复杂度：O(n³)；空间复杂度：O(n²)(矩阵) 最小生成树 具有n个顶点的连通无向图G，图的每条边e有一非负权值c(e)，也称为成本，求有最小成本的生成树。 每个生成树刚好具有n-1条边，所以问题是用某种方法选择n-1条边使它们形成G的最小生成树。 Kruskal’s算法；Prim‘s算法。 Kruskal’s算法 贪心策略：每次选择权值c(e)最小且与以前选择的边不构成回路的边。 上述策略要求按权值从小到大对边排序。 算法可在O(n+eloge)找出最小生成树。 Prim‘s算法 步骤： 在图中选出权值最小的边，边的两个顶点放入点集V； 在图中找到权值最小且与点集V有关的边； 重复2直至找到最小生成树。 偶图覆盖问题(二分覆盖) 偶图是一个无向图，它的n个顶点分为集合A和集合B，且同一集合中的任意两个顶点无边相连。 A的一个子集A’覆盖集合B iff B中每一个顶点至少和A’中一顶点相连。覆盖A‘的大小指A’中的顶点数目。 在偶图中寻找最小覆盖的问题成为偶图覆盖(bipartite-cover)问题。 Example： 上图为有17个顶点的二分图； A={1，2，3，16，17}；B={4，5，6，7，8，9，10，11，12，13，14，15}； 子集A’={1，16，17}是B的最小覆盖：1覆盖{4，6，7，8，9，13}；16覆盖{5，6，8，12，14，15}；17覆盖{4，9，10，11} 贪心策略：选择覆盖B中那些尚未被覆盖的顶点数最多的A的系节点。 对上图应用上述贪心法，得到A‘={1，16，17}。 覆盖算法总的算法复杂性为O(Sizeof(A²)+n²)或O(Sizeof(A²)+n+e)。 连续背包问题 一种可行的贪心策略：按价值密度非递减的顺序检查物品，若剩余容量能容下正在考察的物品，将其装入；否则往背包中装入此物品的一部分。 证明这种贪心算法总能产生最优解：","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Analysis of Algorithms","slug":"Algorithm/AlgorithmChapter3","date":"2020-12-10T05:20:54.000Z","updated":"2021-04-21T03:15:45.381Z","comments":false,"path":"2020/12/10/Algorithm/AlgorithmChapter3/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/10/Algorithm/AlgorithmChapter3/","excerpt":"","text":"Pseudocode（伪代码） Soving Recurrences（解递归） 1.Recursion tree 解T(n)=2T(n/2)+cn，其中c&gt;0为常数。递归展开到T(n0)，会导致推导的麻烦。所以解递归展开到T(1)，然后再从前n0个T(n)的值确定渐进分析的常数。 继续展开得到 Total=Θ(nlgn)。 很多递归式用递归树解不出来，但递归树能提供直觉，帮助我们用归纳法求解(Guess归纳假设) 较一般的递归式：T(n)=aT(n/b)+cn a，b是大于1的整数，递归树方法仍可使用。 2.Substitution method The most general method： 1.Guess the form of the solution； 2.Vertify by induction； 3.Solve for constants。 3.Master method T(n)=aT(n/b)+f(n)。式中a&gt;=1，b&gt;=1，为整数，f(n)&gt;0 以下loga均指以b为底a的对数 Case 1：f(n)&lt;pow(n,loga) f(n)=O(pow(n,loga-ε))，ε&gt;0，为某一常数。f(n)的增长渐进地慢于pow(n,loga)(慢pow(n,ε)倍) ∴Solution：T(n)=Θ(pow(n,loga))。 Case 2： f(n)=Θ(pow(n,loga)*pow(lgn,k)) k&gt;=0为某一常数 f(n)和pow(n,loga)几乎有相同的渐进增长率。 ∴Solution：T(n)=Θ(pow(n,loga)*pow(lgn,k+1))。 Case 3：f(n)&gt;pow(n,loga) f(n)=Ω(pow(n,loga+ε))，ε&gt;0，为某一常数。f(n)的增长渐进地快于pow(n,loga)(快pow(n,ε)倍) 其中，f(n)满足：af(n/b)&lt;=cf(n)，0&lt;c&lt;1为常数 ∴Solution：T(n)=Θ(f(n))。 总结： 等式右边，哪项变化得快，T(n)就属于哪项的数量级。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"是非黑白 自在人心","slug":"是非黑白-自在人心","date":"2020-12-10T03:56:15.000Z","updated":"2021-04-10T03:06:17.825Z","comments":false,"path":"2020/12/10/是非黑白-自在人心/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/10/%E6%98%AF%E9%9D%9E%E9%BB%91%E7%99%BD-%E8%87%AA%E5%9C%A8%E4%BA%BA%E5%BF%83/","excerpt":"","text":"是非黑白，自在人心 ​ 世上本没有路，走的人多了，也便成了路；类似地，有的言论说多了，就有人选择相信。在现在的信息化时代中，人们对信息的获取非常便捷，但是人们接受信息的时间和方式非常的碎片化，很可能尝尝因为一张图片，一个视频片段，一段采访，一篇文章，而相信一个所谓的事实。而往往很多人会去选择相信一个错误的事实。人的观点和思想很容易被改变，往往很多时候不是被事实所影响，甚至是被言语所影响。 毕竟这是个打字不用负责任的年代 有时候你看到的不一定是事实，你以为的事实不一定是真相 建议切换白天与夜晚模式浏览","categories":[{"name":"Humanity","slug":"Humanity","permalink":"https://cheeseburgerim.github.io/categories/Humanity/"}],"tags":[{"name":"Humanity","slug":"Humanity","permalink":"https://cheeseburgerim.github.io/tags/Humanity/"}]},{"title":"Chapter 2 程序性能","slug":"Algorithm/AlgorithmChapter2","date":"2020-12-10T02:54:40.000Z","updated":"2021-04-17T02:50:21.431Z","comments":false,"path":"2020/12/10/Algorithm/AlgorithmChapter2/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/10/Algorithm/AlgorithmChapter2/","excerpt":"","text":"空间复杂度Sp(n) 1.定义 指程序运行时所需的内存空间大小和实例特征的函数关系。 2.程序运行时所需空间包括 指令空间：与实例特征无关的常数； 数据空间：常量和简单变量-与实例无关； ​ 复合变量-数组，链表，树和图等； ​ 环境栈空间-函数调用-是否递归； 复合变量所需空间尝尝和问题实例特征有关； 3.计算 S§=c+Sp(instance characteristics) 其中c为常量(实例无关部分)，Sp为可变部分。在使用解析方法研究程序p的空间复杂度时仅考虑Sp。在分析空间复杂度时我们忽略与实例特征无关的空间需求量。 4.例题 12345678910template &lt;class T&gt;int SequentialSearch(T a[], const T&amp; x, int n)&#123; //Search the unordered list a[0:n-1] for x. //Return position if found; Return -1 otherwise. int i; for(i=0;i&lt;n&amp;&amp;a[i]!=x;i++) if(i==n) return -1; return i;&#125; 实例特征：n，S(n)=0; 该程序所占空间均为常量，与实例特征无关，所以S(n)=0。 时间复杂度T(n) 1.定义 指程序执行时所用的时间。 2.计算 在使用解析方法时程序p的时间复杂度表示为输入量的函数T。 在解析地分析时间复杂度时，使用以下两种时间单位并计算： ​ 操作步数(operation count)：算法的基本操作； ​ (程序)步计数(step count)：分析全部程序。 要点：基本操作或程序步执行的时间必须时常数。 3.例题 s/e：代表该语句执行后步数(count)的变化(增量)； Frequency：代表该语句执行的次数； Total steps：代表该语句在整个程序执行过程中引发的总步数。 Statement s/e Frequency Total steps T Sum(T a[],int n) 0 0 0 { 0 0 0 T tsum=0; 1 1 1 for(int i=0;i&lt;n;i++) 1 n+1 n+1 tsum+=a[i]; 1 n n return tsum; 1 1 1 } 0 0 0 Total 2n+3 渐进分析（O,Ω,Θ） 1.定义 计算机科学使用最多的符号-讨论算法时使用的共同语言 O：上界；Ω：下界；Θ：同阶。 2.随n的增加T(n)的增长率 3.渐进分析时用到的一些等式 E8：i form 1 to n. ∑1/i -&gt; Θ(logn) 4.例题 Statement s/e Frequency Total steps T Sum(T a[], int n) 0 0 Θ(0) { 0 0 Θ(0) T tsum=0; 1 1 Θ(1) for(int i=0;i&lt;n;i++) 1 n+1 Θ(n) tsum+=a[i]; 1 n Θ(n) return tsum; 1 1 Θ(1) } 0 0 Θ(0) ∴ t(n)=Θ(max{})=Θ(n)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Chapter 1 算法概述","slug":"Algorithm/AlgorithmChapter1","date":"2020-12-10T02:28:04.000Z","updated":"2021-04-17T02:48:38.420Z","comments":false,"path":"2020/12/10/Algorithm/AlgorithmChapter1/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/10/Algorithm/AlgorithmChapter1/","excerpt":"","text":"算法 1.定义：是对特定问题求解步骤的一种描述，是指令的有限序列。 2.特征： 输入：算法有零个或多个输入量； 输出：算法至少产生一个输出量； 确定性：算法的每一条指令都有确切的定义，没有二义性； 能行性：算法的每一条指令必须足够基本，他们可以通过已经实现的基本运算执行有限次来实现。 有穷性：算法必须总能在执行有限步之后终止。 程序：程序是算法用某种程序语言的具体实现 程序可以不满足算法的5条性质。 操作系统，是一个在无限循环中执行的程序，因而不是一个算法。 操作系统的各种任务可看成是单独的问题，每一个问题由操作系统中的一个子程序通过特定的算法来实现。该子程序得到输出结果后便终止。 算法的性能：算法所需的计算时间和占用的内存空间 问题和问题求解 常见的应用问题类型： 1.搜索问题；2.排序问题；3.图论问题；4.组合数学问题；5.几何问题；6.数值计算问题； P问题 P问题能够保证存在多项式时间求解算法； NP问题不确定是否存在多项式时间求解算法，但确定存在多项式时间验证算法； P问题是NP问题的子集，因为存在多项式时间求解算法的问题，一定能够在多项式时间内被验证； NP-hard问题不一定是NP问题，有可能是不可判定问题。这时候说明原问题也是不可判定的； NPC问题既是NP问题的子集，又是NP-hard问题的子集，所以NPC问题是NP问题和NP-hard问题的交集； NP-hard问题和NPC问题都要求能够在多项式时间内规约成另外一个问题。这里规约的意思是将一个特殊问题一般化，即将原问题推广为一个最一般的，最有概括性，也更难得，计算复杂度更高的问题，这个问题具有最高的计算复杂度，如果这个最一般的问题也能有多项式时间求解算法，那么那些特殊的原问题也能有多项式时间求解算法。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"IM","slug":"IM","date":"2020-12-08T13:42:52.000Z","updated":"2021-04-21T03:38:25.479Z","comments":false,"path":"2020/12/08/IM/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/08/IM/","excerpt":"","text":"Part of the journey is the end. LoveU3000 Lines Trailer Gosh seems like thousand years ago. I fought my way out of the cave, became iron man. Realized I loved you. I know I said no more surprises, but I was really hoping to pull off the one last one. Avengers：Endgame This thing on? Hey, Miss Potts. Pep. If you find this recording, don’t post it on social media. It’s gonna be a real tearjerker. I don’t know if you’re ever gonna see these. I don’t even know if you’re still … Oh, God, I hope so. Today’s day 21. No, 22. You know, if it wasn’t for the existential terror of staring into the literal void of space, I’d say I’m feeling a little better today. Infection’s run its course, thanks to the Blue Meanie back there. You’d love her. Very practical. Only a tiny bit sadistic. So, the fuel cells were cracked during battle and we figured out a way to reverse the ion charge and bought ourselves about 48 hours of flight time. But it’s now dead in the water. Thousand light years from the nearest 7-Eleven. Oxygen will run out tomorrow morning and that’ll be it. Pep, I know I said no more surprises but I gotta say I was really hoping to pull off one last one. But it looks like … Well, you know what it looks like. Don’t feel bad about this. I mean, actually, if you grovel for a couple weeks and then move on with enormous guilt. I should probably lie down for a minute. Go rest my eyes. Please know, when I drift off, it’ll be like every night lately. I’m fine. Totally fine. I dream about you. Because it’s always you. No amount of money ever bought a second of time. Everybody wants a happy ending, right? But it doesn’t always roll that way. Maybe this time. I’m hoping if you play this back, it’s in celebration. I hope families are reunited. I hope we get it back. And something like a normal version of the planet has been restored. If there ever was such a thing. God, what a world. Universe, now. If you told me 10 years ago that we weren’t alone, let alone to this extent, I mean, I wouldn’t have been surprised, but come on, who knew? The epic forces of darkness and light that have come into play. And for better or worse, that’s the reality Morgan’s gonna have to find a way to grow up in. So, I thought I’d probably better record a little greeting in the case of an untimely death. On my part. Not that death at any time isn’t untimely. This time travel thing that we’re gonna try and pull off tomorrow, it’s got me scratching my head about the survivability of it all. That’s the thing. Then again, that’s the hero gig, right? Part of the journey is the end. What am I even tripping for? Everything is gonna work out exactly the way it’s supposed to. I love you 3000. Click here to watch a MARVELous video→LoveU3000 LoveU3000","categories":[{"name":"IM","slug":"IM","permalink":"https://cheeseburgerim.github.io/categories/IM/"}],"tags":[{"name":"IM","slug":"IM","permalink":"https://cheeseburgerim.github.io/tags/IM/"}]},{"title":"New beginning","slug":"New-beginning","date":"2020-12-08T07:58:12.000Z","updated":"2021-04-10T03:07:49.778Z","comments":false,"path":"2020/12/08/New-beginning/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/08/New-beginning/","excerpt":"","text":"​ 2020/12/8, I built up this website to write down my different phases and some details in my life. This is a totally new start. I will improve this blog gradually and share my ideas and feelings.","categories":[{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/categories/New/"}],"tags":[{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/tags/New/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-08T06:56:49.000Z","updated":"2021-04-10T02:27:04.573Z","comments":false,"path":"2020/12/08/hello-world/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/08/hello-world/","excerpt":"","text":"Original website https://butterfly.js.org/ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new post &quot;Post Name&quot; More info: Writing Run server 1$ hexo s More info: Server Generate static files 1$ hexo g More info: Generating Deploy to remote sites 1$ hexo d More info: Deployment 注意： 1.现安装douban插件，生成网页的命令为hexo douban，由于前缀和hexo deploy相同，所以以后上传时要使用hexo deploy命令。 2.hexo根目录下_config,yml文件中douban中builtin已设置为true，即在hexo g和hexo s时包括了hexo douban命令。 Clean 1$ hexo cl More info: Clean Font Awesome Font Awesome http://www.fontawesome.com.cn/ Font Awesome（foreign） https://fontawesome.com/ Font Awesome 4 https://fontawesome.dashgame.com/ Font Awesome 5 https://fa5.dashgame.com/#/ 聚合图床 http://www.superbed.cn/admin Iconfont+ https://www.iconfont.cn/ emojipedia https://emojipedia.org/ Shields https://shields.io/ Tips 引用JS/CSS文件 Take CSS as an example： 1.新建一个CSS文件，移动到 \\butterfly\\source\\css\\ 目录下。 2.在主题配置文件(\\hexo\\themes\\butterfly_config.yml)中定位搜索 inject。 3.其中head是用来引入 CSS 文件；bottom 是用来引用 JS 文件。 页内跳转 Format：[ ] ( ) 中括号内为名称，小括号内为跳转位置 Example：Jump Here 小括号中必须和标题格式一摸一样，英文字母全部小写，且不能含有emoji等特殊符号 Hexo文章的密码访问 方法一 方法实现，因Hexo中Markdown语言和html是混用的，所以可直接在Markdown中直接插入以下这段script(建议放到&lt;!-- more --&gt;段后面)。 这里用到了windows对象的alert()方法和prompt()方法。prompt()方法的作用即是显示一个可提示用户输入的对话框，而其本身的返回值就是你输入的那个字符串。因此只需要将其与你默认的密码比较一下就好，如果不正确，则直接将当前页面的loaction属性设为上一个页面即可。 1234567891011&lt;script&gt; if(&quot;123&quot;==prompt(&quot;请输入文档密码&quot;)) &#123; alert(&quot;密码正确&quot;); &#125; else &#123; alert(&quot;密码错误返回主页&quot;); location=&quot;/&quot;; &#125;&lt;/script&gt; html语言 方法二 安装 1npm install --save hexo-blog-encrypt 在front-matter中添加password password: your password Gitee图床 注册Gitee账号； 新建仓库； 上传图片； 打开图片得到链接形如 https://gitee.com/username/repository/blob/… 修改链接 将blob改为raw即可在markdown中使用","categories":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/categories/Introduction/"}],"tags":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/tags/New/"}]}],"categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"},{"name":"Project","slug":"Project","permalink":"https://cheeseburgerim.github.io/categories/Project/"},{"name":"Android","slug":"Android","permalink":"https://cheeseburgerim.github.io/categories/Android/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"},{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/categories/Course/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"},{"name":"Solution","slug":"Solution","permalink":"https://cheeseburgerim.github.io/categories/Solution/"},{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/categories/DataBase/"},{"name":"Notification","slug":"Notification","permalink":"https://cheeseburgerim.github.io/categories/Notification/"},{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"},{"name":"Guidance","slug":"Guidance","permalink":"https://cheeseburgerim.github.io/categories/Guidance/"},{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/categories/Postgraduate/"},{"name":"Rubik'sCube","slug":"Rubik-sCube","permalink":"https://cheeseburgerim.github.io/categories/Rubik-sCube/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/categories/Introduction/"},{"name":"Physics","slug":"Physics","permalink":"https://cheeseburgerim.github.io/categories/Physics/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/categories/OS/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"},{"name":"Humanity","slug":"Humanity","permalink":"https://cheeseburgerim.github.io/categories/Humanity/"},{"name":"IM","slug":"IM","permalink":"https://cheeseburgerim.github.io/categories/IM/"},{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/categories/New/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"SophomoreSecondSemester","slug":"SophomoreSecondSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreSecondSemester/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"FSUZ","slug":"FSUZ","permalink":"https://cheeseburgerim.github.io/tags/FSUZ/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/tags/DataBase/"},{"name":"DataBasePrinciple","slug":"DataBasePrinciple","permalink":"https://cheeseburgerim.github.io/tags/DataBasePrinciple/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"ComputerNetwork","slug":"ComputerNetwork","permalink":"https://cheeseburgerim.github.io/tags/ComputerNetwork/"},{"name":"Android","slug":"Android","permalink":"https://cheeseburgerim.github.io/tags/Android/"},{"name":"Project","slug":"Project","permalink":"https://cheeseburgerim.github.io/tags/Project/"},{"name":"DaChuang","slug":"DaChuang","permalink":"https://cheeseburgerim.github.io/tags/DaChuang/"},{"name":"DaChuang2021-2022","slug":"DaChuang2021-2022","permalink":"https://cheeseburgerim.github.io/tags/DaChuang2021-2022/"},{"name":"ORB-SLAM2","slug":"ORB-SLAM2","permalink":"https://cheeseburgerim.github.io/tags/ORB-SLAM2/"},{"name":"Develop","slug":"Develop","permalink":"https://cheeseburgerim.github.io/tags/Develop/"},{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"},{"name":"Windows","slug":"Windows","permalink":"https://cheeseburgerim.github.io/tags/Windows/"},{"name":"Tips","slug":"Tips","permalink":"https://cheeseburgerim.github.io/tags/Tips/"},{"name":"Hexo","slug":"Hexo","permalink":"https://cheeseburgerim.github.io/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://cheeseburgerim.github.io/tags/Blog/"},{"name":"Theme","slug":"Theme","permalink":"https://cheeseburgerim.github.io/tags/Theme/"},{"name":"PersonalPage","slug":"PersonalPage","permalink":"https://cheeseburgerim.github.io/tags/PersonalPage/"},{"name":"ChangeTheme","slug":"ChangeTheme","permalink":"https://cheeseburgerim.github.io/tags/ChangeTheme/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://cheeseburgerim.github.io/tags/Butterfly/"},{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/tags/New/"},{"name":"NewBeginning","slug":"NewBeginning","permalink":"https://cheeseburgerim.github.io/tags/NewBeginning/"},{"name":"NewComputer","slug":"NewComputer","permalink":"https://cheeseburgerim.github.io/tags/NewComputer/"},{"name":"CodeExercise","slug":"CodeExercise","permalink":"https://cheeseburgerim.github.io/tags/CodeExercise/"},{"name":"Exercise","slug":"Exercise","permalink":"https://cheeseburgerim.github.io/tags/Exercise/"},{"name":"Practice","slug":"Practice","permalink":"https://cheeseburgerim.github.io/tags/Practice/"},{"name":"NCMAM","slug":"NCMAM","permalink":"https://cheeseburgerim.github.io/tags/NCMAM/"},{"name":"Math","slug":"Math","permalink":"https://cheeseburgerim.github.io/tags/Math/"},{"name":"Git","slug":"Git","permalink":"https://cheeseburgerim.github.io/tags/Git/"},{"name":"Solution","slug":"Solution","permalink":"https://cheeseburgerim.github.io/tags/Solution/"},{"name":"Github","slug":"Github","permalink":"https://cheeseburgerim.github.io/tags/Github/"},{"name":"ChangeDomainName","slug":"ChangeDomainName","permalink":"https://cheeseburgerim.github.io/tags/ChangeDomainName/"},{"name":"Notification","slug":"Notification","permalink":"https://cheeseburgerim.github.io/tags/Notification/"},{"name":"NOWCODER","slug":"NOWCODER","permalink":"https://cheeseburgerim.github.io/tags/NOWCODER/"},{"name":"Daily","slug":"Daily","permalink":"https://cheeseburgerim.github.io/tags/Daily/"},{"name":"Website","slug":"Website","permalink":"https://cheeseburgerim.github.io/tags/Website/"},{"name":"Design","slug":"Design","permalink":"https://cheeseburgerim.github.io/tags/Design/"},{"name":"js","slug":"js","permalink":"https://cheeseburgerim.github.io/tags/js/"},{"name":"Fun","slug":"Fun","permalink":"https://cheeseburgerim.github.io/tags/Fun/"},{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"To The Moon","slug":"To-The-Moon","permalink":"https://cheeseburgerim.github.io/tags/To-The-Moon/"},{"name":"css","slug":"css","permalink":"https://cheeseburgerim.github.io/tags/css/"},{"name":"Markdown","slug":"Markdown","permalink":"https://cheeseburgerim.github.io/tags/Markdown/"},{"name":"ExternalTag","slug":"ExternalTag","permalink":"https://cheeseburgerim.github.io/tags/ExternalTag/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"DUOCS","slug":"DUOCS","permalink":"https://cheeseburgerim.github.io/tags/DUOCS/"},{"name":"html","slug":"html","permalink":"https://cheeseburgerim.github.io/tags/html/"},{"name":"Guidance","slug":"Guidance","permalink":"https://cheeseburgerim.github.io/tags/Guidance/"},{"name":"PTA","slug":"PTA","permalink":"https://cheeseburgerim.github.io/tags/PTA/"},{"name":"Marxism","slug":"Marxism","permalink":"https://cheeseburgerim.github.io/tags/Marxism/"},{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/tags/Postgraduate/"},{"name":"SophomoreFirstSemester","slug":"SophomoreFirstSemester","permalink":"https://cheeseburgerim.github.io/tags/SophomoreFirstSemester/"},{"name":"Rubik'sCube","slug":"Rubik-sCube","permalink":"https://cheeseburgerim.github.io/tags/Rubik-sCube/"},{"name":"LOL","slug":"LOL","permalink":"https://cheeseburgerim.github.io/tags/LOL/"},{"name":"COC","slug":"COC","permalink":"https://cheeseburgerim.github.io/tags/COC/"},{"name":"fun","slug":"fun","permalink":"https://cheeseburgerim.github.io/tags/fun/"},{"name":"RO","slug":"RO","permalink":"https://cheeseburgerim.github.io/tags/RO/"},{"name":"NEMU","slug":"NEMU","permalink":"https://cheeseburgerim.github.io/tags/NEMU/"},{"name":"Physics","slug":"Physics","permalink":"https://cheeseburgerim.github.io/tags/Physics/"},{"name":"GTAV","slug":"GTAV","permalink":"https://cheeseburgerim.github.io/tags/GTAV/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"},{"name":"Humanity","slug":"Humanity","permalink":"https://cheeseburgerim.github.io/tags/Humanity/"},{"name":"IM","slug":"IM","permalink":"https://cheeseburgerim.github.io/tags/IM/"}]}