{"meta":{"title":"CheeseburgerIM","subtitle":"IM灬Tony Pan","description":"I d like a cheeseburger^_^","author":"Tony Pan","url":"https://CheeseburgerIM.github.io","root":"/"},"pages":[{"title":"Accounts","date":"2021-01-22T10:38:54.000Z","updated":"2021-04-11T04:29:51.082Z","comments":false,"path":"Accounts/index.html","permalink":"https://cheeseburgerim.github.io/Accounts/index.html","excerpt":"","text":"if(\"pyz200168\"==prompt(\"请输入文档密码\")) { alert(\"密码正确\"); } else { alert(\"密码错误返回主页\"); location=\"/\"; } Accounts Communication Game 小米 576638119 pyz…_…(Q) 赛尔号 66466715 1029 造梦西游 44799141 Steam xinger8im pyz1029 Rockstar 邮箱QQ166 Pyz1029 Epic 邮箱QQ166 pyz1029 TapTap 130 Fun 斗鱼 WX166 虎牙 QQ166 微博 QQ2497 Bilibili 邮箱QQ166 130 pyz1029 喜马拉雅 130 QQ166 WX166 Study 金山词霸 130 CET 邮箱QQ166 130 pyz1029_ Github 邮箱130 pyz1029 Gitee 130 pyz1029 Github与Gitee已关联 聚合图床 Cheese 1029 牛客 130 1029 Others 红手指 QQ166 130 pyz1029 腾达 admin fbn123 小黑盒 WX166 Microsoft 邮箱QQ166 130 pyz1029 摇号 130 pyz200 Apple 130 T…P…2… Todos马面老板录播王牌对王牌柯南英雄觉醒B站动漫青春德云社我们的歌平行时空遇见你约吧大明星我想开个店我去上学啦唐探网剧加勒比海盗哈利波特让子弹飞RO,COC小说,动画小说-庆余年，赘婿青春环游记姐姐妹妹的武馆 进击的巨人 让子弹飞 海绵宝宝 正义联盟-扎导 骚男去月球 风声 刀剑神域"},{"title":"about","date":"2021-04-11T04:28:45.000Z","updated":"2021-04-11T04:31:48.047Z","comments":true,"path":"about/index.html","permalink":"https://cheeseburgerim.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-04-11T04:28:17.000Z","updated":"2021-04-11T04:28:33.753Z","comments":true,"path":"friends/index.html","permalink":"https://cheeseburgerim.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-04-11T04:27:18.000Z","updated":"2021-04-11T04:31:18.938Z","comments":true,"path":"categories/index.html","permalink":"https://cheeseburgerim.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-04-11T04:27:48.000Z","updated":"2021-04-11T04:31:37.678Z","comments":true,"path":"tags/index.html","permalink":"https://cheeseburgerim.github.io/tags/index.html","excerpt":"","text":""},{"title":"English","date":"2020-12-08T14:48:17.000Z","updated":"1970-01-01T00:00:00.001Z","comments":false,"path":"english/index.html","permalink":"https://cheeseburgerim.github.io/english/index.html","excerpt":"","text":"Catalog Catalog DailySentences Composition Vacabulary Structure Article DailySentences20214/11：The real voyage of discovery consists not in seeking new landscapes, but in having new eyes. 4/10：The choices we make are ultimately our own responsibility. 4/9：By its very nature, history is always a one-sided account. 4/8：The deepest principle in human nature is the craving to be appreciated. 4/7：The most important thing in communication is hearing what isn’t said. 4/6：You will see exactly what life is worth, when all the rest has gone. 4/5：Never twist yourself just to please the world. 4/4：Let the dead have the immortality of fame, but the living the immortality of love. 4/3：Be yourself; everyone else is already taken. 4/2：Talent hits a target no one else can hit; Genius hits a target no one else can see. 4/1：Disbelief is more resistant than faith because it is sustained by the senses. 3/31：Optimists are right. Pessimists are right. It’s up to you to choose which you will be. 3/30：As terrifying and painful as reality can be, it’s also the only place where you can get a decent meal. 3/29：You see, madness, as you know, is like gravity. All it takes is a little push. 3/28：Nothing in life is to be feared. It is only to be understood. 3/27：You must have long-range goals to keep you from being frustrated by short-term failures. 3/26：Let everything happen to you, beauty and terror, just keep going, no feeling is final. 3/25：You can overcome anything, if and only if you love something enough. 3/24：I just live by the ABCs: Adventurous, Brave, Creative. 3/23：The goal is not always meant to be reached, but to serve as a mark for our aim. 3/22：In every person who comes near you, look for what is good and strong. 3/21：The world’s full of people afraid to make the first move. 3/20：With great power comes great responsibility. 3/19：The only impossible journey is the one you never begin. 3/18：We live in a twilight world, and there are no friends at dusk. 3/17：Always do your best. What you plant now, you will harvest later. 3/16：Through love comes calm, through calm comes thought. 3/15：If no one else guards the world, then I will come forward. 3/14：Doing things change things, no doing things, these things are exactly as they were. 3/13：If you don’t want to give in, your only choice is to resist. 3/12：Storms make trees take deeper roots. 3/11：It may not be pretty, but we headed to the city. 3/10：There is no development physically or intellectually without effort, and effort means work. 3/9：Some people choose to see the ugliness in this world. The disarray. I choose to see the beauty. 3/8：The hardest choices require the strongest wills. 3/7：The famous man once said “We create our own demons”. 3/6：The time you enjoy wasting is not wasted time. 3/5：The task of leadership is not to put greatness into humanity, but to elicit it. 3/4：An act of true love will thaw(melt) a frozen heart. 3/3：There is no pressure when you are making a dream come true. 3/2：The person whose calls you always take, that’s the relationship you ‘re in. 3/1：It is the set of the sails, not the direction of the wind that determines which way we will go. 2/28：Only those that risk going to far can possibly know how far they can go. 2/27：A dream doesn’t become reality through magic; it takes sweat, determination and hard work. 2/26：You go half way around the world chasing something. And the whole time, it’s in your own backyard. 2/25：Being too consumed in fear all the time will result in poor quality of life. 2/24：You’re never really donw for as long as you’ve got a good story and someone to tell it to. 2/23：There is no birth of consciousness without pain. 2/22：Sometimes it is better to lose and do the right thing than to win and do the wrong thing. 2/21：We can only see a short distance ahead, but we can see plenty there that needs to be done. 2/20：The real oppotunity for success lies within the person and not in the job. 2/19：The universe has to move forward. Pain and loss, they define us as much as happiness and love. 2/18：It’s not so much how busy you are, but why you are busy. 2/17：The best love is the kind that awakens the soul and makes us reach for more. 2/16：Self-esteem is the reputation we acquire with ourselves. 2/15：There are some natures too noble to curb and too lofty to bend. 2/14：Sometimes you gotta run before you can walk. 2/13：Home is any four walls that enclose the right person. 2/12：The crepitation of firecrackers sends off the old year. Sweet wine and spring wind brings warmth into thousands of homes. 2/11：Love is what binds us, through fair or stormy weather. 2/10：If we survive danger it steels our courage more than anything else. 2/9：Whenever people want you to do something they think it’s wrong, they say it’s “reality”. 2/8：When the lord closes the door, somewhere he opens a window. 2/7：Since you are like no other being ever created since the beginning of time, you are incomparable. 2/6：All friendship changes, but for the good ones it will only make it stronger. 2/5：He who reigns within himself and rules his passion, desires, and fears is more than a king. 2/4：But don’t worry, forgetting the trauma of childbirth is one of the great gifts of the universe. 2/3：No winter lasts forever; no spring skips its turn. 2/2：In one second your whole life can change. It only takes a moment for everything to feel quite different. 2/1：Without hard work, nothing grows but weeds. 1/31：Just don’t be disappointed if there’s not a pot of gold at the end of rainbow. 1/30：Let our advance worrying become advance thinking and planning. 1/29：Thinking you can escape life is your problem. You can never escape life. 1/28：Some people want it to happen, some wish it would happen, others make it happen. 1/27：Inspiration usually comes during work, rather than before it. 1/26：A decade or two will flt like that. 1/25：Problems are not stop signs, they are guidelines. 1/24：Expect the best, plan for the worst, and prepare to be surprised. 1/23：The size of your dreams must always exceed your current capacity to achieve them. 1/22：Oppotunity does not knock, it presents itself when you beat down the door. 1/21：Life must be lived as we go along. 1/20：The secret of getting ahead is getting started. 1/19：No amount of money ever bought a second of time. 1/18：We must accept finite disappointment, but we must never lose infinite hope. 1/17：Life is 10% what happens to you and 90% how you react to it. 1/16：The old dreams were good dreams. They didn’t work out, but I’m glad I had them. 1/15：Simplicity is the shortest path to a solution. 1/14：The definition of the good society is one in which virtue pays. 1/13：Standing for right when it is unpopular is a true test of moral character. 1/12：You keep living in the past. You are gonna wind up alone. 1/11：Ambition is the path to success. Persistence is the vehicle you arrive in. 1/10：There are many things that seem pretty impossible only so long as one does not attempt them. 1/9：The most important kind of freedom is to be what you really are. 1/8：We are the melodies and the notes of your opus. We are the music of your life. (opus n. 作品，乐曲；note n. 音符) 1/7：You can nearly always enjoy something, if you make up your mind firmly that you will. 1/6：What drains your spirit drains your body. What fuels your spirit fuels your body. 1/5：Purpose drives the process by which we become what we are capable of being. 1/4：It’s when you start to become afraid of death that you learn to appreciate life. 1/3：Great things are not accomplished by those who yield to trends and fads and popular opinion. 1/2：But in times of crisis the wise build bridges, while the foolish build barriers. ——《Black Panther》 1/1：All you need is the plan, the road map, and the courage to press on to your destination. 202012/31：Just because you make a good plan, doesn’t mean that’s what’s gonna happen. 12/30：We will be judged by the courage of our hearts. 12/29：Travel can be one of the most rewarding forms of introspection. (introspection: n.反省) 12/28：It’s not the load that break you down, it’s the way you carry it. 12/27：Get a move on, or all the good ones will have gone. 12/26：Pursue excellence and sucess will follow. 12/25：To simply wake up every morning a better person than when I went to bed. 12/24：Books are the bees which carry the quickening pollen from one to another mind. (pollen n.花粉) 12/23：And in the end, the greatest thief of all is time. 12/22：The sooner you learn it’s on you to make your own life interesting, the better off you’ll be. 12/21：The world may be full of cheating, however we never lack friends with a warm heart. 12/20：If we don’t end war, war will end us. 12/19：Oppotunities are like sunrises, if you wait too long, you’ll miss them. 12/18：Do not settle for what life gives you；Make life better and build something. 12/17：Anyone can hold a grudge, but it takes real courage to forgive. (grudge n：不满，怨恨，恶意，妒忌；vt：怀恨，妒忌，吝惜，不情愿做) 12/16：The world is a book, and those who do not travel read only a page. 12/15：You got to put the past behind before you can move on. 12/14：Sometimes life hits you in th head with a brick. Don’t lose faith. 12/13：The biggest communication problems is we do not listen to understand. We listen to reply. 12/12：It takes more than intelligence to act intelligently. 12/11：A minute on the lips, a lifetime on the hips. 12/10：What lies behind you and what lies in front of you pales in comparison to what lies inside of you. 12/9：Education is a progressive discovery of our own ignorance. 12/8：As long as there are those that always remember what was, there will invariably be those that are unable to accept what can be. 12/7：Everyone fails at who they’re supposed to be. The measure of a person, of a hero is how well they succeed at being who they are. Composition20213/24 Some people say that children should obey the rules of their parents and teachers, while other people think children will not be well-prepared for their adult life if they are given too much control. Discuss in both sides and give your opinion. ​ Recently, heated debates on a prevailing topic that whether children should obey the rules of their parents and teachers is negative or positive are right on their way. From my own perspective, it seems like a coin with two sides. ​ Initially, children are not able to make it possible to live a good life without parents or teachers. Hardly a day goes by without a child getting hurt and even killed on account of the disregard of the rules given by parents or teachers, some of which are of great benefits to the safety, sanitary and so forth. As it turns out these sorts of rules would equip us for lifetime provided that we truly obey them when we are young. ​ Additionally, regulations set by parents and teachers are not supposed to be our restrictions, which would wind up pushing rules through children instead of pushing children through rules. Admittedly, it is said that a mounting number of individuals are becoming less independent and impractical with limitations instead of rules and they would suddenly find themselves unprepared to encounter the adult life in future without their parents and teachers, which is exceedingly awful. ​ Ultimately, rules are indeed like a rose with its thorns. It is not what parents and teachers tell children how to do but to teach children how to react and respond to the things they confront after pondering by themselves that really matters. 202012/10 Some people say that playing computer games is bad for children in every aspect. Others say that playing computer games can have positive effects on the way children develop. Discuss both views and give your opinion. ​ Recently, heated debates on a prevailing topic that whether playing computer games is negative or positive, particularly for children, are right on their way. From my own perspective, it seems like a coin with two sides. ​ Initially, speaking of the detrimental effect that playing computer games have on children, quite a few people support that computer games would do nothing beneficial to children but to rot their brains, render them shortsighted and deprive them of precious time. Actually, it is understandable that they are concerned that these games are liable to cause slipping grades of their children. Moreover, these games serve no purpose beyond temptation so that children would devote their energy and money to the virtual world and even be addicted, which their parents regard as a serious problem. ​ Nevertheless, there are some people standing by the opinion that playing computer games can have positive effects on the way children develop. For example, children are capable of relieving stress in the school by playing computer games with their friends and classmates, which can also facilitate the relationships between them. In addition, children and even adults are overly fond of the feeling that they can do a large quantity of things in the games that seem pretty impossible in the real world. ​ Ultimately, playing computer games is indeed like a rose with its thorns, but I am in favor of the latter viewpoint. On condition that children can distinguish between hobbies and addictions, I perceive it is advisable to play computer games. VacabularyStructureMake sentences by combining the following groups of words. Use while to introduce information that contrasts with what is conveyed in the main clause. Make changes where necessary. Model: you, an early bird; your roommate, a night owl. -&gt; You may be an early bird while your roommate is a night owl. Complete the following sentences by translating the Chinese into English, using the emphatic sentences structure “It is/was … that/who … “. Model: ______(正是在这里你会真正发现) what learning is about. -&gt; It is here that you will truly discover what learning is about. Make sentences by combining the following groups of words using “not that … but (that) …”. Model: he, often,get up on his own; once in a while, suddenly, have a surge of strength. -&gt; Not that he often gets up on his own, but once in a while he ‘ll suddenly have a surge of strength. Using the infinitive phrase “to do something” to express purpose. Model: ______(为了弥补这一点), it spent tens of thousands of dollars to give every one of its incoming freshmen a free Apple iPad. -&gt; To compensate (for it), it spent tens of … . Using the structure “do/did not + verb + because … “ to express transferred negation. Model: These things happened to these people. It was not because they were lazy or stupid. -&gt; These things did not happen to these people because they were lazy or stupid. 这些事情不是因为他们懒或蠢才发生的。 Use the structure “It used to be + that … “ to emphasize a discontinued habit or past situation in contrast to the present. Model: the word hero, reserve, those, perform, acts of distinct courage, beyond, the call of duty. -&gt; It used to be that the word hero was reserved for those who performed acts of distinct courage beyond the call of duty. Using the emphatic sentences structure “participle + prepositional phrase + be “. Model: ______(一半已被水流淹没的是) the car. -&gt; Half submerged in the current was the car. Using the structure “It is/was said/reported, etc. that … “. Model: Cliff Young was said never to keep a single prize. -&gt; It was said that Cliff Young never kept a single prize. said, reported, thought, known, etc. Using “not without” to express affirmative meaning. Model: Of course, participation in competitive teams sports is ______(并非没有危害). -&gt; Of … is not without hazards. Use whereas to suggest that although something is true of on thing, it is not true of another. Model: true, more disengaged students, more likely, work long hours, to begin with; appear working, marginal situation, worse. -&gt; Whereas it is true that more disengaged students are more likely to work long hours to begin with, it appears that working makes a marginal situation worse. Using the “given that … “ structure. Model: ______(鉴于一半的大四打工学生……打工都超过20小时的上限). Indications are that a large number of students are at risk of compromising their school careers with their part-time jobs. -&gt; Given that half of all employed seniors … work above the 20-hour limit, indications … jobs. Using “whether or not” or “whether … or not”. Model: ______(不管是否会被发现), dishonesty has an undesirable effect on anyone who practices it. -&gt; Whether discovered or not, dishonesty … it. Using the structure “hardly a day/week/month, etc. goes by without … “. Model: Almost every day a reluctant office worker rides an elevator with someone talking loudly on the cell phone. -&gt; Hardly a day goes by without a reluctant office worker riding an elevator with someone talking loudly on the cellphone. Using the structure “(much) to one’s relief/delight/surprise, etc. “. Model: ______(让我颇感欣慰的是), research shows that I am, indeed, a “normal guy”. -&gt; Much to my relief, research … guy. Using the structure “not so much … as … “. 与其，不如。 Model: Young boys and girls from deeply sensitive alliances, walk and talk together - ______(目的与其说是为了变得更有智慧，不如说是为了分享他们的希望，忧虑和理想，以及为了共同参与对彼此内心世界的挖掘). -&gt; Young … together - not so much to polish their wits as to share their hopes, fears, and ideals, and to join in a kind of mutual discovery of each other’s own inner life. Using “make (no/much/any) sense”. Model: Therefore, there is no sense in criticizing our students. -&gt; Therefore, it doesn’t make any sense to criticize our students. Using “might as well + present perfect” to say that it would not make any difference if you did something else. Model: “______(它们还不如是用中文写的),” he wrote. -&gt; “They might as well have been in Chinese,” he wrote. Using “no matter how/what/where”. Model: Whatever we do in life, we will have a huge advantage if we can read complex ideas and understand their meaning. -&gt; No matter what we do in life, we … meaning. Using the structure “there is little/no doubt + that …”. Model: ______(毫无疑问，上大学能让年轻人接触到新思想和新关系) and helps promote their critical thinking skills. -&gt; There is little doubt that attending college has the potential for exposing young people to new ideas and relationships and … skills. have the potential for … Using the independent structure “with + n. + v.-ing”. Model: We think of infancy before childhood and middle age before old age, and each unique phase brings its own peculiar set of challenges. -&gt; We … age, with each unique phase bringing its own peculiar set of challenges. peculiar: adj, 奇怪的，古怪的；异常的；特有的，特殊的; Using the independent structure “with + n. + prepositional phrase”. Model: Four bamboo cane chairs are sitting on the porch, ______(每把椅子上面都有亮着的灯). -&gt; Four … porch, with lighted lamps in every one of them. Rewrite the following sentences by changing the “if” clause to a “with” phrase to indicate how a certain condition can affect a particular situation. Model: If it’s a casual dating, it relieves much pressure and achieves more equality. -&gt; With casual dating, there’s less pressure and more equality. Using the inverted structure “adj./adv. + as + main clause”. Model: ______(虽然很难), if I want to date - I have to ask guys out! -&gt; Hard as it is, if … out! Using “imperatives + and/or + statements” structure. Here the imperative sentence is similar to an “if” clause. Model: Your failure to pay is unacceptable. ______(马上支付，要不然你会有麻烦). -&gt; Your … unacceptable. Pay immediately or you’ll be in trouble. Using “there is nothing more + adj. + than … “ to practice the structure of comparison. Model: To exemplify a parent’s nightmare was much terrifying to me than anything else. -&gt; There was nothing more terrifying to me than exemplifying a parent’s nightmare. exemplify: vt: 是…的典型；例示，举例证明； Using “the more … the more …” structure. Model: If you earned more money, you were the better player, given a total of 100 clicks. -&gt; The more money you earned, the better player you were, given a total of 100 clicks. Using “when it comes to … “. Model: We are told we’re in the “driver’s seat”, ______(谈到组织和规划我们的生活). -&gt; We … seat, when it comes to organizing and planning our lives. Using “would rather + v.”. Model: Monica applied for a job as an administrative assistant in 1971. She was asked whether she preferred working for a male or a female attorney. -&gt; When Monica … 1971, she was asked whether she would rather work for a male or a female attorney. attorney: 代理人；律师； Using the structure “as is the case with … “.同样的情况 Model: When the principles themselves are in question, computer modeling alone is of little value. The same is true of the complex biological systems of human life under study. -&gt; When … value, as is the case with the complex biological systems of human life under study. As is often the case：常有的事 Using the structure “as … as …”. Model: The two nice ladies were ______(如同人们期望的一样在收容所里小心地照顾着我们). -&gt; The … were as attentive to us in the shelter as they were expected. Using the sentence pattern “prefer to do sth. (rather) than do sth.” Model: Firms tended to hire less qualified men. They didn’t want to risk hiring a female lawyer, which was unprecedented. -&gt; Firms prefered to hire less qualified men rather than risk hiring a female lawyer, which was unprecedented. Using the conjunction “as” after a verb to mean that something is true despite what you are saying. Model: But______(无论他怎么尽力去找), none of the regular DJs were available. -&gt; But try as he might, none … available. Using the structure “nothing … as much as”. Model: Water scared me most. -&gt; **Nothing scared me as much as water. ** Using the subjunctive structure “It be/become imperative/essential/crucial/vital/important/necessary that sb. (should) do …” Model: It became______(我必须找到她). -&gt; It became imperative that I find her. Using the parallel structure “it is not … that … ; it is … that …”. Model: Steven isn’t in his present position by any coincidence. Steven’s committed spirit has strengthened him in standing fast against all rejections, prejudice and skepticism and driven him to keep moving onward. -&gt; It is not by any coincidence that Steven is in his present position; It is Steven’s committed spirit that has strengthened him standing fast agains all rejections, prejudice and skepticism and driven him to keep moving onward. stand fast 坚持立场，拒不让步 Using the pattern “as it is” or “as they are”(“as” used as conjunction) meaning “in the present situation sth. is in”. Model: Audrey had a complete lack of ego and accepted and______(欣赏别人的真我). -&gt; Audrey … and appreciated others as they were. Using “as it turned out”. Model: At last, I found that she was offering to let me stay at her flat and even had a friend come show me around the city the next day. -&gt; As it turned out,she … day. Using “take sth. with a laugh/a smile/gratitude/a nod/a deep bow, etc”. Model: those little annoyances, those inefficiencies, and those boring bureaucrats(对…一笑了之). -&gt; Take those bureaucrats with a laugh. Using “be it … or …”, which often introduces an adverbial clause of concession in subjunctive mood. Model: They hurl their passion into their work, no matter whether it is physical like the work of a smith, or more mental like that of a scientist or an artist. -&gt; They … work, be it physical … smith, or more … artist. Using “find onself v.ed/v.ing”, which means “discover or realize that one is in a state or doing something without really intending or planning to”. Model: Then I ______(发现自己在他的店里逗留或隔几天去拜访一下), just to chat with him for the joy he would impart. -&gt; Then I found myself lingering in his store or dorpping in every few days, just … impart. Using “be worth next to nothing”. Model: Death is the punishment for the robbery of coal or wood — human life is now not worth a penny. -&gt; Death … life is now worth next to nothing. Using the sentence pattern “look like + clause”. Model: This little guy______(看起来可以在这饱餐一顿), and the camp had more than enough food. -&gt; This little guy looked like he could use a good meal, and … food. Using “what if …”. Model: But what would happen if, instead, your eyes worked as a “positive feedback” mechanism? -&gt; But what if, instead … mechanism? Using the structure “end up doing something”. Model: Sue knew that in all likelihood, ______(她最终会以车为家). -&gt; Sue … likelihood, **she would end up living in a car. ** in all likelihood 十有八九，多半，可能性很大 Using “admittedly”. Model: To tell the truth, I also did not then go out and get hundreds of practice tests and work through them with my daughter far in to the night, doing whatever it took to get her the A. -&gt; Admittedly, I … A. admittedly (尤用于句首)诚然，无可否认 Using “when the time comes to”. Model: ______(当到了该表现时), Chinese children have a blueprint for success; they know how to compete with the best the world has to offer. -&gt;When the time comes to perform, Chinese … offer. when the time comes to + do when it comes to + doing/n. Using the structure “the time has come for sth.(or for sb./sth. to do sth.)” Model: It was now time to convert our relationship from academic to romantic. -&gt;The time has come for the conversion of our relationship from academic to romantic. Using the phrase “in that” to introduce the reason Model: These forums are unique______(因为它们给视角不同的人提供了一个进行公开、真诚交流的场所). -&gt; These forums are unique in that they provide a venue for those with varying perspectives to have an open and honest dialog. Article20214/7 From HERE Original From https://www.smh.com.au/ Attitude Can Be a Powerful Mental Tool Last year, a child was born at a hospital in the UK with her heart outside her body. Few babies survive this rare condition, and those who do must endure numerous operations and are likely to have complex needs. When her mother was interviewed, three weeks after her daughter’s birth, she was asked if she was prepared for what might be a daunting task caring for her. She answered without hesitation that, as far as she was concerned, this would be a “privilege”. Rarely has there been a better example of the power of attitude, one of our most powerful psychological tools. Our attitudes allow us to turn mistakes into opportunities, loss into the chance for new beginnings. An attitude is a settled way of thinking, feeling and/or behaving towards particular objects, people, events or ideologies. We use our attitudes to filter, interpret and react to the world around us. You weren’t born with attitudes; rather they are all learned, and this happens in a number of ways. The most powerful influences occur during early childhood and include both what happened to you directly, and what those around you did and said in your presence. As you acquire a distinctive identity, your attitudes are further refined by the behavior of those with whom you identify — your family, those of your gender and culture, and the people you admire, even though you may not know them personally. Friendships and other important relationships become increasingly important, particularly during adolescence. About that same time and throughout adulthood, the information you receive, especially when ideas are repeated in association with goals and achievements you find attractive, also refine your attitudes. Many people assume that our attitudes are internally consistent, that is, the way you think and feel about someone or something predicts your behavior towards them. However, many studies have found that feelings and thoughts don’t necessarily predict behavior. In general, your attitudes will be internally consistent only when the behavior is easy, and when those around you hold similar beliefs. That’s why, for example, many say they believe in the benefits of recycling or exercise, but don’t behave in line with their views, because it takes awareness, effort and courage to go beyond merely stating that you believe something is a good idea. One of the most effective ways to change an attitude is to start behaving as if you already feel and think the way you’d prefer to. Take some time to reflect on your attitudes, to think about what you believe and why. Is there anything you consider a burden rather than a privilege? If so, start behaving — right now — as if the latter is the case. 4/5 From HERE What Does It Mean To Be Human? In a few decades, artificial intelligence (AI) will surpass many of the abilities that we believe make us special. This is a grand challenge for our age and it may require an “irrational” response. One of the most significant pieces of news from the US in early 2017 was the efforts of Google to make autonomous driving a reality. According to a report, Google’s self-driving cars clocked 1,023,330 km, and required human intervention 124 times. That is one intervention about every 8,047 km of autonomous driving. But even more impressive is the progress in just a single year: human interventions fell from 0.8 times per thousand miles to 0.2, a 400% improvement. With such progress, Google’s cars will easily surpass my own driving ability later this year. Driving once seemed to be a very human skill. But we said that about chess, too. Then a computer beat the human world champion, repeatedly. The board game Go took over from chess as a new test for human thinking in 2016, when a computer beat one of the world’s leading professional Go players. With computers conquering what used to be deeply human tasks, what will it mean in the future to be human? I worry about my six-year-old son. What will his place be in a world where machines beat us in one area after another? He’ll never calculate faster, never drive better, or even fly more safely. Actually, it all comes down to a fairly simple question: What’s so special about us? It can’t be skills like arithmetic, which machines already excel in. So far, machines have a pretty hard time emulating creativity, arbitrary enough not to be predicted by a computer, and yet more than simple randomness. Perhaps, if we continue to improve information-processing machines, we’ll soon have helpful rational assistants. So we must aim to complement the rationality of the machine, rather than to compete with it. If I’m right, we should foster a creative spirit because a dose of illogical creativity will complement the rationality of the machine. Unfortunately, however, our education system has not caught up to the approaching reality. Indeed, our schools and universities are structured to mould pupils to be mostly obedient servants of rationality, and to develop outdated skills in interacting with outdated machines. We need to help our children learn how to best work with smart computers to improve human decision-making. But most of all we need to keep the long-term perspective in mind: that even if computers will outsmart us, we can still be the most creative. Because if we aren’t, we won’t be providing much value in future ecosystems, and that may put in question the foundation for our existence. 2/24 From HERE Puppy Love For some people, there’s no better companion than man’s best friend –a dog. This four-legged canine can bring comfort and joy and provide much-needed exercise for you when it needs walkies! This probably explains why dog ownership increased last year because people spent more time at home during the coronavirus pandemic lockdown. It was demand for puppies in particular that saw the biggest increase. Who couldn’t resist their playful personalities, adorable eyes, and super-soft coats? However, as demand for a new puppy increased, so did the price tag. Popular breeds, such as Cockapoos and Cocker Spaniels, saw even sharper price increases, and puppies have been selling for £3,000or more. Animal welfare charities fear that high prices could encourage puppy farming, smuggling or dog theft. But despite some new owners purchasing a dog legally, maybe from a rescue centre or registered breeder, they’ve proved to be ill-prepared for life with a new pet, and the pet itself has found it hard tocome to terms with life in a new home. Looking to the future, there are concerns about the welfare of these much-loved pets. Ian Atkin, manager of the Oxfordshire Animal Sanctuary in the UK, told the BBC: “At the moment, the dogs are having a great time, but separation anxiety could still surface when people go back to work.” And Claire Calder from the UK’s Dogs Trust rescue charity says “the economic situation also means that some people may find they can’t afford to look after a dog.” The message is not to buy a puppy in haste and to pick one that fits into your lifestyle. 2/23 From HERE Two Apples A sweet little girl was holding two apples in both hands. Her mum came in, and with a smile, softly asked her daughter: “Sweetie, could you give your mum one of those apples?” The girl looked up at her mum for a few seconds, then suddenly took a quick bite of one apple, and then a quick bite of the other. The mum felt the smile on her face freeze. She tried hard not to reveal her disappointment. Then the little girl handed one of her bitten-into apples to her mum, and said: “Here you are, Mummy. This one is much sweeter.” No matter who you are, how experienced you are, or how knowledgeable you think you are, don’t pass judgment without giving others the chance to explain themselves first. What you first see, may not be the reality. Never conclude for others. 2/22 From HERE Everyone Has a Story in Life A 24-year-old boy seeing out from the train’s window shouted, “Dad, look the trees are going behind!” Dad smiled and a young couple, sitting nearby, looked at the 24-year-old’s childish behavior with pity. Suddenly he again exclaimed, “Dad, look the clouds are running with us!” The couple couldn’t resist and said to the old man, “Why don’t you take your son to a good doctor?” The old man smiled and said, “I did and we are just coming from the hospital. My son was blind frombirth. He just got his eyes today.” Every single person on the planet has a story. Don’t judge people before you truly know them. The truth might surprise you. 2/12 From HERE Why Do We Laugh? People from all cultures laugh, although we may laugh at different things. Humans start laughing as early as 3 months into life, even before we can speak. So, the ubiquitous nature of laughter suggests that it must serve a purpose, but what? Laughter serves a social function. It is a way for us to signal to another person that we wish to connectwith them. We’re more likely to laugh in a group. Young children between the ages of 2.5 and 4 were found to be eight times more likely to laugh at a cartoon when they watched it with another child. Evolutionarily speaking, this signal of connection likely played an important role in survival. Upon meeting a stranger, we want to know: What are your intentions with me? And who else are you aligned with? Another theory is that laughter may be a replacement for the act of grooming each other. Grooming another is a behavior seen in primates and requires trust and investment of time. As our communities got larger, we couldn’t all go around grooming each other to establish bonds. But laughter, like the commitment offered through grooming, is hard to fake; unlike grooming, it can be done in a larger group. When we genuinely laugh, we signal that we are comfortable and feel like we belong. There are also a multitude of physical health benefits to laughter. Laughter can increase your oxygen intake, which can in turn stimulate your heart, lungs, and muscles. The act of increasing and then decreasing our heart rate through laughter is also ultimately calming and tension-relieving. So laughter signals cooperation, a key aspect of human survival, and promotes a healthier body to boot. 2/1 From HERE What Makes Us Afraid？ What are the things that scare you: snakes, spiders or creepy crawlies? Or maybe you have a fear of heights or visiting the dentist. Although some of us just get scared or a bit nervous about these things, for others it can cause an irrational reaction that can’t be controlled –something we call a phobia. It occurs when someone develops an exaggerated or unrealistic sense of danger about a situation or object. Sometimes it’s good to be aware of the possible dangers from things. Our brain alerts us to the risks that might lie ahead, but then we often rationalise the risks and overcome them. But phobias are stronger than just fears. Clinical psychologist Warren Mansell says: “An area called the amygdala in the brain is recognising a threat and preparing your body for fight or flight.” With a phobia, your breathing gets quicker, your pulse speeds up, you sweat, and your brain is unable to control these reactions. But where does a phobia come from? Lauren Rosenberg, a fear and phobia expert, says: “Phobias usually are a copy behaviour from a higherauthority, like a parent or teacher, or something you have learnt from your own experience.” Or a trauma from a past event that comes back to haunt you. There are many different complex phobias some people suffer from, such as agoraphobia –triggered by being away from home, social anxiety disorder –feeling anxious in social situations, and iatrophobia –fear of doctors. But how can they be overcome? Cognitive behavioural therapy is one option, where you gradually get used to whatever it is you fear. Lauren Rosenburg says she likes to work with people to clear their subconscious memory and help them breathe. But if you do have a phobia, continually trying to avoid what you’re afraid of is likely to make the situation worse, so it’s a good idea to find help to overcome it. 1/31 From HERE Escapism，Procrastination，and the Dark Playground We often try to escape realities that seem overwhelming or that we don’t like. In a study from StudyMode, feeling overwhelmed and not liking the work are the top 2 reasons college students procrastinate. Because students do not like the work they are assigned to do, or don’t know where to start, instead they divert their attention and escape into things they would rather be doing or are easier to understand. In a post from two weeks ago, The Internet: Procrastination Station, it was noted that TV and movies, along with social media are the top two avenues used for procrastination among college students. However, indulging fantasy or our sense of instant gratification is a way to escape reality. And this takes us to a dark place; a place where we play and partake in unearned leisure activities. This place is named the dark playground. In the dark playground, we choose fun over work and responsibility and as a result that “fun” is clouded by guilt. The dark playground is important in appropriately giving escapism a home in relation to procrastination. Say, for example, if you were to spend 3 hours watching TV series when you should be writing an essay, that’s where escapism becomes procrastination and where guilt is wrapped in fun in the dark playground. As long as you are trying to avoid something, a part of you is vibrating at a level of shame or guilt. To avoid entering the dark playground, you need to confront what you are trying to escape from. Face it and get it done. This is the key to overcome the tricky beast, procrastination. 1/30 From HERE Comparison Is the Thief of Joy In our life, we all try to get better every day. We all set dreams in our life. To win the life race, we work hard and with the time we finally accomplish it. We become happy and celebrate it. It is all right and it should be in that way. But our happiness last for very short time when we start comparing the things with others. We all want to get ahead among friends, colleagues, and even among family. If today you are happy just because you have more than others then be ready to lose your happiness because it will start vanishing when you see someone else having more than you. You spent months or may be even years to get where you are. But it will only take a few days to end your feeling of joy if it is based on what others have. Actually you can never compare yourself with others. You may know yourself completely. You may be aware of what you have and how you got that. But you can never know what circumstances someone else has and how he got that. You can compare one factor but you never even know other factors. What you see is not always the whole thing. Respect every one for what he is and love yourself for whatever you are. If you still want to compare, compare with yourself. Think what you have done better today than you did yesterday. Keep yourself growing and celebrate your victories without comparing them to anyone else. It is good to get inspired from someone you think is better than you. But do not get caught by comparison. Always remember that you are absolutely unique. Just like everyone else. 1/25 From HERE How to Break Bad Habbits Habits are ways of dealing with issues in your environment. You often do not think about them. James Clear, in his book Atomic Habits, describes a four-step process by which habits are made. These steps are cue, craving, response, and reward. A cue is a signal. It tells your brain to do something: to begin a behavior. A craving is a desire for something. The response, or reaction, is the habit that you perform. The response gives you a reward. Imagine you are studying English. Perhaps you are learning new words or expressions. But then you feel the need to check your phone. You return to your studies, only to look again at your phone a short time later. This process, when repeated many times, could reduce your ability to learn new material. It is what you might call a bad habit –a custom or repeated action that has a negative effect on you or your goals. James Clear notes that to break bad habits, you need to think about each step in the habit-making process. In the cell phone example, the cue is seeing the cell phone. The craving is the desire or urge to check your phone. The response is checking your phone. The reward might be seeing something interesting on social media, for example. To break a habit, he writes, you should think about making the bad habit invisible, unattractive, difficult and unsatisfying. To make your phone invisible, you could hide it away. To make it unattractive, you could think about why it is a good idea to stop checking the phone. To make phone use difficult, you can increase the space between you and your phone. To make your phone unsatisfying, you could make a habit contract. The important thing to remember is that people can change their habits. Habit changes take time. But with patience, planning, and repetition, you can do it. 1/7 From HERE The Seasons of Life There was a man who had four sons. He wanted his sons to learn to not judge things too quickly. So he sent them each on a quest, in turn, to go and look at a pear tree that was a great distance away. The first son went in the winter, the second in the spring, the third in the summer, and the youngest son in the fall. When they had all gone and come back, he called them together to describe what they had seen. The first son said that the tree was ugly, bent, and twisted. The second son said no — it was covered with green buds and full of promise. The third son disagreed. He said it was laden with blossoms that smelled so sweet and looked so beautiful; it was the most graceful thing he had ever seen. The last son disagreed with all of them; he said it was ripe and drooping with fruit, full of life and fulfilment. The man then explained to his sons that they were all right, because they had each seen but one season in the tree’s life. He told them that you cannot judge a tree, or a person, by only one season, and that the essence of who they are — and the pleasure, joy, and love that come from that life — can only be measured at the end, when all the seasons are up. If you give up when it’s winter, you will miss the promise of your spring, the beauty of your summer and fulfilment of your fall. Don’t judge a life by one difficult season. Don’t let the pain of one season destroy the joy of all the rest. 202012/13 From HERE Why Is It So Hard to Put Down Our Phones? How many times have you picked up your phone and looked at something in the last hour? The average Brit checks their screen every 12 minutes, according to the latest research. You might find yourself checking your phone at the slightest feeling of boredom, purely out of habit. App developers are not relying on you to come to them whenever you have a bit of downtime, they want to grab your attention. For example, push notifications make sure you keep picking up your phone to see what the announcement is and to see what you may have missed. There may be something new and enticing for us to engage with, or we may have received lots of likes for a social media post. When we do get a like, a follower, comment or share of our post, it excites the brain and produces a chemical which you may have heard of called dopamine. This is a chemical that provides a “feel-good” response to these rewards. Because it feels good, we are tempted to repeat the activity that created the good feeling. This loop is one of the biggest reasons why we are checking our phones every 12 minutes. So, how can we break the loop so that real life does not pass us by? The first is to turn off all notifications on your phone so that you are not distracted or tempted by the alluring messages. Next is to put your phone out of sight. This is particularly helpful if you are revising or have a project to get done. Finally, look for and create opportunities for gaining a dopamine hit in other ways, for example through exercise or music."}],"posts":[{"title":"Java-Part7","slug":"Java-Part7","date":"2021-04-07T13:06:34.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/04/07/Java-Part7/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/07/Java-Part7/","excerpt":"","text":"Java中的多线程 线程定义 目前Java程序都是串行执行的，也就是每个语句依次执行； 有时候需要程序并行执行： 有时系统有多个工作要同时完成：例如一边打字、一边听歌；一边开视频会议、一边看网页； 利用CPU多线程的特性。 一个进程可以有多个线程在执行。 创建线程的方法Method1 通过继承Thread类创建线程 注意启动线程用start()方法而不能用run()方法 1234567891011121314151617181920212223242526272829303132//ch09.TestThread1package ch09;/** * 多线程的例子，注意运行程序时候的输出 */public class TestThread1 &#123; public static void main(String args[]) &#123; Thread t = new MyThread1(100); t.start(); System.out.println(&quot;Main thead end!&quot;); &#125;&#125;class MyThread1 extends Thread &#123; private int n; public MyThread1(int n) &#123; this.n = n; &#125; public void run() &#123; for (int i = 0; i &lt; n; i++) &#123; System.out.print(&quot; &quot; + i); if ((i + 1) % 20 == 0) &#123; System.out.println(&quot;&quot;); &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; Method2 通过向Thread()构造方法传递Runnable对象来创建线程 注意启动线程用start()方法而不能用run()方法 1234567891011121314151617181920212223242526272829303132//ch09.TestThread2package ch09;/** * 多线程的例子 */public class TestThread2 &#123; public static void main(String args[]) &#123; MyThread2 mytask = new MyThread2(100); Thread t = new Thread(mytask); t.start(); &#125;&#125;class MyThread2 implements Runnable &#123; private int n; public MyThread2(int n) &#123; this.n = n; &#125; public void run() &#123; for (int i = 0; i &lt; n; i++) &#123; System.out.print(&quot; &quot; + i); if ((i + 1) % 20 == 0) &#123; System.out.println(&quot;&quot;); &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 两种方法比较 使用Runnable接口； 直接继承Thread类； 无论使用哪种方法，注意启动线程用start()方法而不能用run()方法。 多线程的实例Example11234567891011121314151617181920212223242526272829//ch09.sync.sum.SumMain.javapackage ch09.sync.sum;public class SumMain &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int threadCount = 100; double sum = 0; long mill=System.currentTimeMillis(); SumThread[] threads = new SumThread[threadCount]; long start = 0; long end = 1000000000L; for (int i = 0; i &lt; threads.length; i++) &#123; long threadStart = start + (end - start) / threadCount * i; long threadEnd = start + (end - start) / threadCount * (i + 1); threads[i] = new SumThread(threadStart, threadEnd); threads[i].start(); &#125; for (int i = 0; i &lt; threads.length; i++) &#123; try &#123; threads[i].join(); sum = sum + threads[i].getSum(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;System.out.println((System.currentTimeMillis()-mill)+&quot; ms cost!&quot;); System.out.println(&quot;sum=&quot; + sum); &#125;&#125; thread.join()，等待这个线程结束； 多线程可以显著提升系统性能； 比较SumMain中1/2/3/4/5个线程时消耗的时间。 Example2(ridiculous!)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//ch09.join.MySort.javapackage ch09.join;import java.util.ArrayList;import java.util.List;/** * 一种奇葩的排序算法 */public class MySort extends Thread &#123; private List&lt;Integer&gt; list; private int value; public MySort(List&lt;Integer&gt; list, int value) &#123; this.list = list; this.value = value; &#125; @Override public void run() &#123; try &#123; this.sleep(value); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; list.add(value); &#125; public static void main(String[] args) &#123; int[] arrays = &#123; 1230, 571, 340, 454, 1, 30, 60, 300, 89, 1999, 765 &#125;; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); MySort[] threads = new MySort[arrays.length]; for (int i = 0; i &lt; arrays.length; i++) &#123; threads[i] = new MySort(list, arrays[i]); &#125; for (int i = 0; i &lt; arrays.length; i++) &#123; threads[i].start(); &#125; for (int i = 0; i &lt; arrays.length; i++) &#123; try &#123; threads[i].join(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; System.out.print(list.get(i)+&quot;,&quot;); &#125; &#125;&#125; Daemon线程和非Daemon线程123456789101112131415161718192021222324252627282930313233343536373839404142434445//ch09.TestThreadDaemon.javapackage ch09;/** * Daemon线程和非Daemon线程的区别 */public class TestThreadDaemon &#123; public static void main(String args[]) &#123; Thread t1 = new MyThread(); // 尝试一下false t1.setDaemon(true); t1.start(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;main thread end&quot;); &#125;&#125;class MyThread extends Thread &#123; static int id = 0; MyThread() &#123; id++; &#125; public void run() &#123; System.out.println(&quot;Start&quot;); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; &#125; // yield(); &#125; &#125;&#125;/* * 9.2.4 Daemon线程 * 线程有两种，一类是Daemon线程，一类是非Daemon线程。在Java程序中，若还有非Demon线程，则整个程序就不会结束；而Daemon线程， * 可以在整个程序结束后继续运行，所以Demon线程可以用于后台服务程序。 * 通过调用isDaemon()，可检查一个线程是不是一个Daemon；用setDaemon (boolean * flg)方法可以将一个线程设为Daemon线程。在一个Daemon线程中创建的子线程，也自动是Daemon线程。 * */ Thread.setDaemon(true/false)； Deamon线程→主程序终止，线程终止； 非Deamon线程→主程序终止，线程不终止。 多线程访问的冲突问题解决方法 因为多线程的原因，同一个对象，同一个时刻可能有多个线程访问，进而导致冲突 解决方式：使用synchronized 可加在方法、对象、类上 12//ch09.counter0.SyncCounter0.java//ch09.sync.stack0.MyStackUserThread 解决了多线程访问冲突之后的例子 12//ch09.counter1.SyncCounter1.java//ch09.sync.stack1.MyStackUserThread synchronized带来的死锁问题12345678910111213141516171819202122232425262728293031323334353637383940//ch09.lock.DeadLockTestpackage ch09.lock;/** * 死锁的例子 */public class DeadLockTest &#123; public static void main(String args[]) &#123; Operator o1 = new Operator(); Operator o2 = new Operator(); o1.anotherOperator = o2; o2.anotherOperator = o1; Thread t1 = new Thread(o1); Thread t2 = new Thread(o2); t1.start(); t2.start(); &#125;&#125;//ch09.lock.Operator.javapackage ch09.lock;/** */public class Operator implements Runnable &#123; Operator anotherOperator; synchronized public void methodA(int depth) &#123; System.out.println(Thread.currentThread().getName() + &quot;:begin methodA&quot;); if(depth&lt;=0) &#123; return; &#125; try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; &#125; System.out.println(Thread.currentThread().getName() + &quot;:call another methodA&quot;); anotherOperator.methodA(--depth); System.out.println(Thread.currentThread().getName() + &quot;:end methodA&quot;); &#125; public void run() &#123; methodA(1); &#125;&#125; 由于Operator中定义的methodA方法有synchronized修饰，所以当o1i调用方法的同时需要o2也调用该方法，但是o2在等待o1，造成了相互等待的情况，即死锁。反之亦然 死锁定义 当一个线程等待由另一个线程持有的锁，而后者正在等待已被第一个线程持有的锁时，就会发生死锁； Java不监测也不视图避免这种情况。因而保证不发生死锁就成了程序员的责任。 实例1//ch09.lock.DeadLockTest 避免死锁 控制锁的范围； 按序分配资源。 程序的状态与生命周期 在一个线程的生命周期中，它总处于某一种状态中； 线程的状态表示了线程正在进行的活动以及在这段时间内线程能完成的任务。 多线程的控制生产者·消费者问题 不断使用某类资源的线程称为消费者； 不断产生或释放同类资源的线程称为生产者； 通过协调生产者和消费者的关系，保证生产的东西及时消费掉，也保证消费者总能够有资源可使用。 12345678910111213//ch09.producer_consumer.ProducerConsumerDemo.javapackage ch09.producer_consumer;/** * 一个生产者、消费者模型的例子 */public class ProducerConsumerDemo &#123; public static void main(String args[]) &#123; Stack stack = new Stack(&quot;stack1&quot;); new Producer(stack, &quot;producer1&quot;).start(); new Consumer(stack, &quot;consumer1&quot;).start(); &#125; &#125;//producer和consumer的定义在同一个包下 线程中常用方法notify()/notifyAll() notify()：用来选择并唤醒等候进入监视器的线程； notifyAll()：唤醒所有等待的线程； 只有获得锁以后，才有权力调用notify()/notifyAll()方法。 wait()方法 wait()方法使当前线程处于等待状态，直到别的线程调用notify()方法来通知/唤醒它 如何终止线程 当线程执行完run()方法，它将自然终止运行； Thread有一个stop()方法，可以强制结束线程，但这种方法是不安全的。因此，目前stop()方法已经被废弃； 实际编程中，一般是定义一个标志变量，然后通过程序来改变标志变量的值，从而控制线程从run()方法中自然退出。 123456789101112131415161718192021222324252627282930313233//ch09.ThreadTerminateByFlag.javapackage ch09;import java.util.*;public class ThreadTerminateByFlag &#123; public static void main(String args[]) &#123; Timer timer = new Timer(); Thread thread = new Thread( timer ); thread.setName( &quot;Timer&quot; ); thread.start(); for( int i=0; i&lt;100; i++ )&#123; System.out.print(&quot;\\r&quot; + i ); try&#123; Thread.sleep(100); &#125;catch( InterruptedException e )&#123;&#125; &#125; timer.stopRun(); &#125;&#125;class Timer implements Runnable &#123; boolean flg = true; public void run() &#123; while(flg)&#123; System.out.print( &quot;\\r\\t&quot; + new Date() + &quot;...&quot; ); try&#123; Thread.sleep(1000); &#125;catch( InterruptedException e )&#123;&#125; &#125; System.out.println( &quot;\\n&quot; + Thread.currentThread().getName() + &quot; Stop&quot; ); &#125; public void stopRun()&#123; flg = false; &#125;&#125; 定时器：Timer&amp;TimerTask1234567891011121314151617181920212223242526//ch09.TimerTaskDemopackage ch09;import java.util.Timer;import java.util.TimerTask;/** * timertask例子 */public class TimerTaskDemo &#123; public TimerTaskDemo() &#123; // TODO Auto-generated constructor stub &#125; // public static void main(String[] args) &#123; // Timer timer = new Timer(); // timer.schedule(new MyTimerTask(), 0, 1000L); // &#125; public static void main(String[] args) &#123; Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; int i = 0; public void run() &#123; System.out.println(i++); &#125; &#125;, 0, 1000L); &#125;&#125;//ch09.TimerTaskDemo2 进程的优先级 Thread.setPriority(Thread.MAX_PRIORITY/NORM_PRIORITY/MIN_PRIORITY); 123456789101112131415161718192021222324252627282930313233343536373839//ch09.TestThreadPriority.javapackage ch09;/** * 本例子显示了不同的优先级对线程的影响 */public class TestThreadPriority &#123; public static void main(String args[]) &#123; Thread[] threads = new Thread[10]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(new MyRunner(i)); if (i % 3 == 0) &#123; threads[i].setPriority(Thread.MAX_PRIORITY); &#125; else if (i % 3 == 1) &#123; threads[i].setPriority(Thread.NORM_PRIORITY); &#125; else &#123; threads[i].setPriority(Thread.MIN_PRIORITY); &#125; &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].start(); &#125; &#125;&#125;class MyRunner implements Runnable &#123; int id; MyRunner(int id) &#123; this.id = id; &#125; public void run() &#123; double t = 0; for (int j = 0; j &lt; 100000000; j++) &#123; t = t + j; // if (j % 100 == 0) &#123; // Thread.currentThread().yield(); // &#125; &#125; System.out.println(id + &quot; finished!&quot;); &#125;&#125; ThreadLocal 如何在不传递参数的情况下，让一个线程实用程序外的一个变量？ ThreadLocal是一个线程内部的存储类； 线程间互不干扰。 12345678910111213141516171819202122232425//ch09.thread_local.MyThreadLocal.javapackage ch09.thread_local;/** * ThreadLocal 变量 */public class MyThreadLocal extends Thread &#123; public void run() &#123; for(int i=0;i&lt;5;i++)&#123; try &#123; Thread.currentThread().getName(); String value=this.getName()+&quot; &quot;+i; MyValue.getSession().set(value); Thread.sleep(1000); MyFunction.print(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 2; i++) &#123; new MyThreadLocal().start(); &#125; &#125; &#125; 文章源码文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"Java-Part6","slug":"Java-Part6","date":"2021-04-05T07:53:40.000Z","updated":"2021-04-11T04:26:34.100Z","comments":false,"path":"2021/04/05/Java-Part6/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/05/Java-Part6/","excerpt":"","text":"输入、输出流及文件管理 文件及目录File类 File类提供了若干处理文件、目录和获取它们基本信息的方法； java中目录也是文件(File)，java中没有Directory类； 1234567//File类的构造方法有三个//1File(String pathname);//2File(String parent,String child);//3File(File parent,String child); 文件类例子 在Java中，将目录也当作文件处理 1234567File f;f=new File(&quot;Test.java&quot;);//f=new File(&quot;E:\\\\ex\\\\&quot;,&quot;Test.java&quot;);//File path=new File(&quot;E:\\\\ex\\\\&quot;);File f=new File(path,&quot;Test.java&quot;); File类方法介绍 File类的作用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//创建目录//ch08.UseFile.main()//递归列目录//ch08.UseFile.listDir()//递归删目录//ch08.UseFile.deleteDir()//ch08.UseFile.javapackage ch08;import java.io.File;import java.io.IOException;import java.util.Date;public class UseFile &#123; public static void main(String args[]) throws Exception &#123; // 创建目录 File dir1 = new File(&quot;D:/dir1&quot;); if (!dir1.exists()) &#123; dir1.mkdir(); &#125; // 在某个目录下 创建目录 File dir2 = new File(dir1, &quot;dir2&quot;); if (!dir2.exists()) &#123; dir2.mkdirs(); &#125; // 在某个目录下 创建多层目录 File dir4 = new File(dir1, &quot;dir3\\\\dir4&quot;); if (!dir4.exists()) dir4.mkdirs(); // 在某个目录下 创建文件 File file = new File(dir2, &quot;test.txt&quot;); if (!file.exists()) &#123; file.createNewFile(); &#125; file = new File(&quot;D:/dir1/mytest.txt&quot;); if (!file.exists()) &#123; file.createNewFile(); &#125; listDir(dir1); deleteDir(dir1); &#125; /** * 察看目录信息 */ public static void listDir(File dir) throws IOException &#123; if (dir.isFile()) &#123; System.out.println( &quot;文件:&quot; + dir.getCanonicalPath() + &quot; 修改日期:&quot; + new Date(dir.lastModified()) + &quot; 大小:&quot; + dir.length()); return; &#125; File[] lists = dir.listFiles(); // 打印当前目录下包含的所有子目录和文件的详细信息 for (int i = 0; i &lt; lists.length; i++) &#123; File f = lists[i]; // 如果为目录，就递归调用listDir()方法 System.out.println(&quot;目录:&quot; + f.getCanonicalPath() + &quot; 修改日期:&quot; + new Date(f.lastModified())); listDir(f); &#125; &#125; /** 删除目录或文件，如果参数file代表目录，会删除当前目录以及目录下的所有内容 */ public static void deleteDir(File file) &#123; // 如果file代表文件，就删除该文件 if (file.isFile()) &#123; file.delete(); return; &#125; // 如果file代表目录，先删除目录下的所有子目录和文件 File[] lists = file.listFiles(); for (int i = 0; i &lt; lists.length; i++) &#123; deleteDir(lists[i]); // 递归删除当前目录下的所有子目录和文件 &#125; // 最后删除当前目录 file.delete(); &#125;&#125;//递归列目录//ch08.ListAllFiles.javapackage ch08;import java.io.*;/** * 使用递归的方式，列出一个目录下面所有的子目录和文件 */public class ListAllFiles &#123; public static void main(String[] args) &#123; ListFiles(new File(&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\&quot;)); &#125; public static void ListFiles(File dir) &#123; if (!dir.exists() || !dir.isDirectory()) &#123; return; &#125; String[] files = dir.list(); for (int i = 0; i &lt; files.length; i++) &#123; File file = new File(dir, files[i]); if (file.isFile()) &#123; System.out.println(dir + &quot;\\\\&quot; + file.getName() + &quot;\\t size=&quot; + file.length()); &#125; else &#123; System.out.println(dir + &quot;\\\\&quot; + file.getName() + &quot;\\t&lt;dir&gt;&quot;); ListFiles(file); // 对于子目录,进行递归调用 &#125; &#125; &#125;&#125; 输入流/输出流定义 大部分程序都需要输入/输出处理，比如从键盘读取数据、向屏幕中输出数据、从文件中读或者向文件中写数据、在一个网络连接上进行读写操作等。在Java中，把这些不同类型的输入、输出源抽象为流Stream； 按流的方向，可分为输入流与输出流。 字节流与字符流 字节流(byte) 字符流(char) 输入 InputStream Reader 输出 OutputStream Writer InputStream类 InputStream类最重要的方法是读数据的read()方法。read()方法功能是逐字节地以二进制的原始方式读取数据 1234567//read()读取数据有三种形式//1public int read();//2public int read(byte b[]);//3public int read(byte[] b,int off,int len); OutputStream类 OutputStream类的重要方法是write()，它的功能是将字节写入流中，write()方法有三种形式 1234567891011121314//1public void write(int b);//将参数b的低位字节写入到输出流//2public void write(byte b[]);//将字节数组b[]中的全部字节顺序写入到输出流//3public void write(byte[] b,int off,int len);//将字节数组b[]中从off开始的len个字节写入到流中//Others functionspublic void flush();//强制输出缓冲区中的数据public void close();//关闭流 Reader类 Reader类与InputStream类相似，都是输入流，但差别在于Reader类读取的字符(char)，而不是字节； Reader的重要方法是read()，共有三种形式： 123public int read();public int read(char b[]);public int read(char[] b,int off,int len); Writer类 Writer类与OutputStream类相似，都是输出流，但差别在于Writer类写入的字符(char)，而不是字节 123456789101112public void write(int b);//将参数b的低两字节写入到输出流public void write(char b[]);//将字符数组b[]中的全部字节顺序写入到输出流public void write(char[] b,int off,int len);//将字节数组b[]中从off开始的len个字符写入到流中public void write(String s);//将字符串写入流中public void write(String s,int off,int len);//将字符串中从off开始的len个字符写入到流中public void flush();//刷新流public void close();//关闭流 节点流和处理流 按照流是否直接与特定的地方(如磁盘、内存、设备等)相连，分为节点流与处理流两类 节点流(Node Stream) 可以从或向一个特定的地方(节点)读写数据。如文件流FileReader 处理流(Processing Stream) 是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读、写功能。处理流又称为过滤流，如缓冲处理流BufferedReader 节点流与处理流的关系 其关系如上图所示； 节点流直接与节点(如文件)相连，而处理流对节点流或其他处理流进一步进行处理(如缓冲、组装成对象等等)。 123456//处理流的构造方法总是要带一个其他的流对象作为参数//For example:BufferedReader in=new BufferedReader(new FileReader(file));BufferedReader in2=new BufferedReader( new InputstReamreader( new FileInputStream(file))); 一个流对象经过其他流的多次包装，称为流的链接 常用的节点流 节点类型 字节流 字符流 File文件 FileInputStreamFileOutputStream FileReaderFileWriter Memory Array内存数组 ByteArrayInputStreamByteArrayOutputStream CharArrayReaderCharArrayWriter Memory String StringReaderStringWriter Pipe管道 PipedInputStreamPipedOutputStream PipedReaderPipedWriter 常用的处理流 处理类型 字节流 字符流 Buffering缓冲 BufferedInputStreamBufferedOutputStream BufferedReaderBufferedWriter Filtering过滤 FilterInputStreamFilterOutputStream FilterReaderFilterWriter Converting between bytes and character字节流转为字符流 InputStreamReaderOutputStreamWriter Object Serialization对象序列化 ObjectInputStreamObjectOutputStream Data conversion基本数据类型转化 DataInputStreamDataOutputStream Counting行号处理 LineNumberInputStream LineNumberReader Peeking ahead可回退流 PushbackInputStream PushbackReader Pinting可显示处理 PrintStream PrintWriter 输入输出流例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177//ch08.ReadWriteFileByteDemo.java//InputStream/OutputStreampackage ch08;import java.io.Closeable;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * 本例子演示了如何用面向byte的方式 读取、写入文件 */public class ReadWriteFileByteDemo &#123; public static int CHUNK_SIZE = 4096; public ReadWriteFileByteDemo() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; copyFile(&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\ch08\\\\src.txt&quot;,&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\ch08\\\\target.txt&quot;); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; /** * 复制IO流 * @throws IOException */ public static void copyIO(InputStream in, OutputStream out) throws IOException &#123; byte[] buf = new byte[CHUNK_SIZE]; /** * 从输入流读取内容并写入到另外一个流的典型方法 */ int len = in.read(buf); while (len != -1) &#123; out.write(buf, 0, len); len = in.read(buf); &#125; &#125; /** * 复制文件 * @throws IOException */ public static void copyFile(String fsrc, String fdest) throws IOException &#123; InputStream in = null; OutputStream out = null; try &#123; in = new FileInputStream(fsrc); out = new FileOutputStream(fdest, true); copyIO(in, out); &#125; finally &#123; close(in); close(out); &#125; &#125; /** * 关闭一个输入 输出流 */ public static void close(Closeable inout) &#123; if (inout != null) &#123; try &#123; inout.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;//ch08.ReadWriteFileCharDemo.java//Reader/Writerpackage ch08;import java.io.Closeable;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileReader;import java.io.IOException;import java.io.LineNumberReader;import java.io.OutputStream;import java.io.Reader;import java.util.ArrayList;import java.util.List;/** * 本例子演示了如何使用char的方式 读取、写入文件 */public class ReadWriteFileCharDemo &#123; public static int CHUNK_SIZE = 4096; public ReadWriteFileCharDemo() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; String s = &quot;&quot;; try &#123; s = readFile(&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\ch08\\\\src.txt&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(s); try &#123; writeFile(&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\ch08\\\\target.txt&quot;, s); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; /** * 注意readFile和readFile2等效 * @throws IOException */ public static String readFile(String fsrc) throws IOException &#123; //这句话是否可以写成Reader reader ;为什么？ Reader reader = null; try &#123; reader = new FileReader(fsrc); StringBuffer buf = new StringBuffer(); char[] chars = new char[CHUNK_SIZE]; int readed = reader.read(chars); // 从一个流里面读取内容的经典写法 while (readed != -1) &#123; // 文件是size不能被CHUNK_SIZE整除，所以要记录每次读到的长度readed // 写入到buf的时候，不是用的 buf.append(chars); // 而是用buf.append(chars, 0, readed); buf.append(chars, 0, readed); readed = reader.read(chars); &#125; return buf.toString(); &#125; finally &#123; //reader!=null的判断是否可以取消，为什么？ if (reader != null) &#123; reader.close(); &#125; &#125; &#125; /** * 从一个文件中读取字符串 * @throws IOException */ public static String readFile2(String fsrc) throws IOException &#123; try (Reader reader = new FileReader(fsrc);) &#123; StringBuffer buf = new StringBuffer(); char[] chars = new char[CHUNK_SIZE]; int readed = reader.read(chars); // 从一个流里面读取内容的经典写法 while (readed != -1) &#123; buf.append(chars, 0, readed); readed = reader.read(chars); &#125; return buf.toString(); &#125; &#125; /** * 把字符串写到文件中 * @throws IOException */ public static void writeFile(String fileName, String content) throws IOException &#123; try (OutputStream out = new FileOutputStream(fileName, false)) &#123; out.write(content.getBytes()); out.flush(); &#125; &#125; /** * 关闭输入输入流 */ public static void close(Closeable inout) &#123; if (inout != null) &#123; try &#123; inout.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 再谈节点流和处理流 使用处理流的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//ch08.ReadFileByProcessingStream.javapackage ch08;import java.io.Closeable;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileReader;import java.io.IOException;import java.io.LineNumberReader;import java.io.OutputStream;import java.io.Reader;import java.util.ArrayList;import java.util.List;/** * 本例子演示了如何使用char的方式 读取、写入文件 */public class ReadFileByProcessingStream &#123; public static int CHUNK_SIZE = 4096; public ReadFileByProcessingStream() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; try &#123; List&lt;String&gt; lines = readLines(&quot;D:\\\\course\\\\course\\\\code_demo\\\\src\\\\ch08\\\\XiaoHe.ini&quot;); for (String line : lines) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; /** * 从一个文本文件中，一次读取一行，放到list中 * @throws IOException */ public static List&lt;String&gt; readLines(String fsrc) throws IOException &#123; try (Reader reader = new FileReader(fsrc); //LineNumberReader 必须在其他流基础上构建 LineNumberReader lineReader = new LineNumberReader(reader);) &#123; String line = &quot;&quot;; List&lt;String&gt; lines = new ArrayList&lt;String&gt;(); while (line != null) &#123; lines.add(line); //每次读取一行 line = lineReader.readLine(); &#125; return lines; &#125; &#125;&#125; System中的标准输入和标准输出 System.out提供向”标准输出”写出数据的功能 System.out为PrintStream类型； System.in提供从”标准输入”读入数据的功能 System.in为InputStream类型； System.err提供向”标准错误输出”写出数据的功能 System.err为PrintStream类型。 向标准输出写出数据 System.out/System.err的println/print方法 println方法可将方法参数输出并换行； print方法将方法参数输出但不换行； print和prinln方法针对多数数据类型进行了重写(boolean, char, int, long, float, double, char[], Object, String)； print(Object)和println(Object)方法中调用了参数的toString()方法，再将生成的字符串输出。 从标准输入读取数据 为了使用方便，经常将System.in用各种处理流进行封装处理 1234//For example:BufferedReader br=new BufferedReader( new InputStreamReader(System.in));br.readLine(); 文件的随机访问RandomAccessFile类 基于文本应用的几个问题命令行参数 在启动Java应用程序时可以一次性地向应用程序中传递0~多个参数——命令行参数； 命令函参数使用格式： 1java ClassName lisa &quot;bily&quot; &quot;Mr Brown&quot; 命令行参数被系统以String数组的方式传递给应用程序中的main方法，由参数args接收 1public static void main(String[] args)&#123;&#125; 12345678910111213//ch08.TestCommandLinepackage ch08;/** * 演示了命令行的作用 */public class TestCommandLine &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; args.length; i++) &#123; // 运行时，使用java TestCommandLine lisa &quot;bily&quot; &quot;Mr Brown&quot; System.out.println(&quot;args[&quot; + i + &quot;] = &quot; + args[i]); &#125; &#125;&#125; 命令行参数用法举例 系统属性(System Properties) 在Java中，系统属性起到替代环境变量的作用(环境变量是平台相关的)； 可使用System.getProperties()方法获得一个Properties类的对象，其中包含了所有可用的系统属性信息； 可使用System.getProperties(String name)方法获得特定系统属性的属性值； 在命令行运行Java程序时可使用-D选项添加新的系统属性。 123456789101112131415161718//ch08.TestProperties.javapackage ch08;import java.util.Iterator;import java.util.Properties;/** * 本例子演示了如何取得System.properties */public class TestProperties &#123; public static void main(String[] args) &#123; Properties ps = System.getProperties(); Iterator&lt;Object&gt; it = ps.keySet().iterator(); while (it.hasNext()) &#123; String pName = (String) it.next(); String pValue = ps.getProperty(pName); System.out.println(pName + &quot;=&quot; + pValue); &#125; &#125;&#125; 正则表达式定义 正则表达式是文本处理中常用的工具，它实际上是用来匹配字符串的一种模式。在Java中有一个正则表达式引擎(在java.util.regex包中)，可以用正则表达式来验证和处理文本字符 基本元素 123456789101112131415161718192021222324252627282930313233343536373839//ch08.RegExpDemopackage ch08;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 本例子演示了正则表达式的用法 */public class RegExpDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub findEmail( ); testTels(); splitContent(); &#125; public static void testTels( ) &#123; testTel(&quot;13820477575&quot;); testTel(&quot;123456&quot;); &#125; private static void testTel(String content) &#123; boolean match=content.matches(&quot;[0-9]&#123;11&#125;&quot;); System.out.println(content +(match?&quot; &quot;:&quot; 不&quot;)+&quot;是合法的电话号码&quot;); &#125; public static void findEmail( ) &#123; String content = &quot;天外天技术支持：cs@tju.edu.cn 联系我们：1234567890@qq.com 地址：天津市南开区&quot;; String telReg = &quot;\\\\w+@\\\\w+.[\\\\w+]+&quot;; Pattern telPattern = Pattern.compile(telReg); Matcher m = telPattern.matcher(content); while (m.find()) &#123; System.out.println(m.group(0)); &#125; &#125; public static void splitContent() &#123; String content=&quot; 第一回 甄士隐梦幻识通灵 贾雨村风尘怀闺秀 ... 第二回 贾夫人仙逝扬州城 冷子兴演说荣国府 ... 第三回 托内兄如海酬训教 接外孙贾母惜孤女 ....&quot;; String contents[] = content.split(&quot;第[一,二,三,四,五,六,七,八,九,十,零]&#123;1,3&#125;回 &quot;); for(String title:contents) &#123; System.out.println(title); &#125; &#125;&#125; Points try{}final{}中如果有impments Closable的对象要申请并关闭的时候，ch08.ReadWriteFileCharDemo中两种写法等效 reader必须impments Closable； 必须在try{}里面申请。 12//From ch08.ReadWriteFileCharDemo//readFile &amp; readFile2 文章源码文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"CodeExercise-2021/4","slug":"CE-2021-4","date":"2021-04-01T01:55:42.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2021/04/01/CE-2021-4/","link":"","permalink":"https://cheeseburgerim.github.io/2021/04/01/CE-2021-4/","excerpt":"","text":"","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"CodeExercise","slug":"CodeExercise","permalink":"https://cheeseburgerim.github.io/tags/CodeExercise/"},{"name":"Exercise","slug":"Exercise","permalink":"https://cheeseburgerim.github.io/tags/Exercise/"},{"name":"Practice","slug":"Practice","permalink":"https://cheeseburgerim.github.io/tags/Practice/"}]},{"title":"数值分析方法与Matlab-Part1","slug":"NCMAM-Part1","date":"2021-03-31T13:25:48.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/03/31/NCMAM-Part1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/31/NCMAM-Part1/","excerpt":"","text":"","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"NCMAM","slug":"NCMAM","permalink":"https://cheeseburgerim.github.io/tags/NCMAM/"}]},{"title":"Java-Part5","slug":"Java-Part5","date":"2021-03-30T14:20:21.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/03/30/Java-Part5/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/30/Java-Part5/","excerpt":"","text":"工具类及常用算法 一Java基础类库 java.lang.Object类 Object类是Java程序中所有类的直接或间接父类 equals() 用来比较两个对象是否相同，如果相同，则返回true；否则返回false； 它比较的是两个对象状态和功能上的相同，而不是引用上的相同； Object.equals默认实现 123public boolean equals(Object obj)&#123; return (this==obj);&#125; Integer.equals实现 123456public boolean equals(Object obj)&#123; if(obj instanceof Integer)&#123; return value==((Integer)obj).intValue(); &#125; return false;&#125; String.equals实现 1234567891011121314151617181920212223//ch07.eq.TestEqualsString//ch07.eq.TestEqualsObjectpublic boolean equals(Object anObject)&#123; if(this==anObject)&#123; return true; &#125; if(anObject instanceof String)&#123; String anotherString=(String)anObject; int n=value.length; if(n==anotherString.value.length)&#123; char v1[]=value; char v2=another.value; int i=0; while(n--!=0)&#123; if(v1[i]!=v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 在强调一次，equals()比较的是两个对象状态和功能上的相同，而不是引用上的相同 123456Integer one=new Integer(1);Integer anotherOne=new Integer(1);if(one.equals(anotherOne))&#123; System.out.println(&quot;Objects are equal&quot;);&#125;//例中，equals方法返回true，因为对象One和anotherOne包含相同的数值1 getClass() getClass()方法是final方法，它不能被重载； 它返回一个对象在运行时所对应的类的表示，从而可以得到相应的信息。 下面的方法得到并显示对象的类名： 123void PrintClassName(Object obj)&#123; System.out.println(&quot;The object&#x27;s class is&quot;+obj.getClass().getName());&#125; toString() toString()方法用来返回对象的字符串表示，可以用来显示一个对象； 通过重载toString()方法可以适当地显示对象的信息以进行调试。 finalize() 用于在垃圾收集前清楚对象。 基本数据类型的包装类 double转成String的几种方法 String转成double的几种方法 Math类 System类 1//ch07.SystemDemo 字符串程序中需要用到的字符串可以分为两大类，一类是创建之后不会再做修改和变动的字符串常量；另一类是创建之后允许再做更改和变化的字符串。前者是String类，后者是StringBuffer/StringBuilder类。 Character：这个类的实例可以容纳单一的字符数值。该类还定义了一些简洁的方法来操作或者检查单一字符数据； String：这个类用于处理由多个字符组成的不可变数据； StringBuffer：这个类用于存储和操作由多个字符组成的可变数据； StringBuilder：基本同StringBuffer。 集合类Java集合类框图 Set：无序，唯一； List：有序，不唯一； Map：key→value。 Set(集)定义 Set是最简单的集合，集合中的对象不按照特定的方式排序，并且没有重复地对象； Set接口主要有两个实现类： HashSet； TreeSet。 一般用法1234567891011121314151617181920212223242526//ch07.set.SetDemopackage ch07.set;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class SetDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Set set = new HashSet(); String str = &quot;我是天津大学一名学生&quot;; char[] chars = str.toCharArray(); for (int i = 0; i&lt;chars.length; i++) &#123; set.add(chars[i]); &#125; System.out.println(&quot;不同字符数量： &quot; + set.size()); printSet(set); &#125; public static void printSet(Set set) &#123; // 遍历一个set的方法 Iterator it = set.iterator(); while (it.hasNext()) &#123; System.out.print(it.next()); &#125; &#125;&#125;//ch07.set.SetDemo2 Set集合中存放的是对象，并且没有重复对象； Java中实现Set接口的类很多，例如 1Set set=new HashSet(); 这样就创建了一个集合对象，我们把它当作抽象接口看待； 使用接口的好处在于，实现类将来可以被替换，而程序不用做很多改动。 HashSet类 HashSet类按照哈希算法来存取集合中的对象，具有很好的存取和查找性能； 当向集合中加入一个对象时，HashSet会调用对象的hashCode()方法来获得哈希码，然后根据哈希码进一步计算出对象在集合中的位置。 散列技术的原理 把对象的哈希码直接用一个固定的公式计算，得出存储位置的方法； 优点是：可以快速命中搜索的目标。 HashSet正常工作的前提 两个你认为相同的对象其hashCode()必须相同且两个对象用equals()方法比较的结果为true 1//ch07.set.SetHashCodeEqDemo TreeSet类 TreeSet采用树结构来存储数据，数据打印出来是有序的； 当向集合中加入一个对象时，会把它插入到有序的对象集合中； TreeSet支持两种排序方式： 自然排序； 自定义排序。 默认情况下采用自然排序。 自然排序 要求被排序的对象实现了Comparable接口的compareTo(Object o)方法 1234x.compareTo(y)x==y return 0;x&gt;y return +;x&lt;y return -; 在JDK类库中已经实现Comparable接口的一些类 12345678910111213141516171819202122232425262728//TreeSet的自然排序//ch07.set.TreeSetDemopackage ch07.set;import java.util.HashSet;import java.util.Hashtable;import java.util.Set;import java.util.SortedSet;import java.util.TreeSet;import ch07.Student;import ch07.bak.Dog;public class TreeSetDemo &#123; public TreeSetDemo() &#123; // TODO Auto-generated constructor stub &#125; public static void main (String[] args) &#123; // TODO Auto-generated method stub Set set = new TreeSet(); set.add(0); set.add(5); set.add(2); set.add(01); Object[] ds = set.toArray( ); for (int i = 0; i &lt; ds.length; i++) &#123; System.out.println(ds[i]); &#125; &#125;&#125;//ch07.set.TreeSetDemo2 自定义排序遍历SetMethod11234567Set set=new TreeSet();set.add(new Integer(0));......int sum=0;Integer[] list=(Integer[])set.toArray(new Integer[0]);for(int i=0;i&lt;list.length;i++)&#123; sum=sum+list[i];&#125; Method21234567Set set=new TreeSet();set.add(new Integer(0));......int sum=0;Object[] list=set.toArray();for(int i=0;i&lt;list.length;i++)&#123; sum=sum+(Integer)list[i];&#125; Method31234567Set set=new TreeSet();set.add(new Integer(0));......int sum=0;Iterator it=set.iterator();while(it.hasNext())&#123; sum=sum+(Integer)it.next();&#125; Set用途1234567891011121314151617181920212223//ch07.set.TreeSetUsagepackage ch07.set;import java.util.Iterator;import java.util.Set;import java.util.TreeSet;public class TreeSetUsage &#123; public TreeSetUsage() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; Set set = new TreeSet(); String content = &quot;China will strengthen international cooperation on novel coronavirus epidemic control and continue to provide assistance within its ability to countries affected by the epidemic, Xi Jinping, general secretary of the Communist Party of China Central Committee, said on Wednesday.&quot;; String[] words = content.split(&quot; &quot;); for (int i = 0; i &lt; words.length; i++) &#123; String word = words[i]; set.add(words[i]); &#125; Iterator it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; 保存/统计不重复的对象 判断一个文本有多少不同字符； 判断一个文本有多少不同字符单词、汉字； 判断一个对象是否已经存在了； …… 使用TreeSet还可以快速排序 List(列表)定义 List的主要特征是按照元素以先行方式存储，允许集合中存放重复对象； List接口的主要实现包括： ArrayList； LinkedList。 ArrayList：代表长度可以变化的数组。允许对元素进行快速的随机访问，但是向ArrayList中插入与删除元素速度较慢； LinkedList：双向链表。向LinkedList中插入和删除元素的速度较快，随机访问的速度较慢 1234567//它单独具有以下方法addFirst()addLast()getFirst()getLast()removeFirst()removeLast() 访问List中的元素 List中的对象按照索引位置排序，程序可以按照对象在集合中的索引位置来检索对象。 List特性 保持原来加入时候的顺序； List中可以有重复元素； List本身不带有排序的功能； Collections类是对Java集合类库中的辅助类，它提供操纵集合的各种静态方法 1234567891011121314151617181920212223//对List中对象进行自然排序Collections.sort(List list);//ch07.list.SortListpackage ch07.list;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class SortList &#123; public SortList() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub List list=new ArrayList (); list.add(12); list.add(34); list.add(11); Collections.sort(list); for(int i=0;i&lt;list.size();i++) &#123; System.out.println(list.get(i)); &#125; &#125;&#125; 通途 按顺序存放元素，比数组更方便。 Vector Vector类可以实现动态的对象数组。几乎与ArrayList相同； 由于Vector在各个方面都没有突出的性能，所以现在已经不提倡使用。 Map(映射)定义 Map：集合中的每一个元素包含一对键对象和值对象，集合中没有重复的键对象，值对象可以重复； 向Map集合中加入元素时，必须提供一对键对象和值对象； Map的两个主要实现类： HashMap； TreeMap。 Map最基本的用法，就是提供类似字典的能力； 在Map中检索元素时，只要给出键对象，就会返回值对象。 Map的遍历Method112345678910111213141516171819202122232425262728293031323334353637//通过Set.keySet()返回键的集合来遍历//ch07.map.MapIteratorpackage ch07.map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class MapIterator &#123; public static void main(String[] args) &#123; String str = &quot;China will strengthen international cooperation on novel coronavirus epidemic control and continue to provide assistance within its ability to countries affected by the epidemic, Xi Jinping, general secretary of the Communist Party of China Central Committee, said on Wednesday.&quot;; String freq = getFrequentWord(str); System.out.println(freq); &#125; public static String getFrequentWord(String content) &#123; Map map = new HashMap(); String[] words=content.split(&quot; &quot;); for(int i=0;i&lt;words.length;i++) &#123; String word = words[i]; int count = 0; if (map.containsKey(word)) &#123; count = (Integer) map.get(word); &#125; map.put(word, count + 1); &#125; Iterator it = map.keySet().iterator(); int maxCount = 0; String maxKey = &quot;&quot;; while (it.hasNext()) &#123; String key = (String) it.next(); if ((Integer) map.get(key) &gt; maxCount) &#123; maxKey = key; maxCount = (Integer) map.get(key); &#125; &#125; System.out.println(maxKey+&quot;=&quot;+maxCount); return maxKey; &#125;&#125; Method21234567891011121314151617181920212223242526272829303132333435363738394041//通过Set.entrySet()返回&quot;键值对&quot;的集合来遍历//Map.Entry的对象代表一个&quot;词条&quot;，就是一个键值对//可以从中取值getValue()或键getKey()//ch07.map.MapIterator2package ch07.map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;public class MapIterator2 &#123; public static void main(String[] args) &#123; String str = &quot;China will strengthen international cooperation on novel coronavirus epidemic control and continue to provide assistance within its ability to countries affected by the epidemic, Xi Jinping, general secretary of the Communist Party of China Central Committee, said on Wednesday.&quot;; String freq = getFrequentWord(str); System.out.println(freq); &#125; public static String getFrequentWord(String content) &#123; Map map = new HashMap(); String[] words=content.split(&quot; &quot;); for(int i=0;i&lt;words.length;i++) &#123; String word = words[i]; int count = 0; if (map.containsKey(word)) &#123; count = (Integer) map.get(word); &#125; map.put(word, count + 1); &#125; Iterator it = map.entrySet().iterator(); int maxCount = 0; String maxKey = &quot;&quot;; while (it.hasNext()) &#123; Entry entry=(Entry)it.next(); String key = (String) entry.getKey() ; if ((Integer) entry.getValue() &gt; maxCount) &#123; maxKey = key; maxCount = (Integer) map.get(key); &#125; &#125; System.out.println(maxKey+&quot;=&quot;+maxCount); return maxKey; &#125;&#125; Map两个最重要实现 HashMap按照哈希算法来存取键值对象； TreeMap按照排序规则对keySet进行排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//Map的遍历不保证顺序//但是TreeMap遍历使用Key排序//ch07.map.HashMapTreeMappackage ch07.map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;import java.util.TreeMap;/** * 本例子演示了TreeMap和HashMap区别 */public class HashMapTreeMap &#123; Comparable c; public static void main(String[] args) &#123; testMap(new HashMap()); System.out.println(&quot;=====================&quot;); testMap(new TreeMap()); &#125; public static void testMap(Map map) &#123; map.put(&quot;zhang&quot;, 10); map.put(&quot;li&quot;, 20); map.put(&quot;wan&quot;, 30); map.put(&quot;an&quot;, 40); Iterator it = map.keySet().iterator(); while (it.hasNext()) &#123; Object key = it.next(); Object value = map.get(key); System.out.println(key + &quot; &quot; + value); &#125; &#125;&#125;//Output/*wan 30zhang 10li 20an 40=====================an 40li 20wan 30zhang 10*/ Points JDK API文档可以从far fa-hand-point-right下载，安装后，打开index.html即可； 点击获取Java文档 Java最权威的教材 Iterator 12345678910//不考虑泛型的Iterator定义public interface Iterator&#123; boolean hasNext(); Object next(); void remove();&#125;public interface Collection extends Iterable;public interface Iterable&#123; Iterator iterator();&#125; Collection和Iterator接口 在Collection接口中声明了适用于Java集合(只包括Set和List)的通用方法。因此Set和List对象可以调用以上方法，Map对象不可以； Iterator接口隐藏了底层集合的数据结构，向客户程序提供了遍历各种数据集合的统一接口； 如果集合中的元素没有排序，Iterator遍历集合中元素的顺序也是无序的。 使用Iterator遍历Set/List 123456789101112131415161718192021222324252627282930313233343536//ch07.it.IteratorDemopackage ch07.it;/** * 本例子演示了Iterator的用法 */import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;public class IteratorDemo &#123; public IteratorDemo() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub List list=new ArrayList(); addObject(list); itColleciton(list); Set set=new HashSet(); addObject(set); //留意 itColleciton(set) 和 itColleciton(list) 区别 itColleciton(set); &#125; public static void addObject(Collection collection) &#123; collection.add(&quot;天津&quot;); collection.add(&quot;大学&quot;); &#125; public static void itColleciton(Collection collection) &#123; Iterator it=collection.iterator(); while(it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; 文章源码文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"Java-Part4","slug":"Java-Part4","date":"2021-03-27T12:03:10.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/03/27/Java-Part4/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/27/Java-Part4/","excerpt":"","text":"异常 异常 常见的一些潜在风险 用户不存在？ 用户名口令错误？ 余额不足？ 网络不通？ 磁盘空间不足？ …… 异常处理基本模式Method1 在Java编程语言中，用try和catch语句来处理异常 格式如下 123456//ch06.ExceptionDemotry&#123; //可能发生异常的语句&#125;catch(Exception e)&#123; //发生异常了 执行这里的代码&#125; Method2 与方法1大致相同，增加finally语句 格式如下 12345678910//ch06.ExceptionDemo2try&#123; //可能发生异常的语句 //如果前面发生了异常 就不会执行这里&#125;catch(Exception e)&#123; //发生异常了 执行这里的代码 //如果没有发生异常 不会执行这里&#125;finally&#123; //不管是否发生异常都会执行这里&#125; 注意finally：不管如何(是否发生异常)，都会执行这里的代码。 异常的产生 所有的异常都是通过throw创建出来的 创建方法 12throw new 异常的构造函数()...//例如:throw new Exception(&quot;用户不存在!&quot;); 需要注意的是，不可以随便抛出一个东西 例如如下代码就是错误的 12throw new String(&quot;用户不存在!&quot;);//ch06.ExceptionDemo3 抛出的内容必须是Throwable的子类。 只要是Throwable的子类，都可以使用throw/catch进行操作； 反之，不是Throwable的子类，都不能使用throw/catch进行操作。 可抛出Throwable的几个类型 Error Exception RuntimeException 异常类型Error及其子类 Error类表示Java运行时产生的系统内部错误或资源耗尽等严重错误； 这种错误通常是程序无法控制和解决的，如果发生这种错误，通常的做法是通知用户并中止程序的执行； 这种异常超出了程序员能力范围，没解决办法，建议程序直接退出。编译器检查、必须处理。 1//ch06.ErrorDemo 例：NoClassDefFoundError, OutOfMemoryError, VirtualMachineError, InternalError and so on. Exception及其子类 Exception又称为”可检异常“，”非运行时异常“； 程序能处理的异常； 这种错误的出现完全在程序员意料之中，有对应的解决办法。编译器检查、必须处理。 1//ch06.ExceptionDemo2 例：IOException, SQLException and so on. 此外，还有很多用户自定义的：口令错误、余额不足… RuntimeException及其子类 RuntimeException类及其子类被称为”运行时异常“ 一般发生在JRE内部； 也称”非必检异常“； 如NullPointerException。 RuntimeException类及其子类都成为运行时异常，这种异常的特点是Java编译器不会检查它。也就是说，当程序中可能出现这类异常，即使没有用try-catch语句，出现异常时也会抛出这个错误； RuntimeException表示无法让程序恢复运行的异常，导致这种异常的原因通常是由于执行力错误操作，建议直接显示错误，因此Java编译器不检查这种异常； 也有一种说法认为Exception之所以不检测，是因为不应该替别人背黑锅！ 1//ch06.RuntimeExceptionDemo Example ArithmaticException 12int a=12/0;//Wrong//Exception NullPointerException 123Date d=null;System.out.println(d.toString());//Wrong//RuntimeException ArrayIndexOutOfBoundException 1234int [] array=new int [4];array[0]=1;array[4]=1;//Wrong//RuntimeException ClassCastException 123456class Animal&#123;&#125;class Dog extends Animal&#123;&#125;class Cat extends Animal&#123;&#125;Animal animal=new Dog();Cat cat=(Cat)animal;//Wrong//RuntimeException 创建用户自定义异常类步骤 1//ch06.UserDefineException 创建用户自定义异常时，一般需要完成如下工作 声明一个新的异常类，使之以Exception类或其他某个已经存在的系统异常类或用户异常类为父类； 为新的异常类定义属性和方法，或重载父类的属性和方法，使这些属性和方法能够体现该类所对应的错误的信息。 异常的处理自己处理 12//ch06.ExceptionDemo4//自己处理 自己不处理 继续throw 12//ch06.ExceptionDemo5//等着别人处理 分门类得处理异常 定义多种异常类(Throwable子类)，不同情况下，抛出不同异常类 1//ch06.ExceptionDemo6 Questions 如果抛出了可以捕捉得东西，一定要在方法后面加throws吗？ 有时候需要 如果抛出的是Exception的子类，且非RuntimeException的子类，必须抛出或者捕捉； 有时候不需要 如果抛出的是RuntimeException的子类或者Error的子类，则不需要显式得抛出。 可不可以在不抛出内容的情况下catch？ 有时候不行 ```java//ch06.ExceptionDemo9 1234567- Exception子类且非RuntimeException的子类，必须在抛出的情况下捕捉；- **有时候行**- &#96;&#96;&#96;java &#x2F;&#x2F;ch06.ExceptionDemo10 RuntimeException的子类或者Error的子类，可以在不抛出的情况下捕捉。 catch Exception能捕捉到所有抛出的“东西”吗？ 不能，要写捕捉所有抛出的“东西”，必须catch Throwable ```java//ch06.ExceptionDemo101 12345674. &lt;i&gt;finally中的语句一定被执行吗？&lt;&#x2F;i&gt;- 不一定，finally语句不被执行的唯一情况是程序先执行了终止程序的System.exit()方法- &#96;&#96;&#96;java &#x2F;&#x2F;ch06.ExceptionDemoExit 异常的顺序问题 异常会首先被符合条件的catch捕捉 12345678910try&#123; throw new java.io.IOException(&quot;ie&quot;); //IOException是Exception的子类&#125;catch (IOException ie)&#123; //异常在这里被捕捉了 System.out.println(&quot;IOException&quot;);&#125;catch (Exception e)&#123; //这段就不会执行了 System.out.println(&quot;Exception&quot;);&#125; 如果将上程序中两个catch语句块交换，则会导致编译错误，为什么？ 12345678910try&#123; throw new java.io.IOException(&quot;ie&quot;);&#125;catch(Exception e)&#123; System.out.println(&quot;Exception&quot;);&#125;catch(IOException ie)&#123; //永远接收不到exception System.out.println(&quot;IOException&quot;);&#125; 上面这段代码就会出现编译报错，原因是下面的catch永远不会接收到异常，这是由于Exception是最大的异常类，所有的异常都属于Exception类，所以第一个catch就会优先接收到所有满足条件的异常，即使是IOException的异常，由于IOException也是Exception的一个子类，因此也会再第一个catch处被捕获，而第二个catch也就永远不会有作用了。因此我们必须是按照从小范围到大范围的顺序对catch语句进行排列。 返回问题，下面函数为什么会报错 1234567891011121314//ch06.ExceptionDemo20.java//buypublic int buy(String username, int amount) throws Exception &#123; try &#123; int orgBalance = this.getBalance(username); if (orgBalance &lt; amount) &#123; throw new BalanceException(&quot;余额不足！&quot;); &#125; return orgBalance - amount; &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); // 这里没有返回值，也就意味着如果发生异常，函数就没用返回，所以会报错。 &#125;&#125; 初始化问题，下面函数为什么报错 1234567891011121314//ch06.ExceptionDemo20.java//buy2public void buy2(String username, int amount) throws Exception &#123; int orgBalance; try &#123; orgBalance = this.getBalance(username); if (orgBalance &lt; amount) &#123; throw new BalanceException(&quot;余额不足！&quot;); &#125; &#125; catch (Exception e) &#123; System.out.println(&quot;余额不足:&quot; + orgBalance); // 系统编译的时候认为try里面代码完全有可能一行都不被执行，所以必须要在try前面给变量赋值 &#125;&#125; 初始化问题，下面函数为什么报错 12345678910111213141516171819//ch06.ExceptionDemo20.java//readFromFilepublic void readFromFile(String fileName) &#123; InputStream in; // 正确的写法是InputStream in=null; try &#123; in = new FileInputStream(fileName); // ....以后还有代码，此处省略 &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; if (in != null) &#123; // in没有初始化 in.close(); // in close的时候可能再次发生异常 &#125; &#125;&#125; Exception引发的override问题 1//ch06.ExceptionSon 一个方法必须通过throws语句在方法的声明部分说明它可能抛出而并未捕获的所有的“必检异常”，如果没有这么做，将不能通过编译； 如果在子类中覆盖了父类的某一方法，那么该子类方法不可以比被其覆盖的父类方法抛出更多的异常(但可以更少)。 异常到底应该捕捉还是抛出？ 捕获并处理那些你知道并且应该负责处理的异常； 对那些你不知道方法的调用者会如何处理的的异常，最好将它们留给方法的调用者进行处理。 异常的优点与用途优点 极大的降低了程序调试难度，使得错误定位准确； 强制让用户在编译阶段发现一些未解决的问题，提高程序健壮性。 用途异常的最大用途——查看错误堆栈 1234567891011//ch06.ExceptionDemo31public static void main(String[] args) &#123; try &#123; new ExceptionDemo31(); &#125;catch(Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125;&#125;//编译结果java.lang.ArrayIndexOutOfBoundsException:10 at ch06.ExceptionDemo31.main(Exception31.java:14) Points try中代码是有可能一行都不执行的； 处理异常的过程中，可能再次发生异常； Exception包含在java.lang包中，所以使用Exception不需要import； 可以在不存在潜在风险的情况下throws； 不可以在不存在潜在风险的情况下catch； override的时候要考虑Exception； return的时候要考虑Exception； 异常的常见处理方法 123456789//ch06.ExceptionDemo31public static void main(String[] args) &#123; try &#123; new ExceptionDemo31(); &#125;catch(Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125;&#125; throw与throws用处的区别 12345678910111213141516//ch06.ThrowsDemopublic class ThrowsDemo &#123; public ThrowsDemo() &#123; // TODO Auto-generated constructor stub &#125; public void method() throws SQLException, IOException &#123; if(1&gt;2) &#123; throw new IOException(&quot;IOException&quot;); &#125; if(2&gt;3) &#123; throw new SQLException(&quot;SQLException&quot;); &#125; &#125;&#125; throws：跟在方法声明后面，后面跟着的是异常类名； throw：用在方法体内，后面跟着的是异常类对象名。 文章源码文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"解决Github官网打不开的问题","slug":"STFIOG","date":"2021-03-22T02:59:11.000Z","updated":"2021-04-11T04:26:34.100Z","comments":false,"path":"2021/03/22/STFIOG/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/22/STFIOG/","excerpt":"","text":"Method 1","categories":[{"name":"Solution","slug":"Solution","permalink":"https://cheeseburgerim.github.io/categories/Solution/"}],"tags":[{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"Git","slug":"Git","permalink":"https://cheeseburgerim.github.io/tags/Git/"},{"name":"Solution","slug":"Solution","permalink":"https://cheeseburgerim.github.io/tags/Solution/"},{"name":"Github","slug":"Github","permalink":"https://cheeseburgerim.github.io/tags/Github/"}]},{"title":"数字逻辑与数字系统-Part3","slug":"MLAMS-Part3","date":"2021-03-19T12:35:02.000Z","updated":"2021-04-11T04:26:34.100Z","comments":false,"path":"2021/03/19/MLAMS-Part3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/19/MLAMS-Part3/","excerpt":"","text":"Chapter3 SystemVerilog硬件描述语言基础基于SystemVerilog的数字逻辑电路建模方法基于SystemVerilog的测试程序常见组合逻辑电路模块的设计逻辑阵列","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"Java-Part3","slug":"Java-Part3","date":"2021-03-15T03:31:53.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/03/15/Java-Part3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/15/Java-Part3/","excerpt":"","text":"深入理解JAVA语言 变量及其传递Java数据类型划分 Java中的数据类型分为两大类，一类是基本数据类型； 另一类是引用类型，后者相当于对象。 Java数据类型划分在Java-Part1中有详细介绍 注意：只有类、接口和数组是引用数据类型！ 从JDK1.4以后，引用、对象类型和原始类型基本通用。 类型 引用、对象类型 原始数据类型 整数 Integer int 单精度 Float float 双精度 Double double 布尔 Boolean boolean 字符 Character char 字节 Byte byte 1234567891011121314151617181920212223242526272829303132333435363738//ch05.ref_val.ObjectAndPrimitivepackage ch05.ref_val;public class ObjectAndPrimitive &#123; public ObjectAndPrimitive() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Integer i1 = new Integer(0); int i2 = i1; String s=&quot;abc&quot;; Object o=s; ((String)o).length(); test(i1); // Integer可以用的地方，int也可以 test(678); // 但是Integer的方法，int是不能直接用的 i1.hashCode(); // 下面这个是不可以的 ((Integer) i2).hashCode(); Boolean b1 = Boolean.FALSE; boolean b2 = b1; &#125; public static void test(Integer i) &#123; &#125; &#125; 基本类型变量与引用型变量 基本类型：其值直接存于变量中； 引用型的变量除占据一定的内存空间外，它所引用的对象实体(由new创建)也要占据一定空间； 引用型变量保存的实际上是对象在内存的地址，也称为对象的句柄； ch05.ref_val.MyDate体会m/n什么时候一起改变，什么时候不一起改变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//ch05.ref_val.MyDatepackage ch05.ref_val;/** * 本例子演示了两个对象指向的是同一个地址，而不是简单的值的复制 * * @author Administrator * */public class MyDate &#123; private int day = 12; private int month = 6; private int year = 1900; public MyDate(int y, int m, int d) &#123; year = y; month = m; day = d; &#125; void addYear() &#123; year++; &#125; @Override public Object clone() &#123; // TODO Auto-generated method stub return new MyDate(this.year, this.month, this.day); &#125; public void display() &#123; System.out.println(year + &quot;-&quot; + month + &quot;-&quot; + day); &#125; public static void main(String[] args) &#123; // MyDate m, n; // m = new MyDate(2020, 3, 2);// m指向了一个对象 // // n = (MyDate)m.clone();// n和m指向了同一个对象 // n=m; // n.addYear();// m n同时改变 // m.display(); // n.display();// m n都变成了2021 // n = new MyDate(2019, 3, 2);// n指向了一个新对象 // m.display(); // n.display();// m n 具有不同的值 MyDate m = new MyDate(2020, 3, 6); modifyDate(m); m.display(); &#125; public static void modifyDate(MyDate m) &#123; m=new MyDate(2020, 3, 6); m.addYear(); &#125;&#125; 调用对象方法时，要传递参数。在传递参数时，Java是值传递，即在调用一个方法时，是将表达式的值复制给形式参数； 对于引用型变量，传递的值是引用值(可以理解为内存地址)； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//ch05.ref_val.TransByValue.javapackage ch05.ref_val;/** * 本例子演示了什么样的情况下传递的是地址，什么情况下是值的复制 * * @author Administrator * */public class TransByValue &#123; private static int a; public static void main(String[] args) &#123; int a = 0; modify( a); // System.out.println(a);// 输出0 int[] b = new int[1]; modify(b); System.out.println(b[0]); &#125; /** * 值的复制 * * @param a */ public static void modify(int a) &#123; // 原始类型 传递值 // a++; a = a + 1; &#125; /** * 传递的是地址 * * @param b */ public static void modify(int[] c) &#123; // 对象类型 传递地址 c[0]++; c = new int[5]; &#125; &#125; Java中的参数都是按值传递的，但对于引用型变量，传递的值是引用值，所以方法中对数据的操作可以改变对象的属性； 但是不能简单地认为函数如果传递的参数是一个对象，就可以在函数内部修改这个参数，例如：ch05.ref_val.TestValue 1234567891011121314151617181920212223242526272829303132333435363738394041//ch05.ref_val.TestValuepackage ch05.ref_val;/** * 函数中如果传递的是对象，未必一定可以在函数内部修改这个参数 * @author Administrator * */public class TestValue &#123; public TestValue() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; String str=&quot;a&quot;; modify(str); System.out.println(str); StringBuffer buf=new StringBuffer(&quot;a&quot;); modify(buf); System.out.println(buf.toString()); &#125; /** * s能被修改么？ * @param s */ public static void modify(String s) &#123; s=s+&quot;1&quot;; &#125; /** * buf能被修改么 * @param buf */ public static void modify(StringBuffer buf) &#123; buf.append(&quot;1&quot;); &#125;&#125; 实例变量与局部变量 从语法角度看 实例变量属于类或接口，public,private,static,final修饰； 而局部变量是在方法中定义的变量或方法的参变量； 都可用final修饰，但局部变量则不能够被访问控制符及static修饰。 从存储角度看 从变量在内存中的存储方式来看，实例变量是对象的一部分，而对象是存在于堆中的，局部变量是存在于栈中； 实例变量的生命周期与局部变量的声明周期不同，通常前者较长； 另外，实例变量可以自动赋初值，局部变量则须显式赋值。局部变量必须显式赋值后才能够使用。 文章源码文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"数字逻辑与数字系统-Part2","slug":"MLAMS-Part2","date":"2021-03-13T12:43:15.000Z","updated":"2021-04-11T04:26:34.100Z","comments":false,"path":"2021/03/13/MLAMS-Part2/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/13/MLAMS-Part2/","excerpt":"","text":"Chapter2 组合逻辑设计 Introduction数字逻辑电路 数字逻辑电路(logic circuit)是一个可以处理离散值变量的网络； 其中包括： 一个或多个离散值输入端； 一个或多个离散值输出端； 描述输入和输出关系的功能规范； 描述当输入改变时输出响应延迟的时序规范。 结点(node)和模块(element) 电路由节点和模块组成； 结点是一段导线，通过电压传递离散值变量； 输入结点：接收外部的值(图中的A,B,C)； 输出结点：输出值到外部(图中的Y,Z)； 内部结点：不属于以上两者的结点(图中的n1)。 模块本身是一个带有输入、输出、功能规范和时序规范的电路； 每一个模块本身都是一个电路； 图中的E1,E2,E3。 数字逻辑电路的分类 组合逻辑电路(combinational logic) 任一时刻的输出仅由该时刻的输入信号决定； 无记忆的，与电路状态无关。 时序逻辑电路(sequential logic) 任一时刻的输出由该时刻的输入和电路该时刻的状态共同决定； 有记忆的，与电路状态有关。 组合逻辑电路 每个电路模块都是一个组合逻辑电路； 每个电路结点： 或者是电路的输入； 或者是只连接电路模块的一个输出端。 电路中不包含回路。 判断下列哪写电路是组合逻辑电路 √； ×，有回路； √； ×，连接了两个模块的输出端； √； ×，有回路。 布尔代数基本概念布尔代数的定义 布尔代数中的变量取值只能为**“真”(True)或“假”(False)**； “1”表示真，“0”表示假； 三种基本逻辑运算： “与”，运算符“·”，例：A·B或AB； “或”，运算符“+”，例：A+B； “非”，运算符“上划线”，例：A。 基本概念 变量：可以使用A、B、C…或a、b、c…来表示，取值只能为0或1； 反变量(变量的非，Complement)：变量上面有一条横线 A，B，C； 项(Literal)：变量或它的反变量 A，A，B，B，C，C； 布尔表达式 适用于描述组合逻辑电路中输入与输出间的功能规范； 例如： S=F(A,B,Cin)； Cout=F(A,B,Cin)。 公理和定理布尔代数的公理 对偶规则 对偶(Duality) 设F为任意逻辑表达式，若将F中所有运算符和常量做如下变换 例如：F=AB+CD→F‘=(A+B)(C+D) 则所得新的表达式F’为F的对偶式。 对偶是相互的，F和F’互为对偶式； 对偶规则：两个逻辑表达式F和G相等，则对偶式F’和G’也相等。 单变量定理 多变量定理 德·摩根定律 最小项和最大项基本概念 蕴含项(Implicant)：项的乘积 ABC，AC，BC； 最小项(Miniterm)：包含全部输入变量的乘积项 ABC，ABC，ABC； 最大项(Maxterm)：包含全部输入变量的求和项(Sum) (A+B+C)，(A+B+C)，(A+B+C)。 最小项 最小项是一种特殊的乘积项(“与”项)； 最小项特点： n个变量逻辑函数的每个最小项，一定是包含n个因子的乘积项； 在各个最小项中，每个变量必须以原来变量或反变量形式作为因子出现一次，而且仅出现一次； 最小项的编号 最小项用mi表示 m表示最小项； 下标i为使该最小项为1的变量取值所对应的等效十进制数。 三变量最小项编号表 三变量最小项真值表 从表中可以看出，每个最小项只有一组变量取值能使其值为1，而其他各组取值该最小项皆为0。由这种“与”函数真值表中1的个数最少，而得名“最小项”。 最小项的性质 变量任取一组值，仅有一个最小项为1，其他最小项为0； n变量的全体最小项(共有2n个)之和恒为1； n个变量任意两个不同的最小项相与，结果恒为0； 两最小项相邻，相邻最小项相”或”，可以合并成一项，并可以消去一个变量因子 相邻：两最小项如果仅有一个变量因子不同，其他变量均相同，则称这两个最小项相邻 例：ABC+ABC=AB； 任一n变量的最小项，必定和其他n个不同最小项相邻(每一变量取反都是相邻项) 例：ABC与ABC、ABC、ABC相邻。 最大项 最大项是一种特殊的和项(“或”项)； 最大项特点 n个变量构成的每个最大项，一定是包含n个因子的”或”项； 在各个最大项中，每个变量必须以原变量或反变量形式作为因子出现一次，而且仅出现一次。 最大项编号 最大项用Mi表示 M表示最大项； 下标i为使该最大项为0的变量取值所对应的等效十进制数。 三变量最大项编号表 三变量最大项真值表 每个最大项只有对应的一组变量取值能使其值为0，正因为这种“或”函数真值表中1的个数最多，所以取名“最大项”。 最大项的性质 变量任取一组值，仅有一个最大项为0，其他最大项为1； n变量的全体最大项之积为0； 不同的最大项相或，结果为1； 两相邻的最大项相“与”，可以合并成一项(等于相同因子之和)，并可消去一个变量因子 相邻：两最大项如果仅有一个变量因子不同，其他变量均相同，则称这两个最大项相邻； 任一n变量的最大项，必定和其他n个不同的最大项相邻。 最小项和最大项的关系 编号下标相同的最小项和最大项互为反函数 标准与或式和标准或与式标准或与式(sum-of-products) 由最小项之和构成的逻辑表达式； 每个最小项都对应真值表中值为1的一行； 标准与或式是最小项之间的或运算； 标准与或式与真值表间一一对应； 因此，从标准与或式中可以直接判断哪些变量取值可以使表达式为1。 标准与或式具有唯一性 任一逻辑函数都可以表达为最小项之和的形式，而且是唯一的 标准或与式(product-of-sums) 最大项之积构成的逻辑表达式； 任一逻辑函数都可以表达为最大项之积的形式、而且是唯一的。 标准与或式和标准或与式的关系 布尔表达式与真值表的转换布尔表达式→真值表 三种方法 将变量的组合所有取值组合一一带入表达式进行计算得到； 将表达式转化为标准与或式 根据函数式的逻辑含义直接填表 方法三所得到的真值表 通过上述方法所得到的真值表 真值表→布尔表达式 根据最小项的性质，直接从真值表写出标准与或式 根据最大项的性质，直接写出标准或与式 例子 使用定理化简表达式 例1 例2 从逻辑到门由布尔表达式绘制原理图 与或式可以使用两级门电路来实现 第一级：与门； 第二级：或门。 例 电路原理图绘制原则 原理图需要遵循一致的风格，以易于阅读和检查错误； 绘制原则如下： 输入在原理图的左边(或顶部)； 输出在原理图的右边(或底部)； 门电路流应从左至右(或从上至下)； 尽量使用直线连接； T型接头表示两条线有连接； 两条线交叉的地方有一个点，表示有连接； 两条线交叉的地方没有点，表示没有连接。 实例 多输出电路 构造一个“优先级电路” 在所有输入为真的信号中，选择其中最重要的信号所对应的输出为1； 其余输出为0。 实例 优先级电路的实现 以上多输出电路实例为例 多级组合逻辑减少硬件减少硬件的目的 扇入(fan-in)：单个逻辑门能够接受的数字信号的最大输入数。 所有的逻辑表达式都可以转化为与或式； 理论上，与或式可以使用两级门电路来实现(先与后或)； 使用二级逻辑可能带来更高的成本； 在工程上，门电路的扇入数不可能无限制的增加 受工艺、成本等方面的制约。 采用多级逻辑 可以减少门电路的数量； 可以减少扇入数。 3输入异或门的实现 使用更少的门电路 推气泡推气泡 CMOS电路中经尝使用与非门和或非门； 不易直接根据电路推导出表达式； 推气泡可以帮助我们重画电路，更容易确定逻辑功能； 向后推 电路符号变化； 将气泡加在输入端； 向前推 电路符号变化； 将气泡加在输出端； 写出电路的逻辑表达式 Y=AB+CD 推气泡的方法 从输出端向输入端推； 将气泡从电路最后的输出端开始推； 如果当前门有一个输入气泡、则消除该气泡，并在其上一级门的输出加上气泡。 推气泡的例子 X和Z非法值(illegal)：X 竞争(Contention)：电路结点同时被0和1驱动 电压值可能介于0~VDD之间； 可能是0，可能是1，也可能处于禁止区域内； 导致电路的功耗变大，电路发热，并导致损坏。 注意：竞争通常是由于电路设计缺陷引起的。 无关项(Don’t Care)：X 在优先级电路中： 如果A3输入为TRUE，则输出不用考虑其他的输入量。 用符号X表示不需要考虑的输入。 浮空值(floating)：Z 浮空也称为悬空、高阻态(High impedance)、高Z态、开路、断路； 浮空不等于逻辑0 使用电压并不能判断哪个电路结点处于浮空状态； 测量断路节点的电压和接地点的电压，在电压表上读数都为0。 当电路的输入结点浮空时，输出不确定 可能为0，可能为1，也可能为某个中间电压(处于禁止区)。 产生浮空结点常见的原因是忘记将电压连接到输入端； 但浮空结点并不意味着电路一定出错。 三态缓冲器(tristate buffer) 浮空可以用来防止结点处于竞争状态； 当一个结点同时连接n个输出时，若其中n-1个输出处于浮空状态，则当前结点的值等于驱动正常电平输出端的值； 三态缓冲器 有三种可能输出状态； 高电平、低电平和浮空； 输入端A，输出端Y，使能端E。 三态缓冲器的应用 在连接多个芯片的总线上使用 许多不同的设备同时连接在一总线上； 在某一个时刻只允许一个芯片的使能信号有效，并向总线输出数据； 其他芯片的输出必须浮空，以防止总线竞争； 任何芯片在任何时刻都可以通过总线读取信息。 卡诺图使用卡诺图化简布尔表达式卡诺图的构成三变量卡诺图二变量、四变量卡诺图五变量卡诺图用卡诺图表示逻辑函数卡诺图上合并最小项的规则实例合并规则总结用卡诺图化简逻辑函数组合逻辑电路设计方法设计思路 对实际逻辑问题进行抽象，定义输入和输出逻辑变量； 由实际逻辑问题列出真值表； 由真值表写出表达式； 化简表达式； 画出原理图。 7段数码管驱动电路 4位输入数据，输入一个十进制数字(4位二进制数可以表示一位十进制数)； 7位输出控制发光管显示数字0~9。 7段数码管的两种连接方法 7段数码管逻辑电路设计思路 对实际问题进行抽象，定义输入和输出逻辑变量 由实际逻辑问题列出真值表 由真值表写出表达式 化简表达式 画出原理图 考虑无关项 组合逻辑模块编码器 用n位二进制代码对N=2n个特定信息进行编码的逻辑电路 例：设计一个具有4路信号输入的优先级编码器 输入：X0、X1、X2、X3(高电平为有效信号)； 输出：A1、A0、EO(用于判定是否存在有效输入)； 功能：将4个输入信号进行二进制编码(4线-2线编码器)。 带输出使能的优先级编码器 优先级编码：当有多个信号同时输入时，只对优先权高的一个信号进行编码； 输出使能端：用于判别电路是否有信号输入。 设计逻辑电路 译码器 译码是编码的逆过程，有n个输入，2n个输出； 每一种输入的组合对应使能某个特定的输出信号； 输出的独热(one-hot，互斥)的，同一时刻只能输出一个有效信号。 与上述4线-2线译码器(高电平为有效信号)相对应，以下为2线-4线译码器(高电平为有效信号) 译码器电路的实现 使用译码器实现复杂逻辑 译码器每个输出都对应一个最小项； 使用译码器+或门可以构造出更加复杂的表达式。 多路选择器定义 根据选择信号的值从N个可能的输入中选择一个作为输出； 需要使用log2N位选择信号作为输入，控制输入信号的选择。 实现 更多输入的多路选择器 使用多路选择器实现复杂逻辑 组合逻辑中的时序问题传播延迟和最小延迟 在实际电路中，输入影响输出的改变需要一定时间； 电路设计中最具有挑战性的问题是时序 定义 传播延迟(propagation delay)：tpd 输入改变直到一个或多个输出改变为最终值所经历的最长时间延迟； 最小延迟(contamination delay)：tcd 输入发生变化直到任何一个输出开始改变的最短时间。 产生原因 产生延迟的原因包括： 电路中的电阻和电容的充放电； 光速的上限。 tpd和tcd的值可能不同 上升沿与下降沿的延迟可能不同； 电路存在多个输入和输出时，不同输出的延迟可能不同； 电路对温度敏感，电路较热时速度会变慢。 关键路径与最短路径 毛刺毛刺的产生 一个输入改变引起输出的多次变化； 也成为“冒险”(hazard)； 例：观察A=0，C=1时，B由1变0的瞬间发生了什么？ 上毛刺产生的分析 消除毛刺 当信号的变化在卡诺图中穿越2个主蕴含项的边缘时会出现毛刺； 通过在卡诺图中增加多余的蕴含项来盖住这些边缘以避免毛刺； 多个输入(几乎)同时变化也会产生毛刺； 这些不能通过增加硬件来避免。 毛刺在大多数电路中都存在。","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"Java-Part2","slug":"Java-Part2","date":"2021-03-11T08:36:32.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/03/11/Java-Part2/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/11/Java-Part2/","excerpt":"","text":"类、包和接口 本文章一些等价的名词 类 / class； 实例 / 对象：类的一个具体化； 方法 / 函数：在Java种等价； 实例变量 / 成员变量 / 实例属性 / 成员属性 / 域； static变量 / 类变量 / 静态变量； override 覆盖； overload 重载； 父类 / 超类 / superclass。 类、成员变量、方法 / 函数类 类是组成Java程序的基本要素。它封装了一类对象的状态和方法，是这一类对象的原型； 一个类的例子：ch04.Person 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//ch04.Personpackage ch04;public class Person extends Object&#123; /* 实例变量又叫域变量，成员变量访问修饰符可以是private/protected/public或者干脆没有，但是没有friend; 实例变量不能重名，例如有一个变量是name，不能再有另外一个name; 实例变量如果没有赋值，会有默认值。字符串为null，整数为0... */ private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; /* 构造函数同样也可以有修饰符。构造函数必须和类名字同名，且不能有类型，也不能有返回值; 构造函数可以有多个。 */ public Person(String n, int a) &#123; name = n; age = a; &#125; /* 实例方法又叫成员方法、对象方法。同样可以有修饰符; 方法和构造函数最大的区别在于必须要有返回类型(如果什么都不返回则返回void)。 */ public void sayHello() &#123; //局部变量 String content=null; content = &quot;Hello! My name is &quot; + name + &quot;!&quot;; System.out.println(content); &#125; public void eat() &#123; System.out.println(&quot;eating!&quot;); &#125; public static void main(String[] args) &#123; //类的使用 //Person是一个类，person是类的一个实例 Person person = new Person(&quot;tom&quot;, 20); //注意调用方式 person.sayHello(); //下面这种方法是错误的 //Person.syHellow(); //也可以这样使用 person = new Person(&quot;abc&quot;, 30); Person p; p = new Person(&quot;li&quot;, 19); //和C++不同，使用完以后，不需要释放内存 //不同于C++，对象new完后不需要释放，系统会自动释放 &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; &#125; 部分笔记在上述代码中！ 构造函数 必须和类同名且定义在类中； 不能有任何返回值，void也不行。 12345678public class Dog&#123; public Dog()&#123;...&#125;;//Correct public Dog(String name)&#123;...&#125;;//Correct ... public void Dog()&#123;...&#125;;//Wrong void public createDog()&#123;...&#125;;//Wrong name&#125;public Dog()&#123;...&#125;;//Wrong outside 类的封装 应该尽量只能通过对象变量来访问这个对象的变量或方法，不通过引用变量就无法访问其中的变量或方法。对于访问者而言，这个对象是封装成一个整体的，这正体现了面向对象的程序设计的“封装性”。 重载 多个方法可以享有相同的名字； 这些方法的参数必须不同，或者是参数个数不同，或者是参数类型不同； 不能仅仅返回值类型不同。 1234567891011121314151617181920212223242526272829303132333435363738394041//ch04.Dogpackage ch04;public class Dog &#123; private String name; private int weight; public Dog(String name, int weight) &#123; this.name = name; this.weight = weight; &#125; //构造函数 //构造函数的重载 public Dog( int weight,String name) &#123; this(name,weight); //this.name = name; //this.weight = weight; //this.name表示对象的属性，name表示函数送入的参数。 &#125; //构造函数的重载 public Dog(int weight) &#123; this(&quot;noname&quot;,weight); &#125; //重载的例子 //两个speak一个有参数，一个没有参数 public void speak() &#123; System.out.println(&quot;wang wang!&quot;); &#125; //重载的例子 //两个speak一个有参数，一个没有参数 public void speak(String content) &#123; System.out.println(content); &#125; public static void main(String[] args) &#123; Dog dog=new Dog( 0 ); //错误，this不能用在static方法中 //用上语句会调用构造函数，其中包含 //this.name=&quot;noname&quot;; &#125;&#125; 如下方法每两个构成一对重载 123456789public void f1();public void f1(String p1);//public void f1(String f1,int f2);public void f1(int f2,String p1);//public void f1(String f1);private void f1(int f1);//修饰符可以不相同 如下方法每两个不构成一对重载 123456789101112public void f1();public int f1();//public void f1(String name,String address);public void f1(String address,String name);//public void f1(String f1);public void f2(String f1);//public void f1(String f1);private void f1(String f1);//不能仅用不同的访问控制来重载 this的用途1 使用this解决局部变量与实例同名的问题； this的上述用途1不能用在static方法中。 this的用途2 在一个构造函数里面调用另外一个构造函数； 可尽量减少代码的重复，便于修改。 类的继承类的继承格式1234class 父类 &#123;&#125;class 子类 extends 父类 &#123;&#125; 继承(inheritance)是面向对象的程序设计中最为重要的特征之一； 由继承而得到的类为子类(subclass)，被继承的类为父类或超类(superclass)，父类包括所有直接或间接被继承的类； 一个类只能有一个直接父类； 子类继承父类的状态和行为，同时也可以修改父类的状态或重载父类的行为，并添加新的状态和行为； 采用继承的机制来组织、设计系统中的类，可以提高程序的抽象程度，使之更接近与人类的思维方式，同时也通过继承能较好地实现代码重用，可以提高程序开发效率，降低维护的工作量。 1234567891011121314151617181920212223242526272829303132333435363738394041//ch04.Studentpackage ch04;public class Student extends Person &#123; private String school; @Override public void sayHello() &#123; //如何在子类中调用父类地方法 super.sayHello(); System.out.println(&quot;My school is &quot; + school); &#125; public void study() &#123; System.out.println(&quot;I am studying! &quot;); &#125; public Student(String name, int age, String school) &#123; //如何在子类中调用父类的构造函数 super(name, age); this.school = school; &#125; public static void main(String[] arggs) &#123; Person p = new Person(&quot;Liming&quot;, 50); p.sayHello(); Student student = new Student(&quot;Wangqiang&quot;, 20, &quot;PKU&quot;); student.sayHello(); student.eat(); String str=&quot;3&quot;; str=str+student; System.out.println(str); &#125; @Override public String toString() &#123; return &quot;Student [school=&quot; + school + &quot;, toString()=&quot; + super.toString() + &quot;]&quot;; &#125;&#125; Java中的继承 Java中的继承是通过extends关键字来实现的； 1class SubClass extends SuperClass&#123;...&#125; 如果没有extends语句，则该类默认为java.lang.Objext的子类； Java中所有的类都是通过直接或间接地继承java.lang.Object得到的。 方法地继承、覆盖与增加 方法地继承 父类地非私有方法也可以被子类自动继承。如Student自动继承Person的方法eat()； 方法的覆盖(Overriding) 子类也可以重新定义与父类同名同参数的方法，实现对父类方法的覆盖，如sayHello()； 实例方法和变量的增加 子类可以增加新方法，如study()。 包(Package) Java提供包来管理类名空间。包实际上提供了一种命名机制和可见性限制机制； 包是一种松散的类的集合，一般不要求处于同一个包中的类有明确的相互关系，如包含、继承等。但是由于同一包中的类在默认情况下可以相互访问，所以为了方便编程和管理，通常把需要在一起工作的类放在一个包里。 Package语句 ```javapackage pkg1[.pkg2[.pkg3…]]; 12345678910111213141516171819202122232425- 包及子包的定义，实际上是为了解决名字空间、名字冲突，它与类的继承没有关系。事实上，一个子类与其父类可以位于不同的包中；- Java的JDK提供的包包括：java.applet, java.awt, java.awt.image, java.awt.peer, java.io, java.lang, java.net, java.util, javax.swing等；- 包层次的根目录是由环境变量CLASSPATH来确定的；- 在简单情况下，Java源文件默认为package语句，这时称为无名包(unamed package)。无名包不能有子包。### Package命名规则&gt; 为了保证包的唯一性，包名一般是域名逆序&gt;&gt; 例如：http:&#x2F;&#x2F;cic.tju.edu.cn&#x2F;&gt;&gt; 则包名：cn.edu.tju.cic.2018.Zhangsan...### import语句- 为了能使用java中已提供的类，需要用import语句来引入所需要的类。import类似C语言中的include；- import语句的格式为： &#96;&#96;&#96;java import package1[.package2[.package3...]].(classname |*); 其中，package1[.package2[.package3…]]表明包的层次，与package语句相同，它对应于文件目录，classname则指明要引入的类，如果要从一个包中引入多个类，则可以用星号(*)来代替。例如： 12import java.awt.*;import java.util.Date; Java编译器为所有程序自动引入包java.lang，因此不必用import语句引入它包含的所有的类，但是若需要使用其他包中的类，必须用import语句引入； 注意：使用星号(*)只能表示本层次的所有类，不包括子层次下的类； 例如，经常需要用两条import语句来引入两个层次的类： 12import java.awt.*;import java.awt.event.*; Java中的访问控制符 同一个类中 同一个包中 不同包中的子类 不同包中的非子类 private Yes 默认 Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes 类的访问控制符类、方法、变量前面可以加访问控制符，例如： 12345public class man()...private String name;protected String address;String email;//不写访问修饰符也是一种修饰符public static void main(String[],args)... setter与getter在Java编程中，有一种常见的做法，是将所有的或部分的域用private修饰，从而更好地将信息进行封装和隐藏。用setXXXX和getXXXX方法对类的属性进行存取，分别成为setter与getter。这种方法有以下优点： 属性用private更好的封装和隐藏，外部类不能随意存取和修改； 提供方法来存取对象的属性，在方法中可以对给定的参数的合法性进行检验； 方法可以完成其他必要的工作(如清理资源、设定状态等等)； 只提供getXXXX方法，而不提供setXXXX方法，可以保证属性是只读的。 Eclipse中可自动生成setter&amp;getter 修饰符static、final和abstractstatic static变量，又叫静态变量/类变量，归属于整个类，而不属于某个类的实例； static方法：又叫静态方法/类方法，归属于整个类，而不属于某个类的实例； 访问static变量/方法可以通过类名.变量名/方法名来访问； 访问实例变量/方法要通过实例名.变量/方法名来访问； static方法中，只能访问static变量/方法，不能访问实例变量/方法； 实例方法中，既能访问static变量/方法，又能访问实例变量/方法。 1234567891011121314151617181920212223242526272829303132//ch04.Countpackage ch04;public class Count &#123; public int myCount; public static int totalCount; public int getMyCount() &#123; return myCount; &#125; public void setMyCount(int myCount) &#123; this.myCount = myCount; &#125; public static int getTotalCount() &#123; return totalCount; &#125; public static void setTotalCount(int totalCount) &#123; Count.totalCount = totalCount; &#125; public static void main(String args[]) &#123; Count count = new Count(); count.setMyCount(1); Count.setTotalCount(1); System.out.println(&quot;count.myCount=&quot; + count.getMyCount()); System.out.println(&quot;count.count=&quot; + Count.getTotalCount()); Count count2 = new Count(); count2.setMyCount(2); Count.setTotalCount(2); System.out.println(&quot;count1.myCount=&quot; + count.getMyCount()); System.out.println(&quot;count2.myCount=&quot; + count2.getMyCount()); System.out.println(&quot;count1.count=&quot; + Count.getTotalCount()); &#125;&#125; final final类：如果一个类被final修饰符所修饰和限定，说明这个类不能被继承，即不可能有子类； final方法：final修饰符所修饰的方法，是不能被子类所覆盖的方法； final变量：可以近似理解成不能被修改值的变量； 一个实例变量被static final两个修饰符所限定时，它实际的含义就是常量，如Integer.MAX_VALUE(表示最大整数)、Math.PI(表示圆周率)就是这种常量。在程序中，通常用static与final一起使用来指定一个常量； 在定义static final时，要么在定义的时候赋值，要么在类初始化的时候static{…}赋值； 在定义final实例变量时，要么在定义变量时赋初始值，要么在构造函数中赋值。 12345678910111213141516171819202122232425//ch04.TestFinalpackage ch04;public final class TestFinal &#123; private static final int totalNumber=0; private static final int totalId; static &#123; totalId=0; System.out.println(&quot;class init!&quot;); &#125; private final int myNumber=0; private final int myId; public TestFinal()&#123; System.out.println(&quot;instance init!&quot;); myId=1; &#125; public TestFinal(int id)&#123; System.out.println(&quot;instance init!&quot;); myId=id; &#125; public void setMyId() &#123; &#125; public static void main(String[] args) &#123; new TestFinal(); &#125;&#125; abstract 凡是用abstract修饰符修饰的类都被称为抽象类； 抽象类不能被实例化 被abstract所修饰的方法叫抽象方法，抽象方法的作用在为所有子类定义一个统一的接口。对抽象方法只需声明，而不需实现，即用分号(;)而不是用{}，格式如下： 1abstract returnType abstractMethod([paramlist]); 抽象类中可以包含抽象方法，也可以不包含abstract方法。但是，一旦某个类中包含了abstract方法，则这个类必须声明为abstract类； 抽象方法在子类中必须被实现，否则子类仍然是abstract的； abstract不能和private static final native同时修饰； abstract方法只能存在于abstract类中； abstract类中可以没有abstract方法。 1234567891011121314151617181920212223//ch04.AbstractTestpackage ch04;abstract class C&#123; abstract void callme( ); void metoo( )&#123; System.out.println(&quot;Inside C&#x27;s metoo( ) method&quot;); &#125;&#125;class D extends C&#123; void callme( )&#123; System.out.println(&quot;Inside D&#x27;s callme( ) method&quot;); &#125;&#125;abstract class E extends C&#123; &#125;public class AbstractTest&#123; public static void main( String args[ ] )&#123; C c = new D( ); c.callme( ); c.metoo( ); &#125;&#125; 对抽象类的总结 抽象类中的抽象方法没有方法体，因此无法直接实例化对象； 抽象类必须有子类，子类使用extends继承抽象类，一个子类只能够继承一个抽象类； 能够实现对象的子类，必须实现抽象类中全部的抽象方法。也就是说，只有当所有抽象方法不在抽象了，才能依据类，实现对象。 接口(interface) 有些时候，对象之间存在明显的单一方向继承关系，例如： Q：Java只支持单一继承 A： Java通过接口使得处于不同层次，甚至互不相关的类可以具有相同的行为； 接口就是方法定义和常量值的集合。它的用处主要体现在下面几个方面： 通过接口可以实现不相关类的相同行为，而不需要考虑这些类之间的层次关系； 通过接口可以指明多个类需要实现的方法； 通过接口可以了解对象的交互页面，而不需了解对象所应对的类。 在接口中定义这些共同的行为，然后由每个类分别实现这些行为； 与C++不同，Java不支持多继承，而是用接口实现比多继承更强的功能； 多重继承指一个类可以为多个类的子类，它使得类的层次关系不清楚，而且当多个父类同时拥有相同的成员变量和方法时，子类的行为是不确定的，这给编程带来了困难； 单一继承则清楚地表明了类的层次关系，指明子类和父类各自的行为； 接口则把方法的定义和类的层次区分开来，通过它可以在运行时动态地定位所调用的方法。同时接口中可以实现“多重继承”，且一个类可以实现多个接口。正式这些机制使得接口提供了比多重继承更简单、更灵活而且更强劲的功能。 接口的成员特点 成员变量：只能是常量； 默认修饰符：public static final； 构造方法：没有构造方法； 成员方法：只能是抽象的； 默认修饰符：public abstract； 接口的声明语法格式1234[可见度] interface 接口名称 [extends 其他的接口名]&#123; //声明变量 //抽象方法&#125; 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字； 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字； 接口中的方法都是共有的。 1234567891011//Exampleimport java.lang.*;public interface NameOfInterface&#123; //任何类型 final,static字段 //抽象方法&#125;interface Animal&#123; public void eat(); public void travel();&#125; 当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类； 类使用implements关键字实现接口。在类声明中，implements关键字放在class声明后面； 实现一个接口的语法，可以使用这个公式： 1...implements 接口名称 [,其他接口名称,其他接口名称...,...]... 12345678910111213141516171819//Examplepublic class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(&quot;Mammal eats&quot;); &#125; public void travel()&#123; System.out.println(&quot;Mammal travels&quot;); &#125; public static void main(String[] args)&#123; MammalInt m=new MammalInt(); m.eat(); m.travel(); &#125;&#125;/*编译运行结果:Mammal eatsMammal travels*/ 接口的继承 使用extends关键字，子接口继承父接口的方法。 接口的多继承 在Java中，类的多继承是不合法的，但接口允许多继承； 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口 1public interface Hockey extends Sports,Event 接口的理解 Java语言中，接口占据着非常重要的地位 接口定义了Java语言当中的“全抽象”概念； 接口为Java赋予了较强的扩展性，而借助于接口的扩展性，Java语言能够在不同时期找到自己的位置，从而实现持续发展； 接口为Java的模块化奠定了基础。 接口和类抽象类和接口的协同工作 狗都具有eat()、sleep()方法，我们分别通过抽象类和接口定义这个抽象的概念 如果需要让狗拥有一项特殊的技能——钻火圈DrillFireCircle()，抽象类？or接口？ 一个Special Dog即可继承Dog类，又可实现DrillFireCircle()接口。 继承：是不是； 接口：有没有； 如果一个类继承了某个抽象类，则子类必定是抽象类的种类； 而接口实现的则是有没有、具备不具备的关系； 接口定义是为了在不同的模块/组件之间协议或契约； 接口不关心内部的状态。 接口实例12345678//ch05.inter.swimmerpackage ch04.inter;public interface Swimmer &#123; public void swim(); default int getSwimSpeed () &#123; return 0; &#125;&#125; 接口中只能包含public、static、final和没有修饰符类型的成员变量和public、abstract和没有修饰符类型的成员方法； 接口中JDK8之前，接口不能定义任何实现，这意味着之前所有的Java版本中，接口指定的方法是抽象的，不包含方法体。从JDK8开始，添加了一种新功能——默认方法。默认方法允许接口方法定义默认实现，而所有子类都将拥有该方法及实现。 接口的实现及用途 在类的声明中用implements语句来表示一个类使用某个接口，在类体中可以使用接口中定义的常量，而且必须实现接口中定义的所有方法。一个类可以实现多个接口。 好的编程风格应该面向抽象编程而不是面向具体编程。 实现例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//fishpackage ch04.inter;public class Fish extends Animal implements Swimmer &#123; public Fish() &#123; // TODO Auto-generated constructor stub &#125; @Override public void swim() &#123; // TODO Auto-generated method stub System.out.println(&quot;Fish swim!&quot;); &#125; @Override public void eat() &#123; // TODO Auto-generated method stub System.out.println(&quot;Fish eat!&quot;); &#125;&#125;//frogpackage ch04.inter;public class Frog extends Animal implements Runner,Swimmer &#123; public Frog() &#123; // TODO Auto-generated constructor stub &#125; @Override public void eat() &#123; // TODO Auto-generated method stub System.out.println(&quot;Frog eat!&quot;); &#125; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(&quot;Frog run!&quot;); &#125; @Override public void swim() &#123; // TODO Auto-generated method stub System.out.println(&quot;Frog swim!&quot;); &#125;&#125;//carpackage ch04.inter;public class Car implements Runner &#123; public Car() &#123; // TODO Auto-generated constructor stub &#125; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(&quot;car run!&quot;); &#125;&#125; 用途 123456789101112131415161718192021222324252627282930313233package ch04.inter;public class InterfaceUsage &#123; public InterfaceUsage() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; InterfaceUsage demo = new InterfaceUsage(); Car car = new Car(); Fish fish = new Fish(); Frog fog = new Frog(); demo.startRun(car); demo.startRun(fog); demo.startSwim(fish); demo.startSwim(fog); &#125; public void startRun(Runner runner) &#123; System.out.println(&quot;start run...&quot;); runner.run(); System.out.println(&quot;end run...&quot;); System.out.println(&quot;------------------------------&quot;); &#125; public void startSwim(Swimmer swimmer) &#123; System.out.println(&quot;start swim...&quot;); swimmer.swim(); System.out.println(&quot;end swim...&quot;); System.out.println(&quot;------------------------------&quot;); &#125;&#125; 接口、父类和子类类型转换 子类可以当作父类来用； 父类不能当作子类用； 实现了某个接口的子类可以当这个接口用； 接口不能当子类用。 强制类型转换 (类名) 对象 例如：String str=(String)obj。 实例如下(Important!) 12345678910111213141516171819//ch04.inter.ParentSubInterfaceAssignpackage ch04.inter;public class ParentSubInterfaceAssign &#123; public static void main(String[] args) &#123; String str=&quot;1&quot;; Object obj=str; str =obj; str =(String)obj; obj=new Object(); str =(String)obj; Frog frog=new Frog(); Swimmer swimmer=frog; Runner runner=frog; frog=swimmer; frog=(Frog)swimmer; swimmer=new Fish(); frog=(Frog)swimmer; &#125;&#125; 抽象类和接口的区别 接口的设计目的，是要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制； 抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为，且其中一部分行为的实现方法一致时，可以让这些类都派生于一个抽象类，避免让所有的子类来重复，实现代码复用的目的。其余个性化部分，留给各个子类自己实现。 instanceof 用于判断一个对象是否是某个类/接口(或子类，或是否实现了这个接口) 用法： 1对象名 instanceof 类名 instanceof例子： 枚举类型 123456789101112131415161718192021//ch04.en.EnumDirection2package ch04.en;static class EnumDriection2&#123; public enum EnumDirection2 &#123; EAST(&quot;东&quot;), SOUTH(&quot;南&quot;), WEST(&quot;西&quot;), NORTH(&quot;北&quot;); private EnumDirection2(String desc) &#123;//私有类型构造函数 this.desc = desc; &#125; private String desc;//存放其他属性，其他属性可以随意增减 public String getDesc() &#123;//取得其他属性 return desc; &#125; &#125; public static void main(String[] args) &#123; for(int i=0;i&lt;EnumDirection2.values().length;i++) &#123; EnumDriection2 dir=EnumDirection2.values()[i]; //ordinal()取得序号;getDesc()取得自定义描述 System.out.println(dir+&quot;=&quot;+dir.getDesc()+&quot;\\tindex=&quot;+dir.ordinal()); &#125; &#125;&#125; 关于构造函数再谈构造函数——关于默认构造函数 必须和类同名且定义在类种； 不能有任何返回值，void也不行； 不能用static修饰，但是可以用public/private/protected修饰。 一个类可以没有显式的构造函数，可以调用默认构造方法(Important!) 默认构造方法是没有参数的构造方法，你可以显式定义类的默认构造方法； 为了保证每个类至少有一个构造方法，如果定义的类中一个构造方法也没有写，Java将自动提供一个默认构造方法。该构造方法没有参数，用public修饰，而且方法体为空。格式如下： 1public ClassName()&#123;&#125; 只要类中显式定义了一个或多个构造方法，而且所有显式定义的构造方法都带参数，那么将失去默认构造方法。 构造函数里面调用构造函数用this(…) 只能在构造函数第一行调用this(…)，且只能调用一次。 构造函数中的this/super 构造函数中调用自己的构造函数 this(…)； 调用父类的构造函数 super(…)； 每个构造函数在开始以前，会默认的调用其父类的无参数构造方法，除非这个类开始显式的调用了其他的父类构造函数； 但是，每个类的构造函数不会默认的调用自己的无参数构造方法。 构造函数的注意事项 推论1：如果一个父类，显式的声明了构造函数，且没有无参数构造函数，则其子类构造函数的第一句必须显式的调用父类的一个构造函数； 推论2：如果一个父类，显式的声明了构造函数，且没有无参数构造函数，则其子类必须显式的声明构造函数。 子类调用父类构造方法 在构造子类对象时，JVM会先调用父类的构造方法或者子类构造方法中通过super语句调用父类构造方法； 如果子类构造方法中没有通过super语句调用父类构造方法，那么JVM会调用父类的默认构造方法，如果不存在默认构造方法，将导致编译错误。 文章源码文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"计算机网络-Part1","slug":"ComputerNetwork-Part1","date":"2021-03-10T12:56:22.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2021/03/10/ComputerNetwork-Part1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/10/ComputerNetwork-Part1/","excerpt":"","text":"","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"ComputerNetwork","slug":"ComputerNetwork","permalink":"https://cheeseburgerim.github.io/tags/ComputerNetwork/"}]},{"title":"数据库原理-Part1","slug":"DataBasePrinciple-Part1","date":"2021-03-09T11:03:57.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/03/09/DataBasePrinciple-Part1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/09/DataBasePrinciple-Part1/","excerpt":"","text":"","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/categories/DataBase/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/tags/DataBase/"},{"name":"DataBasePrinciple","slug":"DataBasePrinciple","permalink":"https://cheeseburgerim.github.io/tags/DataBasePrinciple/"}]},{"title":"数字逻辑与数字系统-Part1","slug":"MLAMS-Part1","date":"2021-03-07T03:02:24.000Z","updated":"2021-04-11T04:26:34.100Z","comments":false,"path":"2021/03/07/MLAMS-Part1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/07/MLAMS-Part1/","excerpt":"","text":"Chapter1 逻辑门 逻辑门 Logic Gates 单输入逻辑门 两输入逻辑门 多输入逻辑门 逻辑电平 Logic Levels 通过离散电压代表1和0 For example： ​ 0 = ground(GND) or 0 volts ​ 1 = VDD or 5 volts Questions： What about 4.99 volts ? Is that a 0 or a 1 ? What about 3.2 volts ? ground(GND)为接地电压； VDD为电源电压。 噪声 任何使得信号衰减的事物都是噪声 例如电源供电时耦合到传输线中的阻抗等就是噪声； 实例：一个驱动门输出电压为5V，但因为输出线上存在阻抗，接受端收到的电压只有4.5V 静态约束 对于有效的逻辑输入，所有的电路单元都必须产生有效的逻辑输出； 只能使用有限的电压范围来表示离散的数值1和0。 噪声容限 直流传输特性 理想情况与实际情况对比 逻辑电平系列 Logic Family VDD VIL VIH VOL VOH TTL 5(4.75-5.25) 0.8 2.0 0.4 2.4 CMOS 5(4.5-6) 1.35 3.15 0.33 3.84 LVTTL 3.3(3-3.6) 0.8 2.0 0.4 2.4 LVCMOS 3.3(3-3.6) 0.9 1.8 0.36 2.7 CMOS晶体管 在硅和锗晶体中，原子之间靠的很近，分属于每个原子的价电子受到相邻原子的影响，而使价电子为两个原子所共有，每个原子与其相邻的原子之间形成共价键，共用一对价电子。 形成共价键后，每个原子的最外层电子是八个，构成稳定结构； 共价键有很强的结合力，使原子规则排列，形成晶体； 共价键中的两个电子被紧紧束缚在共价键中，称为束缚电子，常温下束缚电子很难脱离共价键成为自由电子，因此本征半导体中的自由电子很少，所以本征半导体的导电能力很弱。 N型半导体 P型半导体 PN结的形成 在同一片半导体基片上，分别制造P型半导体和N型半导体，经过载流子的扩散，在它们的交界面处就形成了PN结。 PN结处载流子的运动 PN结的单向导电性 PN结反向偏置 半导体二极管的开关特性 MOS晶体管 nMOS晶体管 pMOS晶体管 CMOS晶体管功能 晶体管功能 nMOS能很好的导通低电平0，因此源极接地GND； pMOS能很好的导通高电平1，因此源极接电源VDD。 CMOS非门 A P1 N1 Y 0 ON OFF 1 1 OFF ON 0 CMOS与非门 晶体管功耗 功耗=单位时间消耗的能量 动态功耗； 静态功耗。 动态功耗 对栅极电容进行充电所耗费的能量 对电容充电到电压VDD所耗费的能量为CVDD； 当晶体管以频率f来工作，充电的频率为f/2，放电的频率也为f/2； 但放电的过程不需要耗费能量，因此同台功耗计算如下： 动态功耗：Pdynamic=1/2 CVDD2f 静态功耗 当系统处于空闲状态时，晶体管处于截至状态，但仍然会泄露少量电流，因此会产生静态功耗。静态功耗由电源和地之间的漏电流IDD产生，正比于漏电流。 计算公式如下： Pstatic=IDDVDD 功耗计算实例","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"}]},{"title":"Java-Part1","slug":"Java-Part1","date":"2021-03-06T05:09:19.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/03/06/Java-Part1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/06/Java-Part1/","excerpt":"","text":"IntroductionJava编程语言的主要特性 面向对象 object-oriented 可移植性，跨平台 portable 支持分布式的网络应用 安全性和健壮性 secure and robust Java编程语言是个简单的、面向对象的、分布式的、解释性的、健壮的、安全的与系统无关的、可移植的、高性能的、多线程的并且静态的语言——Sun Java虚拟机 概念 Java虚拟机(Java Virtual Machine)在实际的计算机上通过软件模拟来实现； Java虚拟机有自己想象中的硬件。 功能 提供垃圾回收的功能； 提供运行时环境。 .class可以跨平台(操作系统) Java虚拟机每个平台(操作系统)不一样 关于跨平台的概念 Java是一次编译到处运行 Java编译为.class文件后，到其他操作系统无需再次编译 Java不是一次编写到处运行 C++文件在Windows上编写、编译成.exe文件运行，同样的代码在Linux要再次编译为Linux上可执行文件 Java程序运行模式 网页中的Applet，依托浏览器运行，目前已经很少使用了； Web方式(需要依托webserver如tomcat/websphere…)； Application，下文将重点讨论。 Java基础知识Example 首先来看一个Java应用程序的示例：HelloWorldApp 12345678910//location:.../src/ch02/HelloWorldApp.javapackage ch02;//包的名字，注意一定要和目录严格匹配//注意如何定义一个类，每个.java文件只能定义一个public类，类名字必须和文件名完全符合public class HelloWorldApp&#123; //任何一个Application程序必须要有一个public static void main(String[] args)方法 //但不是所有的类都需要main方法 public static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 关于包package 每个包对应了源程序的一个目录，每个包可以有子包(子目录)； JDK的Java类库中的几个重要包：java.lang, java.io, java.awt, java.net, java.util； 包不同层级之间用 . 分割，正如目录用 / 分割； 一个包下包含了若干类文件或者子包 包 ch02 对应了 ch02/； 包 ch02.sub01 对应了 ch02/sub01/。 关于Java的源文件 初学者可以认为一个源文件(.java)对应一个类的定义(实际上这种说法并不准确，初学者可以这样认为)； .java文件经过编译后生成一个.class文件； Java虚拟机解释.class文件执行程序(java不能直接生成.exe文件)。 关于main方法 每个能够以Java Application模式运行的类中必须有一个main方法； public static void main(String[] args)或static public void main(String[] args)。 Java最基本语法 {} 程序段 每行程序以分号；结束 // 单行注释 /* 。。。*/ 多行注释 System.out.println(); 输出并换行； System.out.print(); 输出不换行； Java对大小写非常敏感！ 包名、类名、方法名、变量名均大小写敏感！ 字符界面的输入与输出 java.io包 System.in.read() System.out.print()/println() 程序： ch02.AppCharInOut 1234567891011121314151617181920212223package ch02;import java.io.*;/** * 例子2-3 * * 本例子演示了如何从控制台读入一个字符，并输出。 * * @author Administrator * */public class AppCharInOut &#123; public static void main(String[] args) &#123; char c = &#x27; &#x27;; System.out.print(&quot;Please input a char: &quot;); try &#123; c = (char) System.in.read(); &#125; catch (IOException e) &#123; &#125; System.out.println(&quot;You have entered: &quot; + c); &#125;&#125; ch02.AppLineInOut 12345678910111213141516171819202122package ch02;import java.io.*;/** * 本例子演示了如何从控制台读入一个行字符，并输出。 * * @author Administrator * */public class AppLineInOut &#123; public static void main(String[] args) &#123; String s = &quot;&quot;; System.out.print(&quot;Please input a line: &quot;); try &#123; BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); s = in.readLine(); &#125; catch (IOException e) &#123; &#125; System.out.println(&quot;You have entered: &quot; + s); &#125;&#125; ch02.AppNumInOut 123456789101112131415161718192021222324252627282930package ch02;//导入输入输出包import java.io.*;/** * 例子2-5 本例子演示了如何从控制台读入一个数字（浮点或者整数）并输出 * * @author Administrator * */public class AppNumInOut &#123; public static void main(String[] args) &#123; String s = &quot;&quot;; int n = 0; double d = 0; try &#123; BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); System.out.print(&quot;Please input an int: &quot;); s = in.readLine(); n = Integer.parseInt(s); System.out.print(&quot;Please input a double: &quot;); s = in.readLine(); d = Double.parseDouble(s); //异常的处理，初学者可以忽略这部分 &#125; catch (IOException e) &#123; &#125; System.out.println(&quot;You have entered: &quot; + n + &quot; and &quot; + d); &#125;&#125; 查看JDK源码 以Eclipse oxygen为例 操作系统Windows7 64位 其他操作系统及软件版本操作类似 鼠标点击对应变量名 或者ctrl鼠标点击方法名 Java数据类型Java数据类型划分 Java中的数据类型分为两大类 一类是基本数据类型(primitive types)； 另一类是引用类型(reference types)； 后者相当于对象 $$数据类型=\\begin{cases}基本数据类型=\\begin{cases}数值型=\\begin{cases}整数类型(byte,short,int,long)\\浮点类型(float,double)\\end{cases}\\字符型(char)\\布尔型(boolean)\\end{cases}\\引用数据类型=\\begin{cases}类(class)\\接口(interface)\\数组\\end{cases}\\end{cases}$$ Java基本数据类型 Java中定义了四类/八种基本数据类型 逻辑型——boolean 文本型——char 整数型——byte，short，int，long 浮点数型——float，double 逻辑型 boolean类型适合于逻辑运算，一般用于程序流程控制； boolean类型数据只允许取值true或false，不可以0或非0的整数替代true和false； 例如 12345boolean b=false;if(b==true)&#123;//do something&#125; 字符类型 char型数据用来表示通常意义上“字符”； 字符常量是用单引号括起来的单个字符 char c = ‘A’； Java字符采用Unicode编码，每个字符占两个字节，因而可用十六进制编码形式表示 char c1 = ‘\\u0061’； Java语言中还允许使用转义字符’&#39;来将其后的字符转变为其他的含义 char c2 = ‘\\r’； 常用的转义字符 整数类型 Java各整数类型有固定的表数范围和字段长度，而不受具体操作系统的影响，以保证Java程序的可移植性 类型 占用存储空间(字节) 表数范围 byte 1 -128~127 short 2 -215~215-1 int 4 -231~231-1 long 8 -263~263-1 Java语言整形常量的三种表示形式(ch03.HexOctInt)： 十进制整数：如12，-134，0； 八进制整数：要求以0开头，如012； 十六进制数：要求以0x或0X开头，如0x12。 Java语言的整形常量默认为int型，如： int i=3； 声明long型常量可以后加’l’或’L’，如： long l=3L； 123456789101112131415161718//ch03.HexOctIntpackage ch03;public class HexOctInt &#123; public HexOctInt() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; int i = 10; int j = 010;//鍏繘鍒� int k = 0x10;//鍗佸叚杩涘埗 System.out.println(&quot;10=&quot; + i); System.out.println(&quot;010=&quot; + j); System.out.println(&quot;0x10=&quot; + k); &#125;&#125; 浮点型 Java浮点类型有固定的表数范围和字段长度 类型 占用存储空间(字节) 表述范围 float 4 -3.403E38~3.403E38 double 8 -1.798E308~1.798E308 Java浮点类型常量有两种表示形式 十进制数形式，必须含有小数点，例如： 3.14，314.0，。314 科学计数法形式，如： 3.14e2，3.14E2，314E2 Java浮点型常量默认为double型，如要声明一个常量为float型，则需在数字后面加f或F，如： double d=3.14； float f=3.14f； 基本数据类型变量声明和赋值 例子见如下代码 ch03.DeclareAssign 123456789101112131415161718192021//ch03.DeclareAssignpackage ch03;public class DeclareAssign&#123; public static void main (String args []) &#123; boolean b = true; int x, y=8; float f = 4.5f; double d = 3.1415; char c; c =&#x27;\\u0031&#x27;; x = 12; System.out.println(&quot;b=&quot; + b); System.out.println(&quot;x=&quot; + x); System.out.println(&quot;y=&quot; + y); System.out.println(&quot;f=&quot; + f); System.out.println(&quot;d=&quot; + d); System.out.println(&quot;c=&quot; + c); &#125;&#125; Java中的关键字 标识符 任何一个变量、常量、方法、对象和类都需要有名字，这些名字就是标识符。标识符可以由编程者自由指定，但是需要遵循一定的语法规定； 标识符要满足如下的规定： 首字母只能是a-z，A-Z，$或者_； 其余字母只能是a-z，A-Z，$，_或者数字。 在实际应用标识符时，应该使标识符能一定程度上反映它所表示的变量、常量、对象、或类的意义，这样程序的可读性会更好； 同时，应注意Java时大小写敏感的语言。 运算符与表达式运算符 算术运算符 1234567891011121314151617181920212223242526272829//ch03.ArithmaticOppackage ch03;public class ArithmaticOp&#123; public static void main( String args[] )&#123; int a=5+4; //a=9 int b=9*2; //b=18 int c=18/4; //c=4 int d=18-4; //d=14 int e=-d; //e=-14 int f=-14%4; //f=-2 double g=18.4; double h=g%4; //h=2.4 int i=3; int j=i++; //i=4,j=3 int k=++i; //i=5,k=5 System.out.println(&quot;a = &quot;+a); System.out.println(&quot;b = &quot;+b); System.out.println(&quot;c = &quot;+c); System.out.println(&quot;d = &quot;+d); System.out.println(&quot;e = &quot;+e); System.out.println(&quot;f = &quot;+f); System.out.println(&quot;g = &quot;+g); System.out.println(&quot;h = &quot;+h); System.out.println(&quot;i = &quot;+i); System.out.println(&quot;j = &quot;+j); System.out.println(&quot;k = &quot;+k); &#125;&#125; 逻辑运算符 1234567891011121314//ch03.LogicOperatorpackage ch03;public class LogicOperator&#123; public static void main( String args[] )&#123; System.out.println(&quot;true&amp;&amp;false =&quot;+(true&amp;&amp;false) ); System.out.println(&quot;true||false =&quot;+(true||false) ); System.out.println(&quot;!true =&quot; +(!true)); System.out.println(&quot;true^false =&quot; +(true^false)); System.out.println(&quot;true&amp;false =&quot;+(true&amp;false) ); System.out.println(&quot;true|false =&quot;+(true|false) ); &#125;&#125; 位运算符 移位运算符 移位运算符性质 使用数据类型：byte、short、char、int、long，对低于int型的操作数将先自动转换为int型再移位； 对于int型整数移位a&gt;&gt;b，系统先将b对32取模，得到的结果才是真正移位的位数； 同样的，对于long型整数移位a&gt;&gt;b，则是先将b对64取模。 移位运算符应用举例 赋值运算符赋值运算符= 当 “=” 两侧的数据类型不一致时，可以使用默认类型转换或强制类型转换(casting)原则进行处理 12long l=100;int i=(int)l; Exception：可以将整型常量直接赋值给byte，short，char等类型变量，而不需要进行强制类型转换，只要不超出其表数范围 12byte b=12; //legalbyte b=4096; //illegal 1234567891011121314151617181920212223242526272829303132333435363738//ch03.AssignOpertor/** * */package ch03;public class AssignOpertor &#123; /** * */ public AssignOpertor() &#123; // TODO Auto-generated constructor stub &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub double d=65; //float f1=d;//Wrong float f2=(float)d;//Right //int i1=f2;//Wrong int i2=(int)f2;//Right //char c1=i2;//Wrong char c2=(char)i2;//Right //byte b1=c2;//Wrong byte b2=(byte)c2;//Right //byte b3=128;//Wrong byte b4=65;//Right System.out.println(&quot;i2=&quot;+i2); System.out.println(&quot;c2=&quot;+c2); System.out.println(&quot;b2=&quot;+b2); &#125;&#125; 扩展赋值运算符 位和位移运算的实例12345678910111213141516171819//ch03.BitOpertorpackage ch03;public class BitOperator &#123; public static void main(String args[]) &#123; int FLAG1 = 1; // (0x0001) int FLAG2 = 2; // (0x0010) int FLAG3 = 7; // (0x0111) System.out.println(&quot;0x0001|0x0010=&quot; + (FLAG1 | FLAG2)); System.out.println(&quot;0x0001&amp;0x0111=&quot; + (FLAG1 &amp; FLAG3)); System.out.println(&quot;0x0001^0x0111=&quot; + (FLAG1 ^ FLAG3)); System.out.println(&quot;0x0001&amp;0x0111=&quot; + (~FLAG1)); System.out.println(&quot;2&lt;&lt;1=&quot; + (2 &lt;&lt; 1)); System.out.println(&quot;2&gt;&gt;1=&quot; + (2 &gt;&gt; 1)); System.out.println(&quot;2&gt;&gt;1=&quot; + ((-2) &gt;&gt; 1)); System.out.println(&quot;2&gt;&gt;&gt;1=&quot; + ((-2) &gt;&gt;&gt; 1)); &#125;&#125; 表达式 表达式是符合一定语法规则的运算符和操作数的序列 表达式的类型和值 对表达式中操作数进行运算得到的结果称为表达式的值； 表达式的值的数据类型即为表达式的类型。 表达式的运算顺序 首先应按照运算符的优先级从高到低的顺序进行； 优先级相同的运算符按照事先约定的结合方向进行。 表达式中的类型转换 当有不同种类的混合运算时：int→long→float→double； 所有的byte，short，char等转为int； 例如 123double d=1;System.out.println(2*d);//输出为2.0而不是2 运算符优先级与结核性 流程控制语句 结构化程序设计的三种基本流程 顺序、分支、循环 简单语句 最简单的语句是方法调用语句及赋值语句，是在方法调用或赋值表达式后加一个分号(；) 如 123System.out.println(&quot;Hello World&quot;);a=3+x;b=a&gt;0?a:-a; 分支语句——if 1234567891011121314151617181920212223242526272829//ch03.LeapYear/** * */package ch03;public class LeapYear &#123; /** * */ public LeapYear() &#123; // TODO Auto-generated constructor stub &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub int year = 2003; if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)) &#123; System.out.println(year + &quot; is a leap year.&quot;); &#125; else &#123; System.out.println(year + &quot; is not a leap year.&quot;); &#125; &#125;&#125; 分支语句——switch 12345678910111213141516171819202122232425//ch03.GradeLevel.javapackage ch03;public class GradeLevel&#123; public static void main( String args[ ] )&#123; char grade=&#x27;C&#x27;; //normal use switch( grade )&#123; case &#x27;A&#x27; : System.out.println(grade+&quot; is 85~100&quot;); break; case &#x27;B&#x27; : System.out.println(grade+&quot; is 70~84&quot;); break; case &#x27;C&#x27; : System.out.println(grade+&quot; is 60~69&quot;); break; case &#x27;D&#x27; : System.out.println(grade+&quot; is &lt;60&quot;); break; default : System.out.println(&quot;input error&quot;); &#125; &#125;&#125; 循环语句 循环语句功能 在循环条件满足的情况下，反复执行特定代码。 循环语句的四个组成部分 初始化部分(init_statement)； 循环条件部分(test_exp)； 循环体部分(body_statement)； 迭代部分(alter_statement)。 循环语句分类 for循环； while循环 do/while循环。 123456789101112131415161718192021222324252627282930313233//ch03.Sum100package ch03;public class Sum100 &#123; public static void main(String args[]) &#123; int sum, n; System.out.println(&quot;\\n**** for statement ****&quot;); sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; sum = sum+i; &#125; System.out.println(&quot;sum is &quot; + sum); System.out.println(&quot;\\n**** while statement ****&quot;); sum = 0; n = 100; while (n &gt; 0) &#123; sum += n; n--; &#125; System.out.println(&quot;sum is &quot; + sum); System.out.println(&quot;\\n**** do_while statement ****&quot;); sum = 0; n = 0; do &#123; sum += n; n++; &#125; while (n &lt;= 100); System.out.println(&quot;sum is &quot; + sum); &#125;&#125; 特殊流程控制语句 123456789101112131415161718192021//ch03.BreakDemo/** * */package ch03;public class BreakDemo &#123; /** * @param args */ public static void main(String args[]) &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 3) break; System.out.println(&quot; i =&quot; + i); &#125; System.out.println(&quot;Game Over!&quot;); &#125;&#125; 12345678910111213141516171819202122232425//ch03.ContinueDemo/** * */package ch03;public class ContinueDemo &#123; /** * @param args */ public static void main(String args[]) &#123; round1:for (int i = 0; i &lt; 10; i++) &#123; round2:for (int j = 0; j &lt; 10; j++) &#123; if (j %2!=0) continue round2; if (i %2==0) continue round1; System.out.println(&quot; i =&quot; + i+&quot;\\t j =&quot; + j); &#125; &#125; System.out.println(&quot;Game Over!&quot;); &#125;&#125; 12345678910111213141516171819202122232425//ch03.BreakContinuepackage ch03;public class BreakContinue &#123; public BreakContinue() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; label1: for (int i = 0; i &lt; 5; i++) &#123; label2: for (int j = 0; j &lt; 5; j++) &#123; if(j==3)&#123; continue label2; &#125; if(i==3)&#123; break label1; &#125; System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j); &#125; &#125; &#125;&#125; 数组数组概述 数组是多个相同类型数据的组合，实现对这些数据的统一管理； 数组属于引用类型，数组型数据是对象(object)，数组中的每个元素相当于该对象的成员变量； 数组中的元素可以是任何数据类型，包括基本类型和引用类型。 一维数组声明 一维数组的声明方式 12345type var[] or type[] var//For exampleint a[];int[] a1;double b[]; Java语言中声明数组时不能指定其长度(数组中元素的个数) 1int a[5]; //illegal 但是可以在需要初始化的时候声明长度 1int[] a=new int[5]; Java数组长度可以是变量(不同于C) 12int len=4;int[] a=new int[len]; 12345678910111213141516171819202122232425262728293031//ch03.ArrayDemopackage ch03;/** * 涓�缁存暟缁勭殑澹版槑鍜屽垵濮嬪寲 * @author Administrator * */public class ArrayDemo &#123; public static void main( String args[ ] )&#123; int[] a; a = new int[3]; a[0] = 3; a[1] = 9; a[2] = 8; int[] b= new int[3]; b[0] = 3; b[1] = 9; b[2] = 8; int[] c= &#123;1,2,3&#125;; //The following is illegal //int[] d=new int[3]; //d= &#123;1,2,3&#125;; int f[]= &#123;1,2,3&#125;; System.out.println(f instanceof Object); &#125;&#125; 数组元素的默认初始化 数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化 123456public class Test&#123; public static void main(String[] args)&#123; int a[]=new int[5]; System.out.println(a[3]); &#125;&#125; 12345678910111213141516//ch03.Fibonaccipackage ch03;public class Fibonacci &#123; public static void main(String args[]) &#123; int i; int f[] = new int[10]; f[0] = f[1] = 1; for (i = 2; i &lt; f.length; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; for (i = 1; i &lt;= f.length; i++) &#123; System.out.println(&quot;F[&quot; + i + &quot;]= &quot; + f[i - 1]); &#125; &#125;&#125; 数组元素的引用 定义并用运算符 new 为之分配空间后，才可以引用数组中的每个元素； 数组元素的引用方式：arrayName[index] index为数组元素下标，可以是整型常量或整型表达式 如a[3], b[i], c[6*i]； 数组元素下标从0开始；长度为n的数组合法下标取值范围：0~n-1； 每个数组都有一个属性 length 指明它的长度 例如：a.length 指明数组 a 的长度(元素个数)。 多维数组12//二维数组举例int a[][]=&#123;&#123;1,2&#125;,&#123;3,4,0,9&#125;,&#123;5,6,7&#125;&#125;; i\\j j=0 j=1 j=2 j=3 i=0 1 2 i=1 3 4 0 9 i=2 5 6 7 Java中多维数组被做为数组的数组处理； Java中多维数组的声明和初始化应按从高维到低维的顺序进行 123456//legalint t[][]=new int[4][];t[0]=new int[5];t[1]=new int[5];//illegalint t1[][]=new int[][4]; Java中多维数组不必须是规则矩阵形式 1234567int [][] tt=new int[4][];tt[0]=new int[2];tt[1]=new int[4];tt[2]=new int[6];tt[3]=new int[8];int tt[][]=new int[4][5]; 多维数组初始化静态初始化12int intArray[][]=&#123;&#123;1,2&#125;,&#123;2,3&#125;,&#123;3,4,5&#125;&#125;;//legalint intArray[3][2]=&#123;&#123;1,2&#125;,&#123;2,3&#125;,&#123;4,5&#125;&#125;;//illegal 动态初始化12345int a[][]=new int[4][5];int b[][]=new int[3][];b[0]=new int[2];b[1]=new int[3];b[2]=new int[5]; 复制数组 关于String和char初步认知Java中字符(char)和字符串(String)的区别123456789101112131415161718192021//ch03.CharAndString/** * */package ch03;public class CharAndString &#123; public static void main(String[] args) &#123; char c=&#x27;a&#x27;; char c2=(char)256; String s1=&quot;abc&quot;; String s2=String.valueOf(c); System.out.println(&quot;c=&quot;+c); System.out.println(&quot;c2=&quot;+c2); System.out.println(&quot;s1=&quot;+s1); System.out.println(&quot;s2=&quot;+s2); &#125;&#125; char是基本数据类型，可以保存一个字符，用’ ‘； 可以把一个整数转换为char； String是一个类，可以保存0个或者更多char，用” “； String类中提供把char转换为String的方法。 Java中的字符 “+”可用于对字符串进行连接操作 1String s=&quot;hello, &quot;+&quot;world!&quot;; “+”两侧操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串 1234int i=300+5;String s=&quot;hello, &quot;+i+&quot;号&quot;;System.out.println(s);//输出：hello, 305号 体会”+”的不同结果 1234String s5=&quot;1&quot;+&#x27;1&#x27;;char c2=&#x27;1&#x27;+&#x27;1&#x27;;System.out.println(s5+&quot;,&quot;+c2);//输出：11,b char[] String int 之间的转换12345678910111213141516171819202122232425262728//ch03.CharArrayStringInt/** * */package ch03;public class CharArrayStringInt &#123; public CharArrayStringInt() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; String s1 = &quot;abc&quot;; // String to char[] char[] charArray = s1.toCharArray(); // char[] to String String s2 = new String(charArray); // get the length of String int len = s1.length(); int num=123; // int to String String s3=String.valueOf(num); // String to int int num2=Integer.valueOf(s3); &#125;&#125; 字符串的比较 判断s1，s2是否相等 123s1.equals(s2);ors1.equalsIgnoreCse(s2); 比较两个字符串大小 1234s1.compareTo(s2);相等 返回0;大于 返回正数，第一位不同的字符相差的ASCII值;小于 返回负数，第一位不同的字符相差的ASCII值; 12345678910111213141516171819202122232425//ch03.StringComparepackage ch03;public class StringCompare &#123; public StringCompare() &#123; // TODO Auto-generated constructor stub &#125; public static void main(String[] args) &#123; String s1=&quot;&quot;; String s2=&quot;123&quot;; for(int i=0;i&lt;4;i++) &#123; s1=s1 + i; &#125; System.out.println(&quot;s1.equals(s2):&quot;+s1.equals(s2)); System.out.println(&quot;s1 == s2 :&quot;+(s1==s2)); System.out.println(&quot;abc.equals(ABc) :&quot;+&quot;abc&quot;.equals(&quot;ABc&quot;)); System.out.println(&quot;abc.equals(ABc) :&quot;+&quot;abc&quot;.equalsIgnoreCase( &quot;ABc&quot;)); System.out.println(&quot;abc.compareTo(aaa) :&quot;+&quot;azc&quot;.compareTo(&quot;aaa&quot;)); System.out.println(&quot;abc.compareTo(abc) :&quot;+&quot;abc&quot;.compareTo(&quot;abc&quot;)); System.out.println(&quot;abc.compareTo(abd) :&quot;+&quot;abc&quot;.compareTo(&quot;abz&quot;)); &#125;&#125; String其他常见操作 错误程序例子 测试代码及输出结果123456789101112131415161718192021package Test;public class Test&#123; public static void main(String[] args) &#123; int i=300+5; String s=&quot;hello&quot;+i+&quot;号&quot;; System.out.println(s); String s5=&quot;1&quot;+&#x27;1&#x27;; char c2=&#x27;1&#x27;+&#x27;1&#x27;; System.out.println(s5+&quot;,&quot;+c2); System.out.println(5+7); System.out.println(1234567890+1234567890); System.out.println(1234567890l+1234567890); System.out.println(&quot;abc.compareTo(aaa) :&quot;+&quot;azc&quot;.compareTo(&quot;aaa&quot;)); System.out.println(&quot;abc.compareTo(abc) :&quot;+&quot;abc&quot;.compareTo(&quot;abc&quot;)); System.out.println(&quot;abc.compareTo(abd) :&quot;+&quot;abc&quot;.compareTo(&quot;abz&quot;)); &#125;&#125; 文章源码文章源码 备用仓库","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"}]},{"title":"域名更换","slug":"ChangeDomainName1","date":"2021-03-05T05:00:54.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2021/03/05/ChangeDomainName1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/05/ChangeDomainName1/","excerpt":"","text":"2021/3/5 ~ 2022/3/5 域名暂时更换至 CheeseburgerIM.space","categories":[{"name":"Notification","slug":"Notification","permalink":"https://cheeseburgerim.github.io/categories/Notification/"}],"tags":[{"name":"ChangeDomainName","slug":"ChangeDomainName","permalink":"https://cheeseburgerim.github.io/tags/ChangeDomainName/"},{"name":"Notification","slug":"Notification","permalink":"https://cheeseburgerim.github.io/tags/Notification/"}]},{"title":"NOWCODER-2021-3","slug":"NOWCODER-2021-3","date":"2021-03-01T09:29:44.000Z","updated":"2021-04-11T04:26:34.099Z","comments":false,"path":"2021/03/01/NOWCODER-2021-3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/03/01/NOWCODER-2021-3/","excerpt":"","text":"Part1 3/3 求出两个数的最大公约数 My Code 12345678910111213#include &lt;iostream&gt;using namespace std;int gcd(int a,int b);int main()&#123; system(&quot;pause&quot;); return 0;&#125;int gcd(int a,int b)&#123; if(a%b==0) return b; return gcd(b,a%b);&#125; Question From：HERE 判断给定的链表中是否有环。如果有环则返回true，否则返回false。 My Code 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;struct ListNode&#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;bool hasCycle(ListNode *head);int main()&#123; system(&quot;pause&quot;); return 0;&#125;bool hasCycle(ListNode *head)&#123; ListNode *slow=head,*fast=head; while(slow&amp;&amp;fast&amp;&amp;fast-&gt;next) &#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast) return true; &#125; return false;&#125; 思路：定义快慢指针，若慢指针能追上快指针，说明链表中存在环，否则不存在； Question From：HERE Part2 3/5 TRDD开了一家免费WiFi体验店， 所有人都可以免费连接WiFi， 只有一个条件， 你要提前一天预约。今天，TRDD收到了n(1 &lt;= n &lt;=1000)个人的预约， 每个人有一个时间段[L, R] (1 &lt;= L &lt;= R &lt;= 5000)表示这个人预约连接WiFi从L时刻到R时刻。 但是市面上只有一种路由器， 这种路由器单台最多能同时连接m(n &lt;= 100)台设备， TRDD想要知道最少使用多少台路由器就能保证明天每个人都能连上WiFi。 思路：首先在纸上直角坐标系，可以清晰地找到最大值； 在C++中，通过定义二维数组来模拟坐标系； 每当有人来使用WiFi时，找到可以使x=l和x=r之间(x,y)恒等于0的y的最小值，将(l,y),(l+1,y)…(r,y)全部置1，问题得解； 不过由于题目中n为1000，定义一个[1000] [1000]的二维数组在提交时提示越界。 Answer 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main()&#123; int n,m; int a[5001]=&#123;0&#125;; cin&gt;&gt;n&gt;&gt;m; int Max=1e-7; while(n--)&#123; int l,r; cin&gt;&gt;l&gt;&gt;r; for(int i=l;i&lt;=r;i++)&#123; a[i]++; if(a[i]&gt;Max)&#123; Max=a[i]; &#125; &#125; &#125; int result; if(Max%m==0)&#123; result = Max/m; &#125; else&#123; result = Max/m+1; &#125; cout&lt;&lt;result&lt;&lt;endl;&#125; 思路：与我思路相似，不过在实现时将二维数组改为一维数组，二维数组的纵坐标即为一维数组中的元素大小，输入所有人的时间后，找到最大值，问题得解。 Question From：HERE Part3 3/6 tabris有一个习惯，无聊的时候就会数圈圈，无论数字还是字母。 现在tabris更无聊啦，晚上睡不着觉就开始数羊，从a只数到b只。 顺便还数了a到b之间有多少个圈。 但是tabris笨啊，虽然数羊不会数错，但很可能数错圈的个数。 但是tabris很难接受自己笨这个事实，所以想问问你他一共应该数出多少个圈，这样tabris才好判断他到底笨不笨啊。 My Code 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; int t; while(cin&gt;&gt;t) &#123; int a,b; for(int i=0;i&lt;t;i++) &#123; cin&gt;&gt;a&gt;&gt;b; int sum=0; for(int j=a;j&lt;=b;j++) &#123; int temp=j; while(temp!=0) &#123; int r=temp%10; if(r==4||r==6||r==9||r==0) sum++; else if(r==8) sum=sum+2; temp=temp/10; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：暴力循环即可。 Question From：HERE Part4 3/7 Atsa just bought Super Mario Maker and wants to test your skills for an analysis with a level that he prepared. My Code 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main()&#123; int l,g; while(cin&gt;&gt;l&gt;&gt;g) &#123; int max=0; for(int i=0;i&lt;g;i++) &#123; int p,d; cin&gt;&gt;p&gt;&gt;d; if(d==0&amp;&amp;d&gt;max) &#123; max=d; &#125; else if(d==1&amp;&amp;l-d&gt;max) &#123; max=l-d-1; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：相撞并不影响走的距离，就像高中物理，质量相同的两小球相撞，无能量损失，碰撞后都按原来相反方向相同速率运动。 Question From：HERE 妞妞希望能选取最大数量的硬币，使其总价值足以支付车费并且出租车司机能接受。 妞妞希望你能帮她计算最多可以支付多少个硬币。 My Code 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n,s; while(cin&gt;&gt;n&gt;&gt;s) &#123; int p[20]=&#123;&#125;; for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i]; sort(p,p+n); int temp=0,ans=0,i=0; while(temp&lt;s) &#123; temp=temp+p[i]; ans++; i++; &#125; for(int i=ans-1;i&gt;=0;i--) &#123; if(temp-p[i]&gt;=s) &#123; ans--; temp=temp-p[i]; &#125; &#125; cout&lt;&lt;ans; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：将硬币大小从小到大排序，用循环拿硬币，直到钱已经大于车费时停止循环；再在所拿的硬币中从大到小取出硬币，直到司机接受为止。 Question From：HERE Part5 3/8 情人节到了，小芳和小明手牵手，打算过一个完美的情人节，但是小刚偏偏也来了，当了一个明晃晃的电灯泡，小明很尴尬，就和小刚说，我交给你个任务，你完成了我俩就带你玩，否则你就回家吧。小刚很有当单身狗的觉悟，他坚决不想让小明过好情人节，同为单身狗的你能帮帮他吗？现在有一个n×n（1 &lt;= n &lt;= 1000）的格子，每一个格子都有一个电灯泡，可能是亮的，也可能是灭的（1代表亮， 0代表灭），现在有两种操作，一种是给你一个坐标，对于那个坐标上的灯泡，如果他是亮的，那么熄灭他，反之如果他是灭的，那么打开它。第二种操作是给你两个坐标，第一个坐标代表一个子矩阵的左上角，另一个坐标是右下角，请你求出当前子矩阵中有多少个灯泡是亮着的。燥起来吧！！！单身狗们！！！！ My Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; int bulb[1010][1010]=&#123;&#125;; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;bulb[i][j]; &#125; &#125; for(int i=0;i&lt;m;i++) &#123; int f; cin&gt;&gt;f; if(f==1) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; if(bulb[x][y]==1) bulb[x][y]=0; else if(bulb[x][y]==0) bulb[x][y]=1; &#125; else if(f==2) &#123; int x1,y1,x2,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; int num=0; for(int j=x1;j&lt;=x2;j++) &#123; for(int k=y1;k&lt;=y2;k++) &#123; if(bulb[j][k]==1) num++; &#125; &#125; cout&lt;&lt;num&lt;&lt;endl; &#125; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE 今天qwb要参加一个数学考试，这套试卷一共有n道题，每道题qwb能获得的分数为ai，qwb并不打算把这些题全做完，他想选总共2k道题来做，并且期望他能获得的分数尽可能的大，他准备选2个不连续的长度为k的区间,即[L,L+1,L+2,….,L+k-1]，[R,R+1,R+2,…,R+k-1]（R &gt;= L+k）。 My Code 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int getSum(int a[],int l,int r);int main()&#123; int t; while(cin&gt;&gt;t) &#123; int n,k; for(int i=0;i&lt;t;i++) &#123; cin&gt;&gt;n&gt;&gt;k; int *a=new int [n+1]; for(int j=0;j&lt;n;j++) &#123; cin&gt;&gt;a[j]; &#125; int max=0; for(int j=0;j+k+k&lt;=n;j++) &#123; for(int m=j+k;m+k&lt;=n;m++) &#123; int temp=getSum(a,j,j+k-1)+getSum(a,m,m+k-1); if(temp&gt;max) max=temp; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125;int getSum(int a[],int l,int r)&#123; int sum=0; for(int i=l;i&lt;=r;i++) &#123; sum=sum+a[i]; &#125; return sum;&#125; 思路：暴力循环求解，超时。 答案代码如下 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[2000005];int main()&#123; ios::sync_with_stdio(0); int _;cin&gt;&gt;_; while(_--)&#123; int n,k;cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],a[i]+=a[i-1]; ll ma=-1e18,ans=-1e18; for(int i=k;i+k&lt;=n;i++)&#123; ma=max(ma,a[i]-a[i-k]); ans=max(ans,ma+a[i+k]-a[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 因为区间大小是固定为k的，所以显然需要前缀和处理一下处理之后我们去维护前缀中长度为k的最大值ma，枚举第二个长度为k的起点，那么答案就是max(ma+当前长度为k的序列和)复杂度为O(n)极限数据计算 n为2e5，k=1e5 所有ai都是1e5 那么最大值是2e5*1e5&gt;(1&lt;&lt;31)-1 超过了int所能表示的范围 所以需要开long long 定义数组a[0]=0; cin&gt;&gt;a, a[1]=a[1-1]+a; cin&gt;&gt;a, a[2]=a[2-1]+a; … cin&gt;&gt;a, a[n]=a[n-1]+a. 通过单层for循环找到前两个最大值，问题得解。 Question From：HERE Part6 3/9 良神爱吃甜点，如果他吃不到甜点的话就会很暴躁！现在桌子上摆着一排n个点心，每个点心具有一个甜度ai，良神一次能吃连续的一些点心，但是他一次不能吃总甜度和超过m（可以等于m），否则他就长不高啦！良神想要知道他最少吃几次才能把这些点心都吃完。 My Code 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; int *a=new int[n+1]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; int ans=0; int temp=0; for(int i=0;i&lt;n;i++) &#123; if(temp+a[i]&lt;=m) &#123; temp=temp+a[i]; &#125; else &#123; ans++; temp=0; i=i-1; &#125; &#125; cout&lt;&lt;ans+1&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE 大吉大利，今晚吃鸡——枪械篇 My Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;struct GUN&#123; double p; int k; double accessory[1010]=&#123;&#125;;&#125;;struct ACCESSORY&#123; int type; double damage;&#125;;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; //输入n把枪的属性 //GUN *gun=new GUN[n+10]; GUN gun[1010]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;gun[i].p&gt;&gt;gun[i].k;//输入p，k for(int j=0;j&lt;gun[i].k;j++) cin&gt;&gt;gun[i].accessory[j];//输入第i把枪可以装备的配件种类，共k种 &#125; //输入m个配件的属性 //ACCESSORY *a=new ACCESSORY[m+10]; ACCESSORY a[1010]; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a[i].type&gt;&gt;a[i].damage;//输入配件的种类和威力 &#125; //找到每个配件的最大值 double *maxA=new double[m+10]; maxA[0]=-1; for(int i=1;i&lt;=m;i++) &#123; double max=0; for(int j=0;j&lt;m;j++) &#123; if(a[j].type==i&amp;&amp;a[j].damage&gt;max) max=a[j].damage; &#125; maxA[i]=max; &#125; /* for(int i=0;i&lt;=m;i++) &#123; cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;maxA[i]&lt;&lt;endl; &#125; */ double MAX=0; for(int i=0;i&lt;n;i++) &#123; double tempG=gun[i].p; double tempA=0; for(int j=0;j&lt;gun[i].k;j++) &#123; tempA=tempA+maxA[int(gun[i].accessory[j])]; &#125; double temp=tempG*(1+tempA); if(temp&gt;MAX) MAX=temp; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;MAX&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE Part7 3/10 现在给出一个赛区的规模，也就是这个赛区的实际参赛队伍数，小 Q 同学想知道有多少队伍的奖牌会由银变金、由铜变银、由铁变铜。 My Code 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; double n; while(cin&gt;&gt;n) &#123; double gold=n*0.1; double silver=n*0.2; double bronze=n*0.3; int goldChange=0,silverChange=0,bronzeChange=0; if(gold-(int)gold&gt;0) goldChange=1; if(silver-(int)silver&gt;0) silverChange=goldChange+1; else silverChange=goldChange; if(bronze-(int)bronze&gt;0) bronzeChange=silverChange+1; else bronzeChange=silverChange; cout&lt;&lt;goldChange&lt;&lt;&quot; &quot;&lt;&lt;silverChange&lt;&lt;&quot; &quot;&lt;&lt;bronzeChange&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE Part8 3/11 彩虹岛网红脸盆大哥最骄傲就是自己制作的木桶。一天𝑙𝑤𝑞拿了𝑛块木板，其中第𝑖块木板的高度为ℎ𝑖，他希望脸盆大哥能够用这些木板制作出精美的木桶。脸盆大哥告诉𝑙𝑤𝑞制作一个木桶需要𝑘块木板，并且所有桶的底面积为𝑠，底面的木板由𝑠𝑙𝑝提供。𝑙𝑤𝑞想知道用这些木块所制作出来的木桶最多能够盛多少体积的水。 注意，木板不能叠在另一个木板上，且不需要考虑木桶具体是怎么由木板组成的，即是说1块或2块木板也可以组成木桶，底面积仍为𝑠。 My Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;#include &lt;valarray&gt;using namespace std;//int findMax(int h[]);int main()&#123; int t; while (cin &gt;&gt; t) &#123; while (t--) &#123; int n, k, s; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; int height[1010]=&#123;&#125;; for (int i = 0; i &lt; n; i++) cin &gt;&gt; height[i]; //for(int i=0;i&lt;n;i++) cout&lt;&lt;height[i]&lt;&lt;&quot; &quot;; //cout&lt;&lt;endl; int ans = 0; for (int i = 0; i &lt; n / k; i++) &#123; int min = 10000; for (int j = 0; j &lt; k; j++) &#123; int max = *max_element(height, height + n); //cout&lt;&lt;&quot;max:&quot;&lt;&lt;max&lt;&lt;endl; if (max &lt; min) min = max; //int index = *find(height, height + n, max) - 1; int index=0; for(int m=0;m&lt;n;m++) &#123; if(height[m]==max) &#123; index=m; break; &#125; &#125; //cout&lt;&lt;&quot;index:&quot;&lt;&lt;index&lt;&lt;endl; height[index] = -1; &#125; //cout&lt;&lt;min*s&lt;&lt;endl; ans = ans + min * s; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE 银行的定期存款一般有1年期、2年期、3年期、5年期四种。 现在我们有1块钱，我们想知道，通过合理安排存款方式，n年以后这1块钱最多会变成几块钱。 假设在这n年里利率不变，且n年以后这笔钱不能处于2年期、3年期、5年期存款年限的中间（否则会变成活期）。 My Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int n; double r1,r2,r3,r5; cin&gt;&gt;n&gt;&gt;r1&gt;&gt;r2&gt;&gt;r3&gt;&gt;r5; double money=1; while(n) &#123; if(n&gt;=5) &#123; int time=n/5; for(int i=0;i&lt;time;i++) &#123; money=money*pow(1+r5,5); &#125; n=n%5; &#125; else if(n&gt;=3) &#123; int time=n/3; for(int i=0;i&lt;time;i++) &#123; money=money*pow(1+r3,3); &#125; n=n%3; &#125; else if(n&gt;=2) &#123; int time=n/2; for(int i=0;i&lt;time;i++) &#123; money=money*pow(1+r2,2); &#125; n=n%2; &#125; else &#123; money=money*(1+r1); n--; &#125; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(5)&lt;&lt;money&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 思路：起初认为存钱年数越长，得到的本息越多，后发现这是错的； 需要使用动态规划。 Answer 1234567891011121314151617181920212223242526272829303132# include&lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;# include &lt;math.h&gt;# define ll long longusing namespace std;double max(double a,double b)&#123; if(a&gt;b) return a; else return b;&#125;double dp[40];int main()&#123; int n;double r1,r2,r3,r5; cin&gt;&gt;n&gt;&gt;r1&gt;&gt;r2&gt;&gt;r3&gt;&gt;r5; r1=pow(1+r1,1); r2=pow(1+r2,2); r3=pow(1+r3,3); r5=pow(1+r5,5); dp[0]=1; for(int i=1;i&lt;=20;++i) &#123; if(i&gt;=1)dp[i]=max(dp[i-1]*r1,dp[i]); if(i&gt;=2)dp[i]=max(dp[i-2]*r2,dp[i]); if(i&gt;=3)dp[i]=max(dp[i-3]*r3,dp[i]); if(i&gt;=5)dp[i]=max(dp[i-5]*r5,dp[i]); &#125; cout&lt;&lt;dp[n]&lt;&lt;endl; return 0;&#125; 动态规划 Question From：HERE Part9 3/13 栗酱在酒桌上玩一个小游戏，第一个人从1开始数数，如果遇到数字中含4或者数字是4的倍数则跳过报下一个，数错了就要罚酒一杯。 My Code 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;bool isFour(int num);int main()&#123; int n; while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;i++) &#123; if(i%4!=0&amp;&amp;isFour(i)) cout&lt;&lt;i&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125;bool isFour(int num)&#123; while(num!=0) &#123; int rest=num%10; if(rest==4) return false; num=num/10; &#125; return true;&#125; Question From：HERE 坤酱想把一块圆形的布裁成正多边形，于是请你告诉坤酱正多边形的几个顶点应在哪里？ 为了方便表示，圆给出在坐标系中，正多边形的第一个顶点固定在该圆在平行于x轴正方向最远的位置上，请按顺时针顺序输出所有的顶点。 My Code 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;math.h&gt;const double PI(acos(-1));using namespace std;int main()&#123; int t; while (cin &gt;&gt; t) &#123; while (t--) &#123; double x, y, r, n; cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; n; double angle = 2 * PI / n; double tempAngle = 0; for (int i = 0; i &lt; n; i++, tempAngle = tempAngle - angle) &#123; if(fabs(x+r*cos(tempAngle))&lt;10e-6) cout&lt;&lt;&quot;0.00 &quot;; else cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; x + r * cos(tempAngle) &lt;&lt; &quot; &quot;; if(fabs(y+r*sin(tempAngle))&lt;10e-6) cout&lt;&lt;&quot;0.00&quot;&lt;&lt;endl; else cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; y + r * sin(tempAngle) &lt;&lt; endl; &#125; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：第一个顶点在原点右边；通过for循环以及cos和sin三角函数计算每次的横坐标和纵坐标改变量； 注意： 通过const double PI(acos(-1));定义PI来减小误差； 通过判断横纵坐标绝对值是否足够小来决定输出(避免输出-0.00)，其中fabs为适用于double类型的绝对值函数。 Question From：HERE Part10 3/14 中国文化的五行：金、木、水、火、土相生相克， 一天Alice和Bob玩起了卡牌游戏。卡牌包含5种类型Jin，Mu，Shui，Huo，Tu，分别代表金、木、水、火、土。 金克木，木克土，土克水，水克火，火克金。游戏规则如下： 两人玩n轮，每轮各自抽取一张卡牌，如果其中一个人的牌克制另一个人的牌那么这个人得3分，另一个人得0分。没有克制关系两人都得1分。最后得分高的获胜。 My Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;math.h&gt;using namespace std;int getLevel(string s);int main()&#123; int n; while(cin&gt;&gt;n) &#123; int score1=0,score2=0; while(n--) &#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; int Alice=getLevel(s1),Bod=getLevel(s2); if(abs(Alice-Bod)==1) &#123; if(Alice&gt;Bod) score1=score1+3; else score2=score2+3; &#125; else if(abs(Alice-Bod)==4) &#123; if(Alice==1) score1=score1+3; else score2=score2+3; &#125; else &#123; score1++; score2++; &#125; &#125; if(score1&gt;score2) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl; else if(score1&lt;score2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Draw&quot;&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125;int getLevel(string s)&#123; if(s==&quot;Jin&quot;) return 5; if(s==&quot;Mu&quot;) return 4; if(s==&quot;Tu&quot;) return 3; if(s==&quot;Shui&quot;) return 2; else return 1;&#125; 小明在坐景驰科技研发的无人车到达了目的地。 景驰科技（JingChi.ai）是一家由人工智能技术驱动、以无人驾驶技术为核心的智能出行公司。它将打造面向中国市场的全无人驾驶。从无人车下来以后，小明看到了一个长长的楼梯。 有一个n级台阶的楼梯，小明一次可以向上跳1步，两步，甚至是n步，请问小明跳到n级台阶有多少种跳法？ My Code 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int f(int n)&#123; if(n==1) return 1; return 2*f(n-1);&#125;int main()&#123; int t,n; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; cout&lt;&lt;f(n)&lt;&lt;endl; &#125; return 0;&#125; 思路：f(0)=1 n=1，f(1)=1； n=2，第一步有两种跳法，分别为一次跳一步和一次跳两步。跳一步时，第二步有一种跳法，即f(1)；跳两步时，不用跳第二步，也就是有一种跳法f(0)。所以f(2)=f(1)+f(0)。 n=3，第一步有三种跳法，分别为1，2，3。跳一步时，第二步有f(2)种跳法；跳两步时，第二步有f(1)种跳法；跳三步时，第二步有f(0)种跳法。所以f(3)=f(2)+f(1)+f(0)，又因为f(2)=f(1)+f(0)，所以f(3)=2*f(2)。 推广到n时，f(n)=2*f(n-1)。 Question From：HERE Part11 3/15 点点是一名出色的狼人。众所周知，狼人只有在满月之夜才会变成狼。同时，月亮的大小随着时间变化，它的大小变化30天为一循环。它的变化情况(从第一天开始)为0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 然后又再一次循环。今年夏天点点很无聊，于是开始看月亮。由于点点很忙，所以他只选择一段连续的时间看月亮，并把月亮的大小记录了下来。现在，他告诉你他记录下东西，让你告诉他下一天(即点点记录下的最后一天的第二天)的月亮是比前一天(即点点记录下的最后一天)大还是小。 My Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std;int main()&#123; int n; while (cin &gt;&gt; n) &#123; if (n == 1) &#123; int a; cin &gt;&gt; a; if (a == 15) cout &lt;&lt; &quot;DOWN&quot; &lt;&lt; endl; else if (a == 0) cout &lt;&lt; &quot;UP&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; continue; &#125; else &#123; int a = 0, b = 0; int situation = 0; for (int i = 1; i &lt;= n; i++) &#123; if (i &lt; n - 1) &#123; int x; cin &gt;&gt; x; &#125; else &#123; if (i == n - 1) cin &gt;&gt; a; else if (i == n) &#123; cin &gt;&gt; b; if (a &gt; b) situation = -1; else situation = 1; &#125; &#125; &#125; if (b == 15) cout &lt;&lt; &quot;DOWN&quot; &lt;&lt; endl; else if (b == 0) cout &lt;&lt; &quot;UP&quot; &lt;&lt; endl; else if (situation == 1) cout &lt;&lt; &quot;UP&quot; &lt;&lt; endl; else if (situation == -1) cout &lt;&lt; &quot;DOWN&quot; &lt;&lt; endl; //0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1 &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 注意： n==0时不是全部不能判断； 只取输入的后两位时，前面还有n-2个数会输入。 Question From：HERE Part12 3/16 小明现在在玩一个游戏，游戏来到了教学关卡，迷宫是一个N*M的矩阵。小明的起点在地图中用“S”来表示，终点用“E”来表示，障碍物用“#”来表示，空地用“.”来表示。障碍物不能通过。小明如果现在在点（x，y）处，那么下一步只能走到相邻的四个格子中的某一个：（x+1，y），（x-1，y），（x，y+1），（x，y-1）；小明想要知道，现在他能否从起点走到终点。 Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,m;int f;int s,e;int vis[505][505];char a[505][505];int dir[][2]=&#123;&#123;-1,0&#125;, &#123;1 ,0&#125; , &#123;0,-1&#125; ,&#123;0,1&#125;&#125;;//方向 上 下 左 右void dfs(int x,int y)&#123; if(x==s&amp;&amp;y==e) &#123; f=1; &#125; for(int i=0;i&lt;4;i++) &#123; int xx=x+dir[i][0]; int yy=y+dir[i][1]; if(a[xx][yy]!=&#x27;#&#x27;&amp;&amp;!vis[xx][yy]&amp;&amp;xx&gt;=0&amp;&amp;xx&lt;n&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;m) &#123; vis[xx][yy]=1; dfs(xx,yy); &#125; &#125;&#125;int main()&#123; int sv,se; while(cin&gt;&gt;n&gt;&gt;m) &#123; f=0; memset(vis,0,sizeof(vis)); memset(a,0,sizeof(a)); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; scanf(&quot; %c&quot;,&amp;a[i][j]); if(a[i][j]==&#x27;S&#x27;)&#123;sv=i,se=j;&#125; if(a[i][j]==&#x27;E&#x27;)&#123;s=i,e=j;&#125; &#125; &#125; dfs(sv,se); if (f) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125; 深度优先算法DFS Question From：HERE 栗酱突发闲心，玩了一会儿仙剑。她玩的这个版本的仙剑非常简单，打架的时候，每次只有一个小怪，栗酱也只有一个主角，主角在每回合开始先攻击小怪，小怪有a点生命值，主角有b点生命值，小怪有c点攻击力，主角有d点攻击力，每次攻击都会造成确确实实的攻击力的伤害。生命值小于等于零时就会挂掉。栗酱发现好像战斗一开始就已经能知道结果了，请你帮她算一下，这样她就可以挂机去做更有趣的事了。数据保证攻击力和初始生命值均大于等于1。 My Code 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int main()&#123; int t; while (cin &gt;&gt; t) &#123; while (t--) &#123; int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; //cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; while (1) &#123; a = a - d; if (a &lt;= 0) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; break; &#125; b = b - c; if (b &lt;= 0) &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; break; &#125; //cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; &#125; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE Part13 3/19 My Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;bool cmp(pair&lt;int, int&gt;a, pair&lt;int, int&gt;b)&#123; return a.first&lt;b.first;//根据fisrt的值升序排序 //return a.second&lt;b.second;//根据second的值升序排序&#125;typedef pair&lt;int, int&gt; p;int main()&#123; int n,k; while(cin&gt;&gt;n&gt;&gt;k) &#123; //pair&lt;int,int&gt; dawn[1000010]; //pair&lt;int,int&gt; dusk[1000010]; p *dawn=new p[n+1]; p *dusk=new p[n+1]; for(int i=0;i&lt;n;i++)&#123; int x; cin&gt;&gt;x; dawn[i]=make_pair(x,i); //cin&gt;&gt;dawn[i].first; //dawn[i].second=i; &#125; sort(dawn,(dawn+n),cmp); for(int i=0;i&lt;n;i++)&#123; int x; cin&gt;&gt;x; dusk[i]=make_pair(x,i); //cin&gt;&gt;dusk[i].first; //dusk[i].second=i; &#125; sort(dusk,(dusk+n),cmp); int sweet=0; for(int i=0,index=n-1;i&lt;=k;i++,index--) &#123; int index1=dawn[index].second; int index2=dusk[index].second; int max1=dawn[index].first; int max2=dusk[index].first; if(index1==index2) &#123; if(max1&gt;=max2) &#123; sweet=sweet+max1; dawn[index1].first=0; dusk[index2].first=0; &#125; else &#123; sweet=sweet+max2; dawn[index1].first=0; dusk[index2].first=0; &#125; &#125; else &#123; sweet=sweet+max1+max2; dawn[index1].first=0; dusk[index1].first=0; dawn[index2].first=0; dusk[index2].first=0; &#125; //cout&lt;&lt;max1&lt;&lt;&quot; &quot;&lt;&lt;max2&lt;&lt;endl; //cout&lt;&lt;sweet&lt;&lt;endl; &#125; cout&lt;&lt;sweet&lt;&lt;endl; delete [] dawn; delete [] dusk; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：对甜度从小到大排序，每次取早上甜度的最大值和晚上甜度的最大值进行比较，分为块数相同和不同两种情况。若块数相同，则增加该块数的早晚甜度最大值；若块数不同，则增加这两个 思路错误，明天再更&gt;_&lt; Question From：HERE Part14 3/27 巴啦啦能量，沙鲁沙鲁，小魔仙大变身：对于一个数，把他所有位上的数字进行加和，得到新的数。 如果这个数字是个位数的话，那么他就满足条件。 My Code 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;typedef long long ll;ll solution(ll n);int main()&#123; ll n; while (cin &gt;&gt; n) &#123; int ans=solution(n); while(ans&gt;=10)&#123; ans=solution(ans); &#125; cout&lt;&lt;ans; &#125; system(&quot;pause&quot;); return 0;&#125;ll solution(ll n)&#123; int ans = 0; while (n / 10 != 0) &#123; ans = ans + n % 10; n = n / 10; &#125; ans = ans + n; return ans;&#125; Question From：HERE Forever97与未央是一对笔友，他们经常互相写信。有一天Forever97去邮局寄信，发现邮局的收费方式变成了按字收费，收取的费用为总字数除了其自身以外的最大因子。虽然Forever97是一个有情调的人，但他不想因新收费方式而破财，所以他打算把信分成几份寄出去来减少邮费。已知Forever97写的信共有n个字，可以拆成无数封信，也可以不拆，每封信最少为2个字。求Forever97最少需要付多少邮费？ My Code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;bool isPrime(int n);int main()&#123; int t; while(cin&gt;&gt;t) &#123; while(t--) &#123; int n; cin&gt;&gt;n; if(isPrime(n)) cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; else if(n%2==0) cout&lt;&lt;&quot;2&quot;&lt;&lt;endl; else if(isPrime(n-2)) cout&lt;&lt;&quot;2&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;3&quot;&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125;// bool isPrime(int n)// &#123;// for(int i=2;i&lt;=n/2+1;i++)// &#123;// if(n%i==0) return false;// &#125;// return true;// &#125;bool isPrime(int x)//判断是不是是素数&#123; int l=sqrt(x*1.0); for(int i=2;i&lt;=l;i++) &#123; if(x%i==0) return 0; &#125; return 1;&#125; 思路：找到n可以被分为最少几个质数； 需要注意的是 不是所有合数都能分成两个质数的和，例如27、35、51等奇合数； 大于2的偶数都可以表示为两个质数的和。 所以，这道题一共只有三种输出：1，2和3。 注意：在使用函数判断一个数是否为质数时，在for循环中只需循环至根号n即可。 Question From：HERE Points C++对double类型取余 123456789101112131415161718192021222324include &lt;math.h&gt;double a,b;fmod(double a,double b);//a对b取余modf(double a,double *b);//将参数的整数部分通过指针回传，返回小数部分//Example#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; double a = 12.4, b = 3; double c=0; cout &lt;&lt; fmod(a, b) &lt;&lt; endl &lt;&lt; modf(a, &amp;c) &lt;&lt; endl &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;/*输出：0.40.412*/ C++ max_element find max 深度优先算法DFS","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"CodeExercise","slug":"CodeExercise","permalink":"https://cheeseburgerim.github.io/tags/CodeExercise/"},{"name":"Exercise","slug":"Exercise","permalink":"https://cheeseburgerim.github.io/tags/Exercise/"},{"name":"Practice","slug":"Practice","permalink":"https://cheeseburgerim.github.io/tags/Practice/"},{"name":"NOWCODER","slug":"NOWCODER","permalink":"https://cheeseburgerim.github.io/tags/NOWCODER/"},{"name":"Daily","slug":"Daily","permalink":"https://cheeseburgerim.github.io/tags/Daily/"}]},{"title":"Course-js","slug":"Course-js","date":"2021-02-26T02:07:24.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2021/02/26/Course-js/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/26/Course-js/","excerpt":"","text":"","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"Website","slug":"Website","permalink":"https://cheeseburgerim.github.io/tags/Website/"},{"name":"Design","slug":"Design","permalink":"https://cheeseburgerim.github.io/tags/Design/"},{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"js","slug":"js","permalink":"https://cheeseburgerim.github.io/tags/js/"}]},{"title":"NOWCODER-2021/2","slug":"NOWCODER-2021-2","date":"2021-02-24T01:45:50.000Z","updated":"2021-04-11T04:26:34.100Z","comments":false,"path":"2021/02/24/NOWCODER-2021-2/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/24/NOWCODER-2021-2/","excerpt":"","text":"Part1 2/23 1有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ My Code 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; int ans=0; while(n&gt;0) &#123; if(n==1) &#123; break; &#125; else if(n==2) &#123; n=n-2; ans++; break; &#125; else//n&gt;=3 &#123; int temp=n/3; ans=ans+temp; n=n%3+temp;; &#125; &#125; if(ans&gt;0) cout&lt;&lt;ans&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; 此解法过于复杂； 通过数学分析，最后获得的饮料总数是总空瓶数整除2； 则有下代码 1234567#include&lt;stdio.h&gt;int main ()&#123; int m; while(~scanf(&quot;%d&quot;,&amp;m)&amp;&amp;m!=0) printf(&quot;%d\\n&quot;,m/2); return 0;&#125; 2明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 My Code 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; int Arr[1010]=&#123;0&#125;; int If[1010]=&#123;0&#125;; for(int i=0;i&lt;n;i++) &#123; int x; cin&gt;&gt;x; if(If[x]) continue; If[x]=1; Arr[i]=x; &#125; sort(Arr,Arr+n); for(int i=0;i&lt;n;i++) &#123; if(Arr[i]==0) continue; cout&lt;&lt;Arr[i]&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 思路：输入n个数，重复时不输入，最后排序，按从小到大的顺序输出正数； 题解思路：声明一个足够大的数组，当输入的数为i时，令数组第i为置1；for循环输出，当数组该位为1时，输出位数； 代码如下 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int N, n; while (cin &gt;&gt; N) &#123; int a[1001] = &#123; 0 &#125;; while (N--) &#123; cin &gt;&gt; n; a[n] = 1; &#125; for (int i = 0; i &lt; 1001; i++) if (a[i]) cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 3写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。 My Code 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; char str[100]; while(cin&gt;&gt;str) &#123; int ans=strtol(str,NULL,16); cout&lt;&lt;ans&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; C++可以规定输入进制数，不需要调用strtol函数； 代码如下 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;hex&gt;&gt;n) &#123; cout&lt;&lt;n&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; Question From：HERE Part2 2/24 输入一个链表，反转链表后，输出新链表的表头。 My Code 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;ListNode* ReverseList(ListNode* pHead);int main()&#123; system(&quot;pause&quot;); return 0;&#125;ListNode* ReverseList(ListNode* pHead)&#123; if(pHead==NULL) &#123; return NULL; &#125; ListNode *Pre=NULL; ListNode *Next=NULL; while(pHead!=NULL) &#123; Next=pHead-&gt;next; pHead-&gt;next=Pre; Pre=pHead; pHead=Next; &#125; return Pre;&#125; 思路1：从头到尾遍历，新建反转链表，不过会浪费一些空间； 思路2(以上代码思路)：将pHead指针逐个后移，再通过Pre以及Next指针将原指针反转，最后返回链表头指针； Question From：HERE 给定一个数组，请你编写一个函数，返回该数组排序后的形式。 12345678vector&lt;int&gt; MySort(vector&lt;int&gt;&amp; arr) &#123; // write code here //sort(arr.begin(),arr.end()); //sort(begin(arr),end(arr)); //sort(arr.begin(),arr.end(),less&lt;int&gt;()); sort(begin(arr),end(arr),less&lt;int&gt;()); return arr;&#125; 通过begin和end函数找到数组的起始位置和结束位置； Question From：HERE Part3 2/25 1老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩. My Code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; int Grade[30010]=&#123;0&#125;; for(int i=1;i&lt;=n;i++) &#123; int temp; cin&gt;&gt;temp; Grade[i]=temp; &#125; while(m--) &#123; char c; int a,b; cin&gt;&gt;c&gt;&gt;a&gt;&gt;b; if(c==&#x27;Q&#x27;) &#123; if(a&gt;b) &#123; int temp=b; b=a; a=temp; &#125; int max=0; for(int i=a;i&lt;=b;i++) &#123; if(Grade[i]&gt;max) max=Grade[i]; &#125; cout&lt;&lt;max&lt;&lt;endl; &#125; else if(c==&#x27;U&#x27;) &#123; Grade[a]=b; &#125; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 这道题没什么难度，唯一需要注意的是当输入字符为Q时，可能会有a&gt;b的情况 2开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。处理:1.记录最多8条错误记录，对相同的错误记录(即文件名称和行号完全匹配)只记录一条，错误计数增加；(文件所在的目录不同，文件名和行号相同也要合并)2.超过16个字符的文件名称，只记录文件的最后有效16个字符；(如果文件名不同，而只是文件名的后16个字符和行号相同，也不要合并)3.输入的文件可能带路径，记录文件名称不能带路径 My Code A Little Bit Hard 3扑克牌游戏大家应该都比较熟悉了，一副牌由54张组成，含3~A，2各4张，小王1张，大王1张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）:)3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如：4 4 4 4-joker JOKER请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR My Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int getType(string str,int l);int main()&#123; string str; while(getline(cin,str)) &#123; int index=str.find(&#x27;-&#x27;); string left=str.substr(0,index); string right=str.substr(index+1,str.length()); string Card=&quot;12345678910JQKA2jokerJOKER&quot;; //Type of left and right //Type: 1Single; 2Pair; 3Trible; 4joker; 5JOKER; // 6Sequence; 7bomb; 8KingBomb int ll=left.length(); int rl=right.length(); int typeOfLeft=getType(left,ll),typeOfRight=getType(right,rl); //Solve the Problem if(typeOfLeft&lt;=6&amp;&amp;typeOfRight&lt;=6&amp;&amp;typeOfLeft!=typeOfRight) cout&lt;&lt;&quot;ERROR&quot;&lt;&lt;endl; else if(typeOfLeft==8) cout&lt;&lt;left&lt;&lt;endl; else if(typeOfRight==8) cout&lt;&lt;right&lt;&lt;endl; else if(typeOfLeft==7&amp;&amp;typeOfRight==7) &#123; int indexLeftSpace=left.find(&#x27; &#x27;),indexRightSpace=right.find(&#x27; &#x27;); string tl=left.substr(0,indexLeftSpace),tr=right.substr(0,indexRightSpace); //cout&lt;&lt;tl&lt;&lt;&quot; &quot;&lt;&lt;tr&lt;&lt;endl; int indexl=Card.find(tl),indexr=Card.find(tr); if(indexl&gt;indexr) cout&lt;&lt;left&lt;&lt;endl; else if(indexl&lt;indexr) cout&lt;&lt;right&lt;&lt;endl; else cout&lt;&lt;&quot;ERROR&quot;&lt;&lt;endl; &#125; else if(typeOfLeft==7) cout&lt;&lt;left&lt;&lt;endl; else if(typeOfRight==7) cout&lt;&lt;right&lt;&lt;endl; else if(typeOfLeft==5) cout&lt;&lt;left&lt;&lt;endl; else if(typeOfRight==5) cout&lt;&lt;right&lt;&lt;endl; else if(typeOfLeft==4) cout&lt;&lt;left&lt;&lt;endl; else if(typeOfRight==4) cout&lt;&lt;right&lt;&lt;endl; else &#123; int indexLeftSpace=left.find(&#x27; &#x27;),indexRightSpace=right.find(&#x27; &#x27;); string tl=left.substr(0,indexLeftSpace),tr=right.substr(0,indexRightSpace); int indexl=Card.find(tl),indexr=Card.find(tr); if(indexl&gt;indexr) cout&lt;&lt;left&lt;&lt;endl; else if(indexl&lt;indexr) cout&lt;&lt;right&lt;&lt;endl; else cout&lt;&lt;&quot;ERROR&quot;&lt;&lt;endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125;int getType(string str,int l)&#123; int numOfSpace=0; for(int i=0;i&lt;l;i++) &#123; if(str[i]==&#x27; &#x27;) numOfSpace++; &#125; if(str==&quot;joker&quot;) return 4; else if(str==&quot;JOKER&quot;) return 5; else if(str==&quot;joker JOKER&quot;||str==&quot;JOKER joker&quot;) return 8; else if(l&lt;=2) return 1; else if(numOfSpace==1) return 2; else if(numOfSpace==2) return 3; else if(numOfSpace==3) return 7; else return 6;&#125; 思路 找到输入字符串‘-’的位置； 在该位置将字符串分成left，right两个字串； 分别判断出两个字串的类型； 比较大小； 问题的解。 Question From：HERE Part4 2/27 1写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000） My Code 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string Reverse(string str);int main()&#123; string s; while(cin&gt;&gt;s) &#123; cout&lt;&lt;Reverse(s)&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125;string Reverse(string str)&#123; reverse(str.begin(),str.end()); return str;&#125; 函数：直接调用&lt; algorithm&gt;头文件中的reverse函数； Question From：HERE 2大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。 My Code 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int Fibonacci(int n);int main()&#123; int n; while(cin&gt;&gt;n) &#123; cout&lt;&lt;Fibonacci(n)&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125;int Fibonacci(int n)&#123; if(n==0) return 0; else if(n==1) return 1; else if(n==2) return 1; else return Fibonacci(n-1)+Fibonacci(n-2);&#125; Question From：HERE 3给定一个字符串，请编写一个函数判断该字符串是否回文。如果回文请返回true，否则返回false。 My Code 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool judge(string str);int main()&#123; string s; while(cin&gt;&gt;s) &#123; if(judge(s)) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;false&quot;&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125;bool judge(string str)&#123; int l=str.length(); int mid=l/2; if(l%2==0)//even &#123; for(int i=0,j=l-1;i&lt;=mid;i++,j--) &#123; if(str[i]!=str[j]) return false; else return true; &#125; &#125; else//odd &#123; for(int i=0,j=l-1;i&lt;mid;i++,j--) &#123; if(str[i]!=str[j]) return false; &#125; return true; &#125;&#125; Question From：HERE 4山峰元素是指其值大于或等于左右相邻值的元素。给定一个输入数组nums，任意两个相邻元素值不相等，数组可能包含多个山峰。找到索引最大的那个山峰元素并返回其索引。 My Code 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int peak(int* a,int aLen);int main()&#123; system(&quot;pause&quot;); return 0;&#125;int peak(int* a,int aLen)&#123; for(int i=aLen-1;i&gt;=0;i--) &#123; if(i==aLen-1) &#123; if(a[i]&gt;a[i-1]) return i; &#125; else &#123; if(a[i]&gt;a[i-1]&amp;&amp;a[i]&gt;a[i+1]) return i; &#125; &#125; return 0;&#125; 这道题很简单，不过以上代码还有可以简化的地方； 将条件设为a[i]&gt;a[i-1]，好处为：如果循环到第i位，说明a[i+1]&lt;a[i]，所以下次不需要再次判断a[i+1]和a[i]的关系； 答案代码如下 12345678int solve(int* a, int aLen) &#123; // write code here for(int i=aLen-1;i;i--) &#123; if(a[i]&gt;a[i-1])return i; &#125; return 0;&#125; Question From：HERE Points C++可以规定输入进制数 123//Example 16int x;cin&gt;&gt;hex&gt;&gt;x; 数组函数 begin end 123456int Arr[]=&#123;1,2,3,......,n&#125;//random numberbegin(Arr)-&gt;1;end(Arr)-&gt;n//convenient when needed to be sorted#include &lt;algorithm&gt;sort(begin(Arr),end(Arr)); C++中输入反斜杠’&#39; 12345678/*在C++编程中有时候会遇到有些符号不能直接输入，像反斜杠&#x27;\\&#x27;，如果直接输入会出现：错误的终止了宏调用的错误，这时我们就需要把这些符号转义一下For Example */#include &lt;string&gt;string str=&#x27;\\&#x27;;//Wrong!string str=&#x27;\\\\&#x27;;//Correct!//使用转义字符&#x27;\\\\&#x27;，这样其实输入的还是&#x27;\\&#x27;// C++ Pair结构 C++ reverse函数 1234#include &lt;algorithm&gt;#include &lt;string&gt;string str=&quot;abcd&quot;;reverse(str.begin(),str.end()); C++ vector结构","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"CodeExercise","slug":"CodeExercise","permalink":"https://cheeseburgerim.github.io/tags/CodeExercise/"},{"name":"Exercise","slug":"Exercise","permalink":"https://cheeseburgerim.github.io/tags/Exercise/"},{"name":"Practice","slug":"Practice","permalink":"https://cheeseburgerim.github.io/tags/Practice/"},{"name":"NOWCODER","slug":"NOWCODER","permalink":"https://cheeseburgerim.github.io/tags/NOWCODER/"},{"name":"Daily","slug":"Daily","permalink":"https://cheeseburgerim.github.io/tags/Daily/"}]},{"title":"To The Moon","slug":"To-The-Moon","date":"2021-02-23T01:25:13.000Z","updated":"2021-04-11T04:26:34.098Z","comments":false,"path":"2021/02/23/To-The-Moon/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/23/To-The-Moon/","excerpt":"","text":"","categories":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"}],"tags":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"Fun","slug":"Fun","permalink":"https://cheeseburgerim.github.io/tags/Fun/"},{"name":"To The Moon","slug":"To-The-Moon","permalink":"https://cheeseburgerim.github.io/tags/To-The-Moon/"}]},{"title":"Course-css","slug":"Course-css","date":"2021-02-22T05:44:24.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2021/02/22/Course-css/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/22/Course-css/","excerpt":"","text":"","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"css","slug":"css","permalink":"https://cheeseburgerim.github.io/tags/css/"},{"name":"Website","slug":"Website","permalink":"https://cheeseburgerim.github.io/tags/Website/"},{"name":"Design","slug":"Design","permalink":"https://cheeseburgerim.github.io/tags/Design/"},{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"}]},{"title":"Chapter5 优化程序性能","slug":"DUOCS-Chapter5","date":"2021-02-19T02:09:23.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2021/02/19/DUOCS-Chapter5/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/19/DUOCS-Chapter5/","excerpt":"","text":"优化编译器的能力和局限性表示程序性能程序示例消除循环的低效率减少过程调用消除不必要的存储器引用理解现代处理器降低循环开销转换到指针代码提高并行性综合：优化合并(Combing)代码的效果小结分支预测和预测错误处罚理解存储器性能现实生活：性能提高技术确认和消除性能瓶颈小结","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/tags/Postgraduate/"}]},{"title":"Course for HTML","slug":"Course-html","date":"2021-02-17T13:10:46.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2021/02/17/Course-html/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/17/Course-html/","excerpt":"","text":"教程 超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言； 可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析； HTML实例1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 注意：对于中文网页需要使用&lt; meta charset=”utf-8”&gt;生命编码，否则会出现乱码。有些浏览器(如360浏览器)会设置GBK为默认编码，则需要设置为&lt; meta charset=”gbk”&gt; Have A Try Examples for HTML 文档的后缀名 .html .htm 以上两种后缀名没有区别，都可以使用 参考手册Reference HTML/CSS/JS在线工具HTML/CSS/JS Online 简介HTML实例 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 实例解析 &lt; !DOCTYPE html&gt; 声明为 HTML5 文档； &lt; html&gt; 元素是 HTML 页面的根元素； &lt; head&gt; 元素包含了文档的元（meta）数据，如 &lt; meta charset=”utf-8”&gt; 定义网页编码格式为 utf-8； &lt; title&gt; 元素描述了文档的标题； &lt; body&gt; 元素包含了可见的页面内容； &lt; h1&gt; 元素定义一个大标题； &lt; p&gt; 元素定义一个段落。 什么是HTML？HTML是用来描述网页的一种语言 HTML 指的是超文本标记语言: HyperText Markup Language； HTML 不是一种编程语言，而是一种标记语言； 标记语言是一套标记标签 (markup tag)； HTML 使用标记标签来描述网页； HTML 文档包含了HTML 标签及文本内容； HTML文档也叫做 web 页面。 标签HTML标记标签通常被称为HTML标签(HTML tag) HTML 标签是由尖括号包围的关键词，比如 &lt; html&gt;; HTML 标签通常是成对出现的，比如 &lt; b&gt;和&lt; /b&gt;; 标签对中的第一个标签是开始标签，第二个标签是结束标签； 开始和结束标签也被称为开放标签和闭合标签。 &lt;标签&gt;内容&lt;/标签&gt; 元素 “HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思； 但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例 HTML元素： &lt; p&gt;这是一个段落。&lt; /p&gt; Web浏览器 Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示; 浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户 网页结构下面是一个可视化的HTML页面结构 &lt;html&gt; &lt;head&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 只有&lt; body&gt;区域才会在浏览器中显示 版本从初期的网络诞生后，已经出现了许多HTML版本: 版本 发布时间 HTML 1991 HTML+ 1993 HTML 2.0 1995 HTML 3.2 1997 HTML 4.01 1999 XHTML 1.0 2000 HTML5 2012 XHTML5 2013 &lt; !DOCTYPE&gt;声明有助于浏览器中正确显示网页； 网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容； doctype 声明是不区分大小写的，以下方式均可 &lt;!DOCTYPE html&gt; &lt;!DOCTYPE HTML&gt; &lt;!doctype html&gt; &lt;!Doctype Html&gt; 基础标题 HTML 标题（Heading）是通过&lt; h1&gt; - &lt; h6&gt; 标签来定义的。 123&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;h2&gt;这是一个标题&lt;/h2&gt;&lt;h3&gt;这是一个标题&lt;/h3&gt; 段落 HTML 段落是通过标签 &lt; p&gt; 来定义的。 12&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;p&gt;这是另外一个段落。&lt;/p&gt; 链接 HTML 链接是通过标签 &lt; a&gt; 来定义的。 提示：在href属性中指定链接的地址。 1&lt;a href=&quot;https://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt; 图像 HTML 图像是通过标签 &lt; img&gt; 来定义的。 注意：图像的名称和尺寸是以属性的形式提供的。 1&lt;img loading=&quot;lazy&quot; src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt; 元素 开始标签 元素内容 结束标签 &lt; p&gt; 这是一个段落 &lt; /p&gt; &lt; a href=”default.htm”&gt; 这是一个链接 &lt; /a&gt; &lt; br&gt; 换行 开始标签常被称为起始标签(opening tag)，结束标签常被称为闭合标签(closing tag) 元素语法 HTML 元素以开始标签起始 HTML 元素以结束标签终止 元素的内容是开始标签与结束标签之间的内容 某些 HTML 元素具有空内容（empty content） 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数 HTML 元素可拥有属性 嵌套的HTML元素 大多数HTML元素可以嵌套(HTML元素可以包含其他HTML元素)； HTML文档由相互嵌套的HTML元素构成。 HTML空元素 没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。 &lt; br&gt; 就是没有关闭标签的空元素（&lt; br&gt; 标签定义换行）。 在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。 在开始标签中添加斜杠，比如 &lt; br /&gt;，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。 即使 &lt; br&gt; 在所有浏览器中都是有效的，但使用 &lt; br /&gt; 其实是更长远的保障。 HTML提示：使用小写标签 HTML 标签对大小写不敏感：&lt; P&gt; 等同于 &lt; p&gt;。许多网站都使用大写的 HTML 标签。 菜鸟教程使用的是小写标签，因为万维网联盟（W3C）在 HTML 4 中推荐使用小写，而在未来 (X)HTML 版本中强制使用小写。 注：本文章转自菜鸟教程 Points 换行&lt; br&gt;； 上划线overline 1&lt;font style=&quot;text-decoration: overline;&quot;&gt;X&lt;/font&gt; 斜体 1&lt;i&gt;斜体&lt;/i&gt;","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"Website","slug":"Website","permalink":"https://cheeseburgerim.github.io/tags/Website/"},{"name":"Design","slug":"Design","permalink":"https://cheeseburgerim.github.io/tags/Design/"},{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"html","slug":"html","permalink":"https://cheeseburgerim.github.io/tags/html/"}]},{"title":"Chapter4 处理器体系结构","slug":"DUOCS-Chapter4","date":"2021-02-16T02:06:09.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/02/16/DUOCS-Chapter4/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/16/DUOCS-Chapter4/","excerpt":"","text":"Y86指令集体系结构逻辑设计和硬件控制语言HCLY86的顺序(sequential)实现流水线的通用原理Y86的流水线实现小结","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"postgraduate","slug":"postgraduate","permalink":"https://cheeseburgerim.github.io/tags/postgraduate/"}]},{"title":"Hexo博客添加自定义HTML页面","slug":"BUPWBP","date":"2021-02-12T12:43:04.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2021/02/12/BUPWBP/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/12/BUPWBP/","excerpt":"","text":"Build up pages without being polished Steps 新建页面或文章 跳过渲染 添加并修改html文件 新建页面或文章1234//Post$ hexo new post &quot;Post Name&quot;//Page$ hexo new page Page Name 跳过渲染在博客根目录的配置文件_config.yml文件里，跳过渲染 找到 skip_render: 123456789# 跳过文件夹下所有文件skip_render: - &quot;filename/*&quot;# 跳过文件夹下的子文件夹skip_render: - &quot;filename/subfilename/*&quot;# 跳过文件夹下所有文件夹和文件skip_render: - &quot;filename/**&quot; 添加并修改html文件最后，处理css、js文件 我们都知道，hexo部署的是静态文件，所有文章的md文件会被渲染成html文件(hexo g生成)，hexo会帮我们把所有的css、js文件都加到文章里，我们之前跳过了渲染(第二步)，所以就需要手动把css、js整合到html文件里，一般我们的代码是这种结构 或 下面分为两部分 css 找到index.html文件里的语句，例如 12&lt;link rel=&quot;stylesheet&quot; href=&quot;css/xxx.css&quot;&gt;&lt;!-- css目录下的xxx.css文件 --&gt; 直接在css文件夹里面找到对应的文件xxx.css，复制文件内容，把上面的代码改写为 1&lt;style&gt; css代码内容 &lt;/style&gt; js 找到index.html文件里的语句，例如 1&lt;script src=&quot;js/xxx.js&quot;&gt;&lt;/script&gt; 直接在js文件夹里面找到对应的xxx.js，复制文件内容，把上面的代码改为 1&lt;script&gt; js代码内容 &lt;/script&gt; 重新部署即可 From： https://blog.csdn.net/qq_40922859/article/details/100877777 示例Proof That Tony Stark Has A Heart hexo new page IronMan 跳过渲染 12skip_render: - &quot;IronMan/**&quot; 添加并修改html文件 源码来自Here Author：阿阳热爱前端 并按上述方法整合css或js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;HTML+CSS 钢铁侠心脏反应堆&lt;/title&gt; &lt;style&gt; * &#123; /* 初始化 清除页面元素的内外边距 */ padding: 0; margin: 0;&#125;body &#123; /* 弹性布局 让页面元素垂直+水平居中 */ display: flex; justify-content: center; align-items: center; /* 让页面始终占浏览器可视区域高度 */ height: 100vh; /* 背景颜色 径向渐变 */ background: radial-gradient(#353c44, #222931);&#125;/* 定义一下几个盒子相同的部分 */.circle &#123; /* 圆形 */ border-radius: 50%;&#125;.center &#123; position: absolute; top: 50%; left: 50%; /* 元素走自身高度/宽度 的一半 */ transform: translate(-50%, -50%);&#125;.container &#123; /* 相对定位 */ position: relative; width: 300px; height: 300px; border: 1px solid rgb(18, 20, 20); background-color: #384c50; /* 盒子阴影 默认是外部阴影 写了inset 就是内部阴影 */ box-shadow: 0 0 32px 8px rgb(18, 20, 20), 0 0 4px 1px rgb(18, 20, 20) inset;&#125;.container .box1 &#123; width: 238px; height: 238px; background-color: rgb(22, 26, 27); box-shadow: 0 0 4px 1px #52fefe;&#125;.container .box2 &#123; width: 220px; height: 220px; background-color: #fff; box-shadow: 0 0 5px 1px #52fefe, 0 0 5px 4px #52fefe inset;&#125;.container .box3 &#123; width: 180px; height: 180px; background-color: #073c4b; box-shadow: 0 0 5px 4px #52fefe, 0 0 6px 2px #52fefe inset;&#125;.container .box4 &#123; width: 120px; height: 120px; border: 1px solid #52fefe; background-color: #fff; box-shadow: 0 0 2px 1px #52fefe, 0 0 10px 5px #52fefe inset;&#125;.container .box5 &#123; width: 70px; height: 70px; border: 5px solid #1b4e5f; box-shadow: 0 0 7px 5px #52fefe, 0 0 10px 10px #52fefe inset;&#125;.container .box6 &#123; position: relative; width: 100%; height: 100%; /* 动画 名称 时长 linear 是匀速运动 infinite是无限次播放 */ animation: rotate 3s linear infinite;&#125;.container .box6 .coil &#123; position: absolute; width: 30px; height: 20px; /* calc方法自动计算位移距离 */ top: calc(50% - 110px); left: calc(50% - 15px); background-color: #073c4b; box-shadow: 0 0 5px #52fefe inset; /* calc方法自动计算数值 var函数调用了我们刚刚给元素定义的--i属性值 然后分别乘以45度 算出各自的度数 */ transform: rotate(calc(var(--i) * 45deg)); /* 这个是旋转的中心 */ transform-origin: center 110px;&#125;/* 定义一下旋转动画 */@keyframes rotate &#123; 0% &#123; transform: rotate(0); &#125; 100% &#123; transform: rotate(360deg); &#125;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container circle&quot;&gt; &lt;div class=&quot;box1 circle center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2 circle center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3 circle center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4 circle center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5 circle center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box6 circle&quot;&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 0&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 5&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 6&quot;&gt;&lt;/div&gt; &lt;div class=&quot;coil&quot; style=&quot;--i: 7&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 重新部署即可","categories":[{"name":"Guidance","slug":"Guidance","permalink":"https://cheeseburgerim.github.io/categories/Guidance/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://cheeseburgerim.github.io/tags/Hexo/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"Guidance","slug":"Guidance","permalink":"https://cheeseburgerim.github.io/tags/Guidance/"}]},{"title":"Chapter3 程序的机器级表示","slug":"DUOCS-Chapter3","date":"2021-02-11T08:50:41.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/02/11/DUOCS-Chapter3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/11/DUOCS-Chapter3/","excerpt":"","text":"历史观点程序编码数据格式访问信息算术和逻辑操作控制过程数组分配和访问异类的数据结构对齐(alignment)综合：理解指针实现生活：使用GDB调试器存储器的越界引用和缓冲区溢出浮点代码在C程序中嵌入汇编代码小结","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/tags/Postgraduate/"}]},{"title":"Chapter2 信息的表示和处理","slug":"DUOCS-Chapter2","date":"2021-02-09T02:58:18.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/02/09/DUOCS-Chapter2/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/09/DUOCS-Chapter2/","excerpt":"","text":"现代计算机存储和处理以二值信号表示的信息。这些普通的二进制数字，或者位(bit)，形成了数字革命的基础。大家熟悉地使用了1000多年的十进制(以10为基数，base-10)起源于印度，在12世纪被阿拉伯数学家所改进，并在13世纪被意大利数学家Leonardo Pisano(更有名的叫法是Fibonacci)带到西方。使用十进制表示法对于有十个手指头的人类来说是很自然的事情，但是当构造存储和处理信息的机器时，二进制值工作得更好。二值信号能够很容易地表示、存储和传输，例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者磁场引起的顺时针或逆时针。基于二值信号的存储和执行计算的电子电路非常简单和可靠，使得制造商能够在一个单独的硅片上集成百万个这样的电路； 单独地来说，单个的位不是非常有用。然而，当我们把位组合在一起，再加上某种解释(interpretation)，即给予不同的可能位模式以含义，我们就能够表示任何有限集合的元素。比如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的字符码，我们能够对一份文档中的字母和符号进行编码； 我们考虑三中最重要的数字编码。无符号(unsigned)编码是基于传统的二进制表示法的，表示大于或等于零的数字。二进制编码(two’s-complement)编码是表示有符号整数的最常见的方式，有符号整数就是为正或者为负的数字。浮点数(floating-point)编码是表示实数的科学计数法的以二为基数的版本。计算机用这些不同的表示方法实现算术运算，例如加法和乘法，类似于相应的整数和实数运算； 计算机的表示法用有限的位数来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会溢出(overflow)。这会导致某些令人吃惊的后果。例如，在大多数今天的计算机上，计算表达式200×300×400×500会得出-884,901,888。这违背了整数运算的属性——计算一组正数的乘积产生了一个为负的结果； 另一方面，整数的计算机运算满足了真正整数运算的许多普通的属性。例如，乘法是可结合的和可交换的，这样一来计算下面任何一个C表达式，都会得出884,901,888 (500×400)×(300×200) ((500×400)×300)×200 ((200×500)×300)×400 400×(200×(300×500)) 计算机可能没有产生这个预期的结果，但至少它是一致的！ 浮点运算有完全不同的数学属性。但是溢出会产生特殊的值+∞，但是一组正数的乘积总是正的。另一方面，由于表示的精度有限，浮点运算时不可结合的。例如，在大多数机器上，C表达式(3.14+1e20)-1e20求得的值会是0.0，而3.14+(1e20-1e20)求得的值会是3.14； 通过研究实际数字的表示，我们能够了解可以表示的值得范围和不同运算的属性。对于编写在全部数值范围内都能正常工作，而且可以跨越不同机器、操作系统和编译器组合的可移植的程序来说，这种了解是非常重要的； 计算机用几种不同的二进制表示来编码数值； 通过直接操作位级的数字表示，我们得到了几种进行算术运算的方式。理解这些技术对于理解编译算术表达式时产生的机器级代码是很重要的； 对这些内容的处理是非常精确的。我们从编码的基本定义开始，然后得出一些属性，例如可表示的数字的范围、它们的位级表示以及算术运算的属性。从这样一个抽象的观点来分析这些内容是很重要的，因为程序员需要对计算机运算和更为人熟悉的整数和实数运算之间的关系有牢固的理解。尽管这看起来很吓人，但精确的处理只需要了解基本的代数知识； C++编程语言建立在C之上，使用完全相同的数字表示和运算。以下关于C的所有内容对C++都有效。另一方面，Java语言创造了一套新的数字表示和运算标准。C标准被设计为允许多种实现方式，而Java标准在数据的格式和编码上是详细而精确的。 信息存储 大多数计算机使用8位的块，或叫做字节(byte)，来作为最小的可寻址的存储器单位，而不是访问存储器中单独的位。机器级程序将存储器视为一个非常大的字节数组，称为虚拟存储器(virtual memory)。存储器的每个字节都由一个唯一的数字来标识，称为它的地址(address)，所有可能地址的集合就称为虚拟地址空间(virtual address space)。正如它的名字表明的，这个虚拟地址空间只是一个展现给机器程序的概念性映像(image)。实际的实现使用的是随机访问存储器RAM、磁盘存储、特殊硬件和操作系统软件的结合，来为程序提供一个看上去统一的字节数组； 编译器和运行时系统的一个任务就是将这个存储器空间划分为更可管理的单元，来存放不同的程序对象(program object)，也就是，程序数据、指令和控制信息。有各种机制可以用来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。例如，C中一个指针的值(无论它指向一个整数、一个结构或是某个其他程序单元)都是某个存储块的第一个字节的虚拟地址。C编译器还把每个指针和类型信息联系起来，这样它就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管C的编译器维护着这个类型信息，但是它1生成的实际机器级程序并没有关于数据类型的信息。它简单地把每个程序对象视为一个字节块，而程序本身看做一个字节序列； 给C语言初学者：C中指针的角色 指针是C的一个重要特性，它提供了引用数据结构的元素(包括数组)的机制。就像一个变量，指针也有两个方面：它的值和它的类型，它的值表示的是某个对象的位置，而它的类型表示那个位置上所存储对象的类型(比如，整数或者浮点数)。 十六进制表示法 一个字节包括8位。在二进制表示法中，它的值域是000000002111111112。如果看成十进制整数，它的值域就是01025510。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而使用十进制表示法，与位模式的相互转化很麻烦。替代的方法是，我们以16为基数，或者叫做十六进制(hexadecimal)数，来书写位模式。十六进制(简写“Hex”)使用数字”0”“9”，以及字符“A”“F”来表示16个可能的值。下表展示了16个十六进制数字对应的十进制值和二进制值 十六进制数字 0 1 2 3 4 5 6 7 十进制值 0 1 2 3 4 5 6 7 二进制值 0000 0001 0010 0011 0100 0101 0110 0111 十六进制数字 8 9 A B C D E F 十进制值 8 9 10 11 12 13 14 15 二进制值 1000 1001 1010 1011 1100 1101 1110 1111 在C中，以0x或0X开头的数字常量被认为是十六进制的值。字符“A”~“F”既可以是大写，也可以是小写。例如，我们可以将数字FA1D37B16写作0xFA1D37B或者0xfa1d37b，甚至是大小写混合，比如0xFa1D37b； 编写机器级程序的一个常见任务就是手工地在位模式的十进制、二进制和十六进制表示之间转换。二进制和十六进制之间的转换是简单直接的，因为可以一次执行一个十六进制数字的转换。数字的转换可以参考上表。 字 每台计算机都有一个字长(word size)，指明整数和指针数据的标称大小(nominal size)。因为虚拟地址是以这样的字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为n位的机器而言，虚拟地址的范围为0~2n-1，程序最多访问2n字节； 今天大多数计算机的字长都是32位。这就限制了虚拟地址空间为4千兆字节(写作4GB)，也就是说，刚刚超过4×109字节。虽然对大多数应用而言，这个空间足够大了，但是现在已经有许多大型的科学和数据库应用需要更大的存储了。因此，随着存储器价格的降低，字长为64位的高端机器正逐渐变得普遍起来。 数据大小 计算机和编译器使用不同的方式来编码数字，比如不同长度的整数和浮点数，从而支持多种数字格式。比如，许多机器都有处理单个字节的指令，也有处理表示为两字节、四字节或者八字节整数的指令，还有些指令表示为四字节和八字节的浮点数； C语言支持整数和浮点数的多种数据格式。C的数据类型char表示一个单独的字节。尽管“char”这个名字是由于它被用来存储文本串中的单个字符这一事实而来的，但它也能被用来存储整数值。C的数据类型int之前还能加上限定词long和short，提供各种大小的整数表示。下表展示了为各种C数据类型分配的字节数 C声明 典型的32位机器 Compaq Qlpha机器 char 1 1 short int 2 2 int 4 4 long int 4 8 char * 4 8 float 4 4 double 8 8 准确的字节数依赖于机器和编译器。我们展示了两个有代表性的例子：典型的32位机器和Compaq Alpha体系结构，其中Compaq Alpha是针对高端应用的64位机器，大多数32位机器使用“典型”的分配方式。可以观察到，“短”整数分配有两字节，而不加限制的int为四字节，“长”整数使用机器的全字长； 上表也说明了指针(例如，一个被声明为类型为“char *”的变量)使用机器的全字长。大多数机器还支持两种不同的浮点格式：单精度(在C中声明为float)和双精度(在C中声明为double)。这些格式分别使用四字节和八字节； 程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。C标准对不同数据类型的数字范围设置了下界，但是却没有上界。因为32位机器在过去20年里一直是标准，许多程序的编写都是以上表中“典型的32位机器”列出的分配原则为假设的。在不久的将来，随着64位机器越来越重要，在将这些程序移植到新机器上时，许多隐藏的对字长的依赖就会呈现出来，成为错误。比如，许多程序员假设一个声明为int类型的程序对象能被用来存储一个指针。这在大多数32位的机器上工作正常，但是在一台Alpha机器上却会导致问题。 寻址和字节顺序 对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么和我们在存储器中如何对这些字节排序。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节序列中最小的地址。例如，假设一个类型为int的变量x的地址为0x100，也就是说，地址表达式&amp;x的值为0x100.那么，x的四字节将被存储在存储器的0x100、0x101、0x102和0x103位置； 对表示一个对象的字节序列排序，有两个通用的规则。考虑一个w位的整数，有位表示[xw-1,xw-2,…,x1,x0]，其中xw-1是最高有效位，而x0是最低有效位。假设w是8的倍数，这些位就能被分组成为字节，其中最高有效字节包含位[xw-1,xw-2,…,xw-8]，而最低有效字节包含位[x7,x6,…,x0]，其他字节包含中间的位。某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则——最低有效字节在最前面的方式称为**小端法(little endian)。大多数源自以前的Digital Equipment公司(现在是Compaq公司的一部分)的机器，以及Intel的机器都采用这种规则。后一种规则——最高有效字节在最前面的方式称为大端法(big endian)**。IBM、Motorola和Sun Microsystem的大多数机器都采用这种规则。注意我们说的是“大多数”。这些规则并没有严格按照企业界限来划分。比如，IBM制造的个人计算机使用的是Intel兼容的处理器，因此就是小端法。许多微处理器芯片，包括Alpha和Motorola和PowerPC，能够运行在任一种模式中，其取决于芯片加电启动时确定的字节顺序规则； 继续我们前面的示例，假设变量x类型为int，位于地址0x100处，有一个十六进制值为0x01234567.地址范围0x100~0x103的字节顺序依赖于机器的类型 大端法 0x100 0x101 0x102 0x103 … 01 23 45 67 … 小端法 0x100 0x101 0x102 0x103 … 67 45 23 01 … 注意，在字0x01234567中，高位字节的十六进制值为0x01，而低位字节值为0x67； 令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上，术语”little endian(小端)”和”big endian(大端)”来自于Jonathan Swift的《格利弗游记(Gulliver’s Travels)》，其中交战的两个派别无法就应该从哪一端——小端还是大端——打开一个半熟的鸡蛋达成一致。就像鸡蛋的问题一样，没有技术原因来选择字节顺序规则，因此争论退化成为关于社会政治论题的口角。对于哪种字节排序的选择是任意的； 对于大多数应用程序员来说，他们机器的字节顺序是完全不可见的。无论为哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题，首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反之时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示； 字节顺序变得重要的第二种情况是当阅读表示整数数据的字节序列时。这通常发生在检查机器级程序时。作为一个示例，从某个文件中摘出了下面这行代码，该文件给出了一个针对Intel处理器的机器级代码的文本表示 180483bd：01 05 64 94 04 08 add %eax，0x8049464 这一行是由反汇编器(disassembler)生成的，反汇编器是一种确定可执行程序文件所表示的指令序列的工具。现在，我们只是注意这行表述了十六进制字节串01 05 64 94 04 08是一条指令的字节级表示，这条指令是增加一个字宽的数据到存储在主存地址0x8049464的值上，如果我们取出这个序列的最后四字节：64 94 04 08，并且按照相反的顺序写出，我们得到08 04 94 64，去掉开头的零，我们就得到值0x8049464，就是右边写着的数值。当阅读像此例中一样的小端法机器生成的机器级程序表示时，经尝会将字节按照相反的顺序显示。书写字节序列的自然方式是最低位字节在左边，而最高位字节在右边，但是这和书写数字时最高有效位在左边，最低有效位在右边的通常方式是相反的； 字节顺序变得可见的第三种情况是当编写规避正常的类型系统的程序时。在C语言中，可以通过使用**强制类型转换(cast)**来允许以一种不同于它被创造时的数据类型来引用一个对象。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必须的； 下面展示了一段C代码 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;typedef unsigned char *byte_pointer;void show_bytes(byte_pointer start,int len)&#123; int i; for(i=0;i&lt;len;i++) printf(&quot;%.2x&quot;,start[i]); printf(&quot;\\n&quot;);&#125;void show_int(int x)&#123; show_bytes((byte_pointer)&amp;x,sizeof(int));&#125;void show_float(float x)&#123; show_bytes((byte_pointer)&amp;x,sizeof(float));&#125;void show_pointer(void *x)&#123; show_bytes((byte_pointer)&amp;x,sizeof(void *));&#125; 它使用强制类型转换来访问和打印不同程序对象的字节表示。 整数表示整数运算浮点小结","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/tags/Postgraduate/"}]},{"title":"Chapter1 计算机系统漫游","slug":"DUOCS-Chapter1","date":"2021-02-03T08:28:40.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/02/03/DUOCS-Chapter1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/03/DUOCS-Chapter1/","excerpt":"","text":"信息就是位+上下文1234567//Programm hello#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello,world\\n&quot;); return 0;&#125; 我们的hello程序的生命是从一个源程序(或者说源文件)开始的，该源程序由程序员通过编辑器创建并保存为文本文件，文件名就是hello.c，源程序实际上就是一个由0和1组成的位(又称为比特)序列，这些位被组织成8个一组，称为字节。每个字节都表示程序中某个文本字符； 大部分的现代系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的字节大小的整数值来表示每个字符； 比如，hello.c程序是以字节序列的方式存储在文件中的。每个字节都有一个整数值，对应于某个字符。例如，第一个字节的整数值是35，它对应的就是字符”#”。第二个字节整数值为105，它对应的字符是”i”，以此类推； 注意，每行文本都是以一个看不见的换行符”\\n”来结束的，它所对应的整数值为10。像hello.c这样只由ASCII字符构成的文件称为文本文件，所有其他文件则称为二进制文件； hello.c的表示方法说明了一个基本的思想：系统中所有的信息——包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由一串比特表示的； 区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令； 作为程序员，我们需要了解数字的机器表示方式，因为它们与常见的整数和实数是不同的。它们有些相似，但这种相似并不为人知。 程序被其他程序翻译成不同的格式 在hello程序生命周期的一开始时是一个高级C程序，因为当处于这种形式时，它是能够被人读懂的。然而，为了在系统上运行hello.c程序。每条C语句必须被其他程序转化为一系列的低级机器语言指令，然后这些指令按照一种称为可执行目标程序(executable object program)的格式打好包，并以二进制磁盘文件的形式存放起来，目标程序也成为可执行目标文件(executable object file)； 在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序(complier driver)完成的 1unix&gt; gcc -o hello hello.c 在这里，gcc编译器驱动程序读取源文件hello.c，并把它翻译成一个可执行目标文件hello，这个翻译的过程是分为四个阶段完成的，如下所示 执行这四个阶段的程序(预处理器、编译器、汇编器和链接器)一起构成了编译系统 预处理阶段：预处理器(cpp)根据以字符#开头的命令(directives)，修改原始的C程序。比如hello.c中第一行的#include &lt;stdio.h&gt;指令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入到程序文本中去。结果就得到了另一个C程序，通常是以.i作为文件扩展名； 编译阶段：编译器(ccl)将文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言； 汇编阶段：接下来，汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成为一种叫做可重定位(relocatable)目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它的字节编码是机器语言指令而不是字符。如果我们在文本编辑器中打开hello.o文件，呈现的是一对乱码； 链接阶段：请注意，我们的hello程序调用了printf函数，它是标准C库中的一个函数，每个C编译器都提供，printf函数存在于一个名为printf.o的单独的预编译目标文件中，而这个文件必须以某种方式并入到我们的hello.o程序中。链接器(id)就负责处理这种并入，结果就得到hello文件，它是一个可执行目标文件(或者简称为可执行文件)。可执行文件加载到存储器后，由系统负责执行。 了解编译系统如何工作是大有益处的​ 对于像hello.c这样简单的程序，我们可以依靠编译系统生成正确有效的机器代码，但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。 优化程序性能。现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在我们的C程序中做出好的代码选择，我们确实需要对汇编语言以及编译器如何将不同的C语句转化为汇编语言有一些基本的了解。比如，一个switch语句是不是总比一系列的if-then-else语句高效得多？一个函数调用的代价有多大？while循环比do循环更有效吗？指针引用比数组索引更有效吗？相对于通过引用传递过来得参数求和，为什么用本地变量求和得循环，其运行就会快得多呢？为什么两个功能相近得循环的运行时间会有很大差异？ 理解链接时出现的错误。根据我们的经验，一些最令人困扰得程序错误往往都与链接器操作有关，尤其是当你试图建立大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？如果你在不同的C文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？为什么我们在命令行上排列库的顺序是有影响的？最为烦人的是，为什么有些链接错误直到运行时才出现？ 避免安全漏洞，近年来，缓冲区溢出错误造成了大多数网络和Internet服务器上的安全漏洞。这些错误的存在是因为太多的程序员忽视了编译器用来为函数产生代码的堆栈规则。 处理器读并解释储存在存储器中的指令​ 此刻，我们的hello.c源程序已经被编译系统转换成了可执行目标文件hello，并被存放在磁盘上。为了在Unix系统上运行该可执行文件，我们将它的文件名输入到称为shell的应用程序中： 123unix&gt; ./hellohello, worldunix&gt; ​ shell是一种命令行解释器，它输出一个提示符，等待你输入一行命令，然后执行这个命令。如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，要加载和执行该文件。所以在此例中，shell将加载和执行hello程序，然后等待程序终止。hello程序在屏幕上输出它的信息，然后终止。shell随后输出一个提示符，等待下一个输入的命令行。 系统的硬件组成​ 为了了解运行时hello程序发生了什么，我们需要理解一个典型系统的硬件组织，如下图所示 CPU：中央处理单元； ALU：算术/逻辑单元； PC：程序计数器； USB：通用串行总线 总线 贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字(word)，字中的字节数(即字长)是一个基本的系统参数，各个系统中也不尽相同。比如，Intel Pentium系统的字长为4字节，而服务器类的系统，例如Intel Itaniums和高端的Sun公司的SPARCS的字长为8字节。用于汽车和工业中的嵌入式控制器之类较小的系统的字长往往只有1或2字节。为了便于描述，我们假设字长为4字节，并且假设总线一次只传一个字。 I/O设备 I/O(输入/输出)设备是系统与外界的联系通道。我们的示例系统包括四个I/O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器(简单地说就是磁盘)。最开始，可执行程序hello就放在磁盘上； 每个I/O设备都是通过一个控制器或适配器与I/O总线连接起来的。控制器和适配器之间的区别主要在于它们的组成方式。控制器是I/O设备本身中或是系统的主印制电路板(通常被称作主板)上的芯片组，而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。 主存 主存是一个临时存储设备，在处理器执行程序时，它被用来存放程序和程序处理的数据。物理上来说，主存是由一组DRAM(动态随机存取储存器)芯片组成的，。逻辑上来说，存储器是由一个线性的字节数组组成的，每个字节都有自己唯一的地址(数组索引)，这些地址是从零开始的。一般来说，组成程序的每条机器指令都有不定量的字节构成。与C程序变量相对应的数据项的大小是根据类型变化的。比如，在运行Linux的Intel机器上，short类型的数据需要2字节，int、float和long类型则需要4字节，而double类型需要8字节； 处理器 中央处理单元(CPU)简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个被称为程序计数器(PC)的字长大小的存储设备(或寄存器)。在任何一个时间点上，PC都指向主存中的某条机器语言指令(内含其地址)； 从系统通电开始，直到系统断电，处理器一直在不假思索地重复执行相同的基本任务：从程序计数器(PC)指向地存储器处读取指令，解释指令中的位，执行指令指示的简单操作，然后更新程序计数器指向下一条指令，而这条指令并不一定在存储器中和刚刚执行的指令相邻； 这样的简单操作的数目并不多，它们在主存、寄存器文件(register file)和算数逻辑单元(ALU)之间循环。寄存器文件是一个小的存储设备，由一些字长大小的寄存器组成，这些寄存器每个都有唯一的名字。ALU计算新的数据和地址值。下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作 加载：从主存拷贝一个字节或者一个字到寄存器，覆盖寄存器原来的内容； 存储：从寄存器拷贝一个字节或者一个字到主存的某个位置，覆盖这个位置上原来的内容； 更新：拷贝两个寄存器的内容到ALU，ALU将两个字相加，并将结果存放到一个寄存器中，覆盖该寄存器中原来的内容； I/O读：从一个I/O设备中拷贝一个字节或者一个字到一个寄存器； I/O写：从一个寄存器中拷贝一个字节或者一个字到一个I/O设备； 转移：从指令本身抽取一个字，并将这个字拷贝到程序计数器(PC)中，覆盖PC中原来的值。 运行hello程序 通过对系统的硬件组成和操作的简单学习，我们开始能够了解当我们运行示例程序时发生了什么。在这里我们必须忽略很多细节，稍后会做一些补充，但是现在我们将很满意这种粗略的描述。 首先，shell程序执行它的指令，等待我们输入命令。当我们在键盘上输入字符串“./hello”后，shell程序就逐一读取字符到寄存器，再把它放到存储器中，如下图所示 当我们在键盘上敲回车键时，shell就知道我们已经结束了命令的输入。然后shell执行一系列指令。这些指令将hello目标文件中的代码和数据从磁盘拷贝到主存，从而加载hello文件。数据包括最终会被输出的字符串“hello，world\\n”。 利用称为DMA(直接存储器存取)的技术，数据可以不通过处理器而直接从磁盘到达主存，这个步骤如下图所示 一旦hello目标文件中的代码和数据被加载到了存储器，处理器就开始执行hello程序的主程序中的机器语言指令，这些指令将“hello，world\\n”串中的字节从存储器中拷贝到寄存器文件，再从寄存器中文件拷贝到显示设备，最终显示在屏幕上，这个步骤如下图所示 高速缓存 通过这个简单的示例我们了解到重要的一课，那就是系统花费了大量时间把信息从一个地方挪到另一个地方。hello程序的机器指令最初是存放在磁盘上的。当程序加载时，它们被拷贝到主存，当处理器运行程序时，指令又从主存拷贝到处理器。相似地，数据串“hello，world\\n”开始时在磁盘上，再被拷贝到主存，然后从主存上拷贝到显示设备。从一个程序员的角度来看，大量的拷贝减慢了程序的实际工作。因此，系统设计者的一个主要目标就是使这些拷贝操作尽可能的快； 根据机械原理，较大的存储设备要比较小的存储设备运行德慢，而快速设备的造价远高于低俗设备。比如说，一个典型系统上的磁盘驱动器可能比主存大100倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大1000万倍； 类似地，一个典型的寄存器文件只存储几百字节的信息。与此相反，主存里可存放几百万字节。然而，处理器从寄存器文件中读数据比从主存中读取快几乎100倍。更麻烦的是，随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。加快处理器的运行速度比加快主存的处理速度要容易和便宜得多； 针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器(cache memories，简称高速缓存)，它们被用来作为暂时的集结区域，存放处理器在不久的将来可能会需要的信息。下图展示了一个典型系统中的高速缓存存储器 形成层次结构的存储设备 在处理器和一个较大较慢的设备(例如主存)之间插入一个更小更快的存储设备(例如高速缓存)的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成立一个存储器层次结构，如下图所示 在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是0级或记为L0。这里我们展示的是三层高速缓存L1到L3，占据存储器层次结构的第1层到第3层。主存在第4层，以此类推； 存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是L1的高速缓存，L1是L2的高速缓存，L2是L3的高速缓存，L3是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存； 正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个储存器层次结构的理解来提高程序性能。 操作系统管理硬件 让我们回到hello程序的例子。当shell加载和运行hello程序时，以及hello程序输出自己的消息时，shell和hello程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是，它们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，如下图所示 所有应用程序对硬件的操作尝试都必须通过操作系统； 操作系统有两个基本功能：防止硬件被失控的应用程序滥用；在控制复杂而又通常广泛不同的低级硬件设备方面，为应用程序提供简单一致的方法。操作系统通过下图中显示的几个基本的抽象概念(进程、虚拟存储器和文件)实现这两个功能 如上图所示，文件是对I/O设备的抽象表示，虚拟存储器是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。 进程 像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去独占地使用处理器、主存和I/O设备，而处理器看上去就像在不间断地一条接一条地执行程序中的指令。该程序都代码和数据就好像是系统存储器中唯一地对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一； 进程是操作系统对运行程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像独占地使用硬件。我们称之为并发运行，实际上是说一个进程的指令和另一个进程的指令时交错执行的。操作系统实现这种交错执行的机制称为上下文切换(context switching)； 操作系统保存进程运行所需的所有状态信息。这种状态，也就是上下文(context)，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，系统上都只有一个进程正在运行。当操作系统决定从当前进程转移控制权到某个新进程时，它就会进行上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权转移到新进程。新进程就会从它上次停止的地方开始。下图展示了我们的示例hello运行的基本场景 在我们的示例场景中有连个同时运行的进程：shell进程和hello进程。最开始，只有shell进程在运行，等待命令行上的输入。当我们让它运行hello程序时，shell通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及上下文，然后将控制权传给新的hello进程。在hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给它，它会继续等待下一命令行输入； 实现进程这个抽象概念需要低级硬件和操作系统软件的紧密合作。进程这个抽象的概念还暗示着由于不同的进程交错执行，打乱了时间的概念，使得程序员很难获得运行时间的准确和可重复测量。在现代系统中，拥有各种时间的概念以及用来获得准确测量值的技术。 线程 尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据； 由于网络服务器中对并行处理的要求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般都比进程更高效。 虚拟存储器 虚拟存储器是一个抽象概念，它为每个进程提供了一个假象，好像每个进程都在独占地使用主存。每个进程看到的存储器都是一致的，称之为虚拟地址空间。下图所示的时=是Linux进程的虚拟地址空间(其他Unix系统的设计也与此类似) 在Linux中，最上面的四分之一的地址空间是预留给操作系统中的代码和数据的，这对所有进程都一样。底部的四分之三的地址空间用来存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的； 每个进程看到的虚拟地址空间由大量准确定义的区(area)构成，每个区都有专门的功能。从最低的地址开始，逐步向上研究将是非常有益的 程序代码和数据：代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据区。代码和数据区是由可执行目标文件直接初始化的。在我们的示例中就是可执行文件hello； 堆：代码和数据区后紧跟随着的是运行时堆。代码和数据区是在进程一旦开始运行时就被指定了大小的，与此不同。作为调用像malloc和free这样的C标准库函数的结果，堆可以在运行时动态地扩展和收缩； 共享库：在地址空间的中间附近是一块用来存放像C标准库和数学库这样共享库的代码和数据的区域。共享库的概念非常强大，但是也是个相当难懂的概念； 栈：位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长。每次我们从函数返回时，栈就会收缩； 内核虚拟存储器：内核是操作系统总是驻留在存储器中的部分。地址空间顶部的四分之一部分是为内核预留的。应用程序不允许读写这个区域的内容或者直接调用内核代码定义的函数。 虚拟存储器的运作需要硬件和操作系统软件间的精密复杂的相互合作，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟存储器的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。 文件 文件只不过就是字节序列。每个I/O设备，包括磁盘、键盘、显示器，甚至于网络，都可以被看成是文件。系统中的所有输入输出都是通过使用称为UnixI/O的一小组系统函数调用读写文件来实现的； 文件这个简单而精致的概念是非常强大的，因为它使得应用程序能够统一地看待系统中可能含有的所有各式各样的I/O设备。例如，处理磁盘文件内容的应用程序员可以非常幸福地无需了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。 利用网络系统和其它系统通信 系统漫游行之至此，我们一直是把系统视为一个孤立地硬件和软件的集合体。实际上，现代系统经常是通过网络和其他系统连接到一起的。从一个单独的系统来看，网络可视为又一个I/O设备，如下图所示 当系统从主存拷贝一串字符到网络适配器时，数据流经过网络到达另一台机器，而不是到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据拷贝到自己的主存； 随着像Internet这样的全球网络的出现，从一台主机拷贝信息到另外一台主机已经成为计算机系统最重要的用途之一。比如，像电子邮件、即时消息传送、万维网、FTP和telnet这样的应用都是基于网络拷贝信息的功能的； 回到我们hello示例，我们可以使用熟悉的telnet应用在一个远程主机上运行hello程序。假设我们用本地主机上的telnet服务器。在我们登录到远程主机并运行shell后，远端的shell就在等待接收输入的命令。从这点上来看，在远端运行hello程序包括下图的五个基本步骤 当我们在客户端键入“hello”串并敲下回车键后，客户端软件就会将这个字符串发送到telnet的服务器。在telnet服务器从网络上接收到这个串后，会把它传递给远端shell程序，接下来，远端shell运行hello程序，并将输出返回给telnet服务器。最后，telnet服务器通过网络把输出串转发给telnet客户端，客户端就将输出串输出到我们的本地终端上； 这种在客户端和服务器之间交互的类型在所有的网络应用中是非常典型的。 下一步 我们旋风式的系统漫游到此就结束了。从这次讨论中要得出一个很重要的观点，那就是系统不仅仅是硬件。系统是相互交织的硬件和系统软件的集合体，他们必须共同协作以达到运行应用程序的最终目的。 小结 计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据不同的上下文又有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ASCII文本，然后被编译器和链接器翻译成二进制可执行文件； 处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在存储器、I/O设备和CPU寄存器之间拷贝数据，所以系统中的存储设备就被按层次排列，CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存储器和磁盘存储器。在层次模型中位于更高层的存储设备比低层的存储设备要快，单位比特造假也更高，程序员通过理解和运用这种存储层次结构的知识，可以优化他们C程序的性能； 操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象概念： 文件时对I/O设备的抽象概念 虚拟存储器是对主存和磁盘的抽象概念 进程是处理器、主存和I/O设备的抽象概念 最后，网络提供了计算机系统之间通信的手短。从某个系统的角度看，网络就是一种I/O设备。","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/tags/Postgraduate/"}]},{"title":"PTA","slug":"PTA","date":"2021-02-02T12:22:06.000Z","updated":"2021-04-11T04:26:34.099Z","comments":false,"path":"2021/02/02/PTA/","link":"","permalink":"https://cheeseburgerim.github.io/2021/02/02/PTA/","excerpt":"","text":"PTA 基础编程题目集7-23 币值转换From here Question：输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“cWdQbBai”元。 Input Format：输入在一行中给出一个不超过9位的非负整数。 Output Format：在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void Transform(string m,int l);int main()&#123; string money; while(cin&gt;&gt;money) &#123; int l=money.length(); Transform(money,l); &#125; system(&quot;pause&quot;); return 0;&#125;void Transform(string m,int l)&#123; char str[10]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;&#125;; // 0 1 2 3 4 5 6 7 8 9 //012345678 //813227345 if(l==9) &#123; cout&lt;&lt;str[m[0]-48]&lt;&lt;&quot;Y&quot;; for(int i=1;i&lt;l-4;i++) &#123; cout&lt;&lt;str[m[i]-48]; if(l-i-4==4&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;Q&quot;; if(l-i-4==3&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;B&quot;; if(l-i-4==2&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;S&quot;; &#125; //cout&lt;&lt;&quot;W&quot;; if(m[1]==48&amp;&amp;m[2]==48&amp;&amp;m[3]==48&amp;&amp;m[4]==48); else cout&lt;&lt;&quot;W&quot;; for(int i=l-4;i&lt;l;i++) &#123; cout&lt;&lt;str[m[i]-48]; if(l-i==4&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;Q&quot;; if(l-i==3&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;B&quot;; if(l-i==2&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;S&quot;; &#125; cout&lt;&lt;endl; &#125; else if(l&lt;9&amp;&amp;l&gt;=5) &#123; bool isZero=0; for(int i=0;i&lt;l-4;i++) &#123; bool isEnd=1; for(int j=i;j&lt;l-4;j++) &#123; if(m[j]!=48) &#123; isEnd=0; break; &#125; &#125; if(isEnd) break; if(m[i]!=48) isZero=0; if(isZero) continue; cout&lt;&lt;str[m[i]-48]; if(i&gt;0&amp;&amp;m[i]-48==0) &#123; isZero=1; continue; &#125; if(l-i-4==4) cout&lt;&lt;&quot;Q&quot;; if(l-i-4==3&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;B&quot;; if(l-i-4==2&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;S&quot;; &#125; cout&lt;&lt;&quot;W&quot;; isZero=0; for(int i=l-4;i&lt;l;i++) &#123; bool isEnd=1; for(int j=i;j&lt;l;j++) &#123; if(m[j]!=48) &#123; isEnd=0; break; &#125; &#125; if(isEnd) break; if(m[i]!=48) isZero=0; if(isZero) continue; cout&lt;&lt;str[m[i]-48]; if(i&gt;0&amp;&amp;m[i]-48==0) &#123; isZero=1; continue; &#125; //if(i&gt;0&amp;&amp;m[i]-48==0) if(l-i==4&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;Q&quot;; if(l-i==3&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;B&quot;; if(l-i==2&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;S&quot;; &#125; cout&lt;&lt;endl; &#125; else//l&lt;5 &#123; if(l==1) cout&lt;&lt;str[m[0]-48]; bool isZero=0; for(int i=0;i&lt;l;i++) &#123; bool isEnd=1; for(int j=i;j&lt;l;j++) &#123; if(m[j]!=48) &#123; isEnd=0; break; &#125; &#125; if(isEnd) break; if(m[i]!=48) isZero=0; if(isZero) continue; cout&lt;&lt;str[m[i]-48]; if(i&gt;0&amp;&amp;m[i]-48==0) &#123; isZero=1; continue; &#125; if(l-i==4) cout&lt;&lt;&quot;Q&quot;; if(l-i==3&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;B&quot;; if(l-i==2&amp;&amp;m[i]-48!=0) cout&lt;&lt;&quot;S&quot;; &#125; cout&lt;&lt;endl; &#125;&#125; 源码地址 7-24 约分最简分式From Here Question：分数可以表示为分子/分母的形式。编写一个程序，要求用户输入一个分数，然后将其约分为最简分式。最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8；而当分子分母相等时，仍然表达为1/1的分数形式。 Input Format：输入在一行中给出一个分数，分子和分母中间以斜杠/分隔，如：12/34表示34分之12。分子和分母都是正整数（不包含0，如果不清楚正整数的定义的话）。 提示：在scanf的格式字符串中加入/，让scanf来处理这个斜杠。 Output Format：在一行中输出这个分数对应的最简分式，格式与输入的相同，即采用分子/分母的形式表示分数。如 5/6表示6分之5。 Code 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int GCD(int s,int m);//Greatest Common Divisorint main()&#123; int son, mom; while (scanf(&quot;%d/%d&quot;, &amp;son, &amp;mom)) &#123; cout&lt;&lt;son/GCD(son,mom)&lt;&lt;&#x27;/&#x27;&lt;&lt;mom/GCD(son,mom)&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125;int GCD(int s,int m)&#123; if(s&lt;m) &#123; int temp=m; m=s; s=temp; &#125; int r=s%m; while(r!=0) &#123; s=m; m=r; r=s%m; &#125; return m;&#125; 源码地址 以上代码运行时超时，但没有找到原因，答案代码如下 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; int numerator,denominator,temp,a,b; char c; scanf(&quot;%d%c%d&quot;,&amp;numerator,&amp;c,&amp;denominator); a=numerator; b=denominator; while(b!=0)&#123; temp=a%b; a=b; b=temp; &#125; numerator/=a; denominator/=a; printf(&quot;%d/%d&quot;,numerator,denominator); system(&quot;pause&quot;); return 0;&#125; 源码地址","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"CodeExercise","slug":"CodeExercise","permalink":"https://cheeseburgerim.github.io/tags/CodeExercise/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"PTA","slug":"PTA","permalink":"https://cheeseburgerim.github.io/tags/PTA/"}]},{"title":"Marxism","slug":"Marxism","date":"2021-01-30T02:34:51.000Z","updated":"2021-04-11T04:26:34.100Z","comments":false,"path":"2021/01/30/Marxism/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/30/Marxism/","excerpt":"","text":"导论马克思主义基本原理构成 马克思注意哲学； 马克思主义政治经济学； 科学社会主义。 马克思主义的诞生 1848年《共产党宣言》标志着马克思注意的诞生。 马克思主义服务阶级与学说类别 马克思主义申明为无产阶级服务； 是关于人类解放的学说。 马克思主义理论来源 英国古典政治经济学； 德国古典哲学； 英法空想社会主义。 马克思一生两大发现 《唯物史观》和《剩余价值学说》分别在《德意志意识形态》和《资本论》中有充分阐述。 马克思主义理论特点 科学性； 革命性； 实践性； 人民性； 发展性。 世界的物质性及发展规律世界多样性与物质统一性马克思主义哲学的四部分内容 唯物主义； 辩证法； 认识论； 唯物史观。 哲学的基本问题思维和存在的关系问题 哲学派别划分标准一：思维和存在谁是本原 存在：唯物主义； 思维：唯心主义。 划分标准二：思维与存在是否统一/同一 是：可知论； 否：不可知论。 物质的特点物质的根本特点：客观实在性。 物质与感觉的关系物质不依赖于我们的感觉而存在，但可以被我们的感觉所复写，射影和反映。 Points高频词 特点； 本质； 关系。 人物 亚当斯密，《国富论》，分工 生产分工→经济增长； 康德，《纯粹理性批判》 人知道什么； 人应该知道什么； 人希望知道什么； 什么是人。 黑格尔，《逻辑学》，《精神现象学》","categories":[{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/categories/Postgraduate/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/tags/Postgraduate/"},{"name":"Marxism","slug":"Marxism","permalink":"https://cheeseburgerim.github.io/tags/Marxism/"}]},{"title":"Git Intro","slug":"GitIntro","date":"2021-01-27T05:25:12.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2021/01/27/GitIntro/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/27/GitIntro/","excerpt":"","text":"Git Intro Git教程 Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目； Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件； Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git安装Linux12345678//Ubuntu$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev$ apt-get install git$ git --versiongit version 1.8.1.2 Windows在官网下载即可 Git配置 Git提供了一个叫做git config的工具，专门用来配置或读取相应的工作环境变量； 可用于配置个人的用户名称和电子邮件地址 12$ git config --global user.name &quot;Your username&quot;$ git config --global user.email &quot;Your email&quot; 如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息; 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 Points 提交代码至远程仓库 git add . git commit -m “” git push","categories":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"Git","slug":"Git","permalink":"https://cheeseburgerim.github.io/tags/Git/"}]},{"title":"Rubik's Cube","slug":"RubikCube","date":"2021-01-26T10:40:14.000Z","updated":"2021-04-11T04:26:34.099Z","comments":false,"path":"2021/01/26/RubikCube/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/26/RubikCube/","excerpt":"","text":"Rubik's Cube 三阶教程 选择一个颜色拼成一面并作为底面； 完成从底面数第一行以及第二行中间的颜色； 在顶层做出十字 顶层棱中间块归位 顶层顶角半归位 完成","categories":[{"name":"Rubik'sCube","slug":"Rubik-sCube","permalink":"https://cheeseburgerim.github.io/categories/Rubik-sCube/"}],"tags":[{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"Fun","slug":"Fun","permalink":"https://cheeseburgerim.github.io/tags/Fun/"},{"name":"Rubik'sCube","slug":"Rubik-sCube","permalink":"https://cheeseburgerim.github.io/tags/Rubik-sCube/"}]},{"title":"C&C++","slug":"LanguageC","date":"2021-01-25T03:12:44.000Z","updated":"2021-04-11T04:26:34.100Z","comments":false,"path":"2021/01/25/LanguageC/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/25/LanguageC/","excerpt":"","text":"C&amp;C++Points 简易进制转换 C 123printf(&quot;%05o\\n&quot;,35); //按八进制格式输出，保留5位高位补零printf(&quot;%03d\\n&quot;,35); //按十进制格式输出，保留3位高位补零printf(&quot;%05x\\n&quot;,35); //按十六进制格式输出，保留5位高位补零 C++ 123456789101112#include &lt;bitset&gt; #include&lt;iostream&gt;using namespace std; int main() &#123; cout &lt;&lt; &quot;35的8进制:&quot; &lt;&lt; oct &lt;&lt; 35&lt;&lt; endl; cout &lt;&lt; &quot;35的10进制&quot; &lt;&lt; dec &lt;&lt; 35 &lt;&lt; endl; cout &lt;&lt; &quot;35的16进制:&quot; &lt;&lt; hex &lt;&lt; 35 &lt;&lt; endl; cout &lt;&lt; &quot;35的2进制: &quot; &lt;&lt; bitset&lt;8&gt;(35) &lt;&lt; endl; //&lt;8&gt;：表示保留8位输出 return 0; &#125; 保留X位小数/有效数字 123456789101112//C++#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; double a; cin&gt;&gt;a; cout&lt;&lt;setprecision(x)&lt;&lt;a&lt;&lt;endl;//保留x位有效数字 cout&lt;&lt;fixed&lt;&lt;setprecision(x)&lt;&lt;a&lt;&lt;endl;//保留x位小数 return 0;&#125; sort函数 12345678910111213141516171819202122//头文件#include &lt;algorithm&gt;void sort(start,end,cmp);/*start表示要排序数组的起始地址end表示数组结束地址的下一位cmp用于规定排序的方法，可不填，默认升序*///Example#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]=&#123;9,6,3,8,5,2,7,4,1,0&#125;; for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; sort(a,a+10);//指针 for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;&#125; 进制转换函数 itoa atoi strtol string类函数","categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"}]},{"title":"英雄联盟","slug":"LeagueOfLegends","date":"2021-01-21T02:05:24.000Z","updated":"2021-04-11T04:26:34.100Z","comments":false,"path":"2021/01/21/LeagueOfLegends/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/21/LeagueOfLegends/","excerpt":"","text":"League of LegendsRelated Websites Official Developer Championship Highlights 2021年第一个五杀 2021/2/6 赛娜第一个五杀 2021/2/7~2021/2/8 第一次上黄金 2021/2/12 男枪五杀 2021/2/25 赛娜五杀 Videos 更多视频请前往B站投稿以及英雄联盟个人收藏观看 Skins 2020/9/5 原计划：雷 卢锡安 2020/11/11 源计划：联合 艾希 2020/11/17 战斗学院 杰斯 202012/14 西部天使 赛娜 2020/12/18 IG 卡莎 2021/1/21 银河魔装机神 兰博 2021/2/9 龙的传人 李青 2021/2/27 弹幕天使 卡莎 2021/3/23 神龙烈焰 金克斯 大乱斗英雄 VN，金克斯，炸弹人，维鲁斯，大头，奎因，赛娜，莫甘娜，发条，男枪，风女，拉克丝，妖姬莉莉娅，寒冰，兰博，维克托，亚索，卡牌，豹女，小炮，乌鸦，女警，赏金，卢锡安，EZ，铁男，妮蔻，杰斯，老鼠，烬，小法，萨勒芬妮，大虫子，卡莎，大眼，飞机，梦魇，泽拉斯，轮子妈 排位英雄 赛娜 英雄购买顺序 萨勒芬妮，莉莉娅，大眼，烬泽拉斯，大虫子，乌鸦","categories":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"}],"tags":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"Fun","slug":"Fun","permalink":"https://cheeseburgerim.github.io/tags/Fun/"},{"name":"LOL","slug":"LOL","permalink":"https://cheeseburgerim.github.io/tags/LOL/"}]},{"title":"Clash Of Clans","slug":"ClashOfClans","date":"2021-01-20T02:57:57.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2021/01/20/ClashOfClans/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/20/ClashOfClans/","excerpt":"","text":"Clash of ClansRelated Websites Official Developer Tool ClanWorld","categories":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"}],"tags":[{"name":"COC","slug":"COC","permalink":"https://cheeseburgerim.github.io/tags/COC/"},{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"fun","slug":"fun","permalink":"https://cheeseburgerim.github.io/tags/fun/"}]},{"title":"Ragnarok","slug":"Ragnarok","date":"2021-01-15T03:32:34.000Z","updated":"2021-04-11T04:26:34.098Z","comments":false,"path":"2021/01/15/Ragnarok/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/15/Ragnarok/","excerpt":"","text":"RagnarokBackgroundJob Job Jewelry Jewelry EP 唤醒计划 樱之花嫁 宠物情人 永恒的爱 梦想天空 黑色派对 崭新时空 光影之都 甜蜜召唤师 龙之城洛阳 辉煌领域 Mentor凩 一只教会我很多的大佬 Related Websites Official Developer Tool","categories":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"}],"tags":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"fun","slug":"fun","permalink":"https://cheeseburgerim.github.io/tags/fun/"},{"name":"RO","slug":"RO","permalink":"https://cheeseburgerim.github.io/tags/RO/"}]},{"title":"Markdown Symbols","slug":"MarkdownSymbols","date":"2021-01-07T04:14:27.000Z","updated":"2021-04-11T04:26:34.100Z","comments":false,"path":"2021/01/07/MarkdownSymbols/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/07/MarkdownSymbols/","excerpt":"","text":"符号 Symbol Code Ω ω \\Omega or \\omega ρ \\rho Φ φ \\Phi or \\phi Δ δ \\Delta or \\delta π \\pi λ \\lambda ⇒ → \\Rightarrow or \\rightarrow Θ θ \\Theta \\theta Γ γ \\Gamma \\gamma ∞ \\infty Σ σ \\Sigma \\sigma E ε \\Epsilon \\epsilon M μ \\Mu \\mu N ν \\Nu \\nu Ψ ψ \\Psi \\psi 计算 Function Code 分数 \\frac{}{} 根号 \\sqrt{} 恒等于≡ \\equiv 正负± \\pm 约等于≈ \\approx 远大于 远小于 \\gg \\ll 积分∫ 用上下标表示上限和下限 \\int * \\ast 点乘 · \\cdot 叉乘 × \\times 除以 ÷ \\div 不等于≠ \\not= \\neq 标记 Symbol Code 上划线 \\overline{} 下划线 \\underline{} 上标 ^ 下标 _ 删除线，中划线 \\sout 左下到右上 \\cance 左上到右下 \\bcance 叉 \\xcance 操作 Operation Code 换行 \\ 空格，空格长度递增 , ; \\quad \\qquad 加粗 \\pmb{} 加粗倾斜 \\boldsymbol{} 字体1&lt;font color=red&gt;我是红色&lt;/font&gt; 我是红色 1&lt;font size=5&gt;我是红色&lt;/font&gt; 我是红色 1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=blue&gt; 背景色是蓝色&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 背景色是蓝色 1&lt;center&gt;居中文本&lt;/center&gt; 居中文本 1&lt;b&gt;加粗字体&lt;/b&gt; 加粗字体","categories":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/categories/Introduction/"}],"tags":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/tags/New/"},{"name":"Markdown","slug":"Markdown","permalink":"https://cheeseburgerim.github.io/tags/Markdown/"}]},{"title":"NEMU-PA3","slug":"NEMU-PA3","date":"2021-01-06T03:40:53.000Z","updated":"2021-04-11T04:26:34.099Z","comments":false,"path":"2021/01/06/NEMU-PA3/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/06/NEMU-PA3/","excerpt":"","text":"Phase1：Cache 阅读实验手册后，根据任务1中描述的性质实现cache，创建cache.h，定义块大小，位数，以及缓存相应的结构体 1234567891011121314151617181920#define BLOCK_SIZE 64#define STORAGE_SIZE_L1 64*1024#define STORAGE_SIZE_L2 4*1024*1024#define EIGHT_WAY 8#define SIXTEEN_WAY 16void init_cache();struct Cache&#123; bool valid; int tag; uint8_t data[BLOCK_SIZE];&#125;cache[STORAGE_SIZE_L1/BLOCK_SIZE];struct SecondaryCache&#123; bool valid,dirty; int tag; uint8_t data[BLOCK_SIZE];&#125;cache2[STORAGE_SIZE_L2/BLOCK_SIZE]; 构造cache初始化函数init_cache()，代码如下 根据要求把给valid，tag以及dirty赋值并在monitor.c文件中的restart()函数中添加相应代码对缓存进行初始化 1234567891011121314151617void init_cache()&#123; int i; for (i = 0;i &lt; STORAGE_SIZE_L1/BLOCK_SIZE;i ++) &#123; cache[i].valid = false; cache[i].tag = 0; memset (cache[i].data,0,BLOCK_SIZE); &#125; for (i = 0;i &lt; STORAGE_SIZE_L2/BLOCK_SIZE;i ++) &#123; cache2[i].valid = false; cache2[i].dirty = false; cache2[i].tag = 0; memset (cache2[i].data,0,BLOCK_SIZE); &#125;&#125; 修改memory.c中的hwaddr_read()和hwaddr_write()函数，实现读写cache的功能，并当cache缺失时才读写DRAM 1234567891011121314151617181920212223242526272829303132333435uint32_t hwaddr_read(hwaddr_t addr, size_t len) &#123; int index = is_mmio(addr); if ( index &gt;= 0) &#123; return mmio_read(addr, len, index); &#125; uint32_t offset = addr &amp; (BLOCK_SIZE - 1); // inside addr uint32_t block = cache_read(addr); uint8_t temp[4]; memset (temp,0,sizeof (temp)); if (offset + len &gt;= BLOCK_SIZE) &#123; uint32_t _block = cache_read(addr + len); memcpy(temp,cache[block].data + offset, BLOCK_SIZE - offset); memcpy(temp + BLOCK_SIZE - offset,cache[_block].data, len - (BLOCK_SIZE - offset)); &#125; else &#123; memcpy(temp,cache[block].data + offset,len); &#125; int zero = 0; uint32_t tmp = unalign_rw(temp + zero, 4) &amp; (~0u &gt;&gt; ((4 - len) &lt;&lt; 3)); return tmp;&#125;void hwaddr_write(hwaddr_t addr, size_t len, uint32_t data) &#123; int index = is_mmio(addr); if ( index &gt;= 0) &#123; mmio_write(addr, len, data, index); return ; &#125; cache_write(addr, len, data);&#125; 至此完成第一阶段。 做第二阶段之前虚拟机发生了一个小小的意外，卡在下图开不了机，只能用新建一个虚拟机重新写第一阶段，再写第二阶段，git log也无法恢复 Phase2：Segment 在kernal/include/common.h中定义宏IA32_SEG 1#define IA32_SEG 修改CPU_state，在reg.h和reg.c文件中增加如下代码，添加并实现GDTR,CR0和各种段寄存器 123456789101112131415161718192021//reg.h#include &quot;../lib-common/x86-inc/cpu.h&quot;//definition of CR0enum &#123;R_CS,R_DS,R_ES,R_SS&#125;//R_GS,R_FS//在CPU_state中//GDTRstruct GDTR&#123; uint32_t base_addr; uint16_t seg_limit;&#125;gdtr;//CR0CR0 cr0;//registersunion&#123; struct SREG sr[6]; struct&#123; struct SREG cs,ds,es,ss; &#125;;&#125;;////reg.cconst char *regss[]=&#123;&quot;cs&quot;,&quot;ds&quot;,&quot;es&quot;,&quot;ss&quot;&#125;; 添加 lgdt 指令 12345678910111213141516//lgdt.h#ifndef __LGDT_H__#define __LGDT_H__make_helper(lgdt_rm_v);#endif//lgdt.c#include &quot;cpu/exec/helper.h&quot;#define DATA_BYTE 2#include &quot;lgdt-template.h&quot;#undef DATA_BYTE#define DATA_BYTE 4#include &quot;lgdt-template.h&quot;#undef DATA_BYTEmake_helper_v(lgdt_rm) 修改swddr_read()和swaddr_write()函数，实现段级地址转换 123456789101112131415uint32_t swaddr_read(swaddr_t addr, size_t len) &#123;#ifdef DEBUG assert(len == 1 || len == 2 || len == 4);#endif lnaddr_t lnaddr = seg_translate(addr, len, current_sreg); return lnaddr_read(lnaddr, len);&#125;void swaddr_write(swaddr_t addr, size_t len, uint32_t data) &#123;#ifdef DEBUG assert(len == 1 || len == 2 || len == 4);#endif lnaddr_t lnaddr = seg_translate(addr, len, current_sreg); return lnaddr_write(lnaddr, len, data);&#125; 定义segment.c，实现seg_translate()函数 1234567#include &quot;nemu.h&quot;lnaddr_t seg_translate(swaddr_t addr, size_t len, uint8_t sreg) &#123; if (cpu.cr0.protect_enable == 0)return addr; Assert(addr+len &lt; cpu.sr[sreg].seg_limit, &quot;cs segment out limit&quot;); return cpu.sr[sreg].seg_base + addr; &#125; 在Operand结构体中添加成员sreg 123456789101112131415typedef struct &#123; uint32_t type; size_t size; union &#123; uint32_t reg; struct &#123; swaddr_t addr; uint8_t sreg; &#125;; uint32_t imm; int32_t simm; &#125;; uint32_t val; char str[OP_STR_SIZE];&#125; Operand; 修改read_ModR_M()中的代码, 以确定是和DS, SS中的哪一个进行捆绑, 然后设置 rm-&gt;sreg, 这样 swaddr_read()和 swaddr_write()就可以使用正确的 段寄存器了 1234567891011121314151617//nemu/src/cpu/decode/modrm.c//read_ModR_M()//elseelse &#123; int instr_len = load_addr(eip, &amp;m, rm); if(rm-&gt;reg == R_ESP || rm-&gt;reg == R_EBP) &#123; current_sreg = R_SS; &#125; else &#123; current_sreg = R_DS; &#125; rm-&gt;val = swaddr_read(rm-&gt;addr, rm-&gt;size); return instr_len; &#125; 出现了报错，重复定义，找了一段时间但是没有解决 尝试做一下任务3 Phase3：Page 添加CR3寄存器，并相应对CR0寄存器进行初始化 12//reg.hCR3 cr3; 修改lnaddr_read()和lnaddr_write()函数 1234567891011121314151617181920212223242526272829uint32_t lnaddr_read(lnaddr_t addr, size_t len) &#123;#ifdef DEBUG assert(len == 1 || len == 2 || len == 4);#endif size_t max_len = ((~addr) &amp; 0xfff) + 1; if (len &gt; max_len) &#123; uint32_t low = lnaddr_read(addr, max_len); uint32_t high = lnaddr_read(addr + max_len, len - max_len); return (high &lt;&lt; (max_len &lt;&lt; 3)) | low; &#125; hwaddr_t hwaddr = page_translate(addr); return hwaddr_read(hwaddr, len);&#125;void lnaddr_write(lnaddr_t addr, size_t len, uint32_t data) &#123;#ifdef DEBUG assert(len == 1 || len == 2 || len == 4);#endif size_t max_len = ((~addr) &amp; 0xfff) + 1; if (len &gt; max_len) &#123; lnaddr_write(addr, max_len, data &amp; ((1 &lt;&lt; (max_len &lt;&lt; 3)) - 1)); lnaddr_write(addr + max_len, len - max_len, data &gt;&gt; (max_len &lt;&lt; 3)); return; &#125; hwaddr_t hwaddr = page_translate(addr); hwaddr_write(hwaddr, len, data);&#125; 实现page_translate()函数 123456789101112131415161718192021222324252627//memory.chwaddr_t page_translate(lnaddr_t);//新建page.c文件//page.c#include &quot;nemu.h&quot;#define DIR(addr) ((addr)&gt;&gt;22)#define PAGE(addr) (((addr)&gt;&gt;12) &amp; 0x3ff)#define OFFSET(addr) ((addr) &amp; 0xfff)hwaddr_t TLB_read(uint32_t);void TLB_write(uint32_t ,uint32_t);hwaddr_t page_translate(lnaddr_t addr) &#123; PAGE_descriptor dir; PAGE_descriptor page; hwaddr_t hwaddr; if (!cpu.cr0.paging || !cpu.cr0.protect_enable)return addr; if ((hwaddr = TLB_read(addr)) != -1)return hwaddr + OFFSET(addr); dir.page_val = hwaddr_read((cpu.cr3.page_directory_base&lt;&lt;12)+(DIR(addr)&lt;&lt;2), 4); Assert(dir.p, &quot;pagevalue = %x eip = %x&quot;, dir.page_val,cpu.eip); page.page_val = hwaddr_read((dir.addr&lt;&lt;12)+(PAGE(addr)&lt;&lt;2), 4); Assert(page.p, &quot;page do not exist at %x&quot;, cpu.eip); hwaddr = (page.addr&lt;&lt;12)+OFFSET(addr); TLB_write(addr, hwaddr); return hwaddr;&#125; Problems 使用PA2答案做PA3，做完PA1后尝试运行。不知道什么原因，发现kernal无法运行，更改opcode_table中的一些指令后即可运行； From 2021/1/6 to 2120/1/17","categories":[{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"NEMU","slug":"NEMU","permalink":"https://cheeseburgerim.github.io/tags/NEMU/"}]},{"title":"Physics","slug":"PhysicsChapter1","date":"2021-01-05T08:18:38.000Z","updated":"2021-04-11T04:26:34.098Z","comments":true,"path":"2021/01/05/PhysicsChapter1/","link":"","permalink":"https://cheeseburgerim.github.io/2021/01/05/PhysicsChapter1/","excerpt":"","text":"Chapter1：振动一、简谐振动简谐振动方程$$x=Acos(ωt+Φ)$$ 在水平方向上的弹簧振子简谐运动中，有$$ω=\\sqrt{\\frac{k}{m}}$$ x对t求导得到v函数 $$v=\\frac{dx}{dt}=-Aωsin(ωt+Φ)=Aωcos(ωt+Φ+\\frac{\\pi}{2})$$ v对t求导得到a的函数 $$a=\\frac{dv}{dt}=\\frac{(dx)^2}{dt^2}=-Aω^2cos(ωt+Φ)=-ω^2x$$ 观察上式可得出结论： 最大位移为Xm，最大速度为Vm，最大加速度为am 则有|Xm|=A，|Vm|=Aω，|am|=Aω² 描述简谐振动特征的物理量 振幅A：振幅是振动物体离开平衡位置的最大位移，反映振动强弱程度的物理量； 角频率ω：$$ω=2\\pi f=\\frac{2\\pi}{T}$$ 相位ωt+Φ：称为振动系统在时刻t的相位，其中Φ是振动系统在t=0时刻的相位，称为初相位。 相位每变化2π，振动的物体就完成一次全振动； t=0时，有$$x_0=x|t=0=AcosΦ\\v_0=v|t=0=-ωAsinΦ$$由上式可得出$$A=\\sqrt{(x_0)^2+(\\frac{v_0}{ω})^2},tanΦ=-\\frac{v_0}{ωx_0}$$ 简谐振动的图示法——旋转矢量法简谐振动的能量 弹性势能Ep$$E_p=\\frac{1}{2}kx^2=\\frac{1}{2}kA^2cos^2(ωt+Φ)$$ 动能Ek$$E_k=\\frac{1}{2}mv^2=\\frac{1}{2}mω^2A^2sin^2(ωt+Φ)=\\frac{1}{2}kA^2sin^2(ωt+Φ)$$ 因此，弹簧谐振子的总机械能为E$$E=E_k+E_p=\\frac{1}{2}kA^2=\\frac{1}{2}mω^2A^2$$ 由此可知，弹簧谐振子的总机械能是一个不随时间变化的常量，即系统的机械能守恒。这也是简谐振动的一个显著的特征； 振幅不仅给出了简谐振动的运动范围，而且还反应了振动系统总能量的大小，或者说反应了振动的强度； 此外，弹簧谐振子的势能平均值和动能平均值(可以分别称为平均势能和平均动能)相等并且等于总机械能的一半。这一结论同样适用于其他简谐振动。 二、简谐振动的合成两个同方向同频率简谐振动的合成 设某物体同时参与两个同方向，同频率的简谐振动，其表达式分别为$$x_1=A_1cos(ωt+Φ_1)\\x_2=A_2cos(ωt+Φ_2)$$ 根据叠加原理，该物体在任意时刻的合振动的位移为$$x=x_1+x_2=A_1cos(ωt+Φ_1)+A_2cos(ωt+Φ_2)$$ 合振动的表达式为$$x=Acos(ωt+Φ)$$ 其中可以利用余弦定理得到合振幅$$A=\\sqrt{A_1^2+A_2^2+2A_1A_2cos(Φ_2-Φ_1)}$$ 初相位Φ满足$$tanΦ=\\frac{A_1sinΦ_1+A_2sinΦ2}{A_1cosΦ_1+A_2cosΦ_2}$$合振幅不仅与两个分振幅有关，还与两个分振动的相位差有关； 合振幅的值将介于最大值A1+A2和最小值|A1-A2|之间。 Chapter2：波动一、波动方程、平面简谐波 一维简谐波的波函数 $$y(x,t)=Acos(ωt-kx+Φ),k=\\frac{2\\pi}{λ} 波沿x轴正向传播\\y(x,t)=Acos(ωt+kx+Φ),k=\\frac{2\\pi}{λ} 波沿x轴负向传播$$ 利用式中各物理量之间的关系，波函数还可以改写成$$y(x,t)=Acos[2\\pi(\\frac{t}{T}-\\frac{x}{λ}+\\phi)]$$ 速度与加速的的函数同样是用求导的方法得到 $$v(x,t)=\\frac{∂y}{∂t}=-\\omega Asin[\\omega (t-\\frac{x}{u})+\\phi],u为波速\\ a=\\frac{∂v}{∂t}=\\frac{∂^y}{∂t^2}=-\\omega^2Acos[\\omega (t-\\frac{x}{u})+\\phi]$$ 通过波函数判断振动方向 上坡下振，下坡上振 二、波的能量、能流密度 在简谐波的传播过程中，任意质元的动能和势能都随时间而变化，但是在任何时刻，势能和动能都是同相位的，其值也是完全相等的； 动能达到最大值时，势能也达到最大值；动能为零时，势能也为零； 在波的传播过程中，任意质元的总机械能不是一个常量，而是随时间做周期性变化的； 质元从比自己相位超前的部分接受能量，又向比自己相位滞后的部分输出能量； 能量伴随波动过程而传播，波动是能量传输的一种方式； 质元运动到平衡位置时能量最大。 波的能量密度 单位体积中波的能量称为波的能量密度，简称波能密度，用w表示； $$w=\\frac{dE}{dV}=\\rho\\omega^2A^2sin^2[\\omega(t-\\frac{x}{u})+\\phi]$$ 波的平均能量密度与介质的密度ρ，角频率ω的平方以及振幅A的平方成正比。这一结论虽然是由平面简谐波导出的，但是对于各种机械波都是适用的。$$\\overline{w}=\\frac{1}{2}\\rho\\omega^2A^2$$ 波的能流密度 波动的过程是波的能量“流动的过程”，因此要引入表征波的能量流动的物理量——波的能流密度，用I表示； 单位时间内通过截面S的波的能量称为波的平均能流，用Q表示 通过单位面积的波的平均能流用I表示 $$Q=\\overline{w}Su\\I=\\overline{w}u=\\frac{1}{2}\\rho\\omega^2A^2u$$ I称为平均能流密度矢量或波的强度。 对于平面简谐波，沿波线方向，即波的传播方向，波的振幅是不变的，因而波的强度也是不变的； 而对于球面简谐波而言，沿波线方向，振幅是变化的，因而波的强度也是变化的； 如果取距波源(也就是球面波的球心)单位距离处的振幅为A0，于是球面波在距波源r处的振幅可以表示为A=A0/r，从而球面简谐波的波函数可以表示为 $$y(r,t)=\\frac{A_0}{r}cos[\\omega(t-\\frac{r}{u})+\\phi]$$ 以上讨论都认定介质是无吸收的理想介质。 三、电磁波电磁波的性质 电磁波是横波； 电场强度E与磁场强度H同相位；$$在真空中,电磁波的传播速度大小表示为c=\\frac{1}{\\sqrt{\\epsilon_0\\mu_0}}\\approx3\\times10^8m/s\\而在介质中电磁波的传播速度大小则表示为u=\\frac{1}{\\sqrt{\\epsilon_0\\epsilon_r\\mu_0\\mu_r}}=\\frac{1}{\\sqrt{\\epsilon\\mu}}\\式中,\\epsilon_r,\\mu_r分别为介质的相对介电常量和相对磁导率\\$$ 电磁波的能量密度与能流密度；$$电场的能量密度可以表示为w_e=\\frac{1}{2}\\epsilon_0E^2\\磁场的能量密度可以表示为w_m=\\frac{1}{2}\\mu_0H^2\\所以电磁场的能量密度w=w_e+w_m\\在电磁波传播过程中,理论和实验都证明,在任何时刻空间中的任何地点\\\\underline{电场的能量密度与磁场的能量密度都相等}\\由此可得\\sqrt{\\epsilon_0}E=\\sqrt{\\mu_0}H\\电磁场的能量密度又可以表示为w=\\frac{1}{c}EH\\$$ $$电磁波在空间传播时,在某一时刻,单位时间内通过与电磁场传播方向相垂直的单位面积的能量\\称为电磁波的瞬时能流密度,通常用S来表示\\d电磁波的瞬时能流密度可以表示为S=wc=E\\times H\\上式表明,能流密度与电场强度和磁场强度之间符合右手螺旋的关系\\$$ 为方便起见,引入电磁波的平均能流密度,即电磁波的强度,用I表示； 平均而言，在单位时间内，通过与电磁波传播方向垂直的单位面积的能量，或者说，通过与电磁波传播方向相垂直的单位面积的平均功率，就是电磁波的平均能流密度，也就是电磁波的强度；$$若电磁波的平均能量密度用\\overline{w}表示,电场强度和磁场强度的平均值分别用\\overline{E}和\\overline{H}表示\\则电磁波的平均能流密度,即电磁波的强度可以表示为I=\\overline{S}=\\overline{w}c=\\overline{EH}\\在介质中传播时,I=\\overline{S}=\\frac{1}{2}\\sqrt{\\frac{\\epsilon}{\\mu}}E_0^2=\\frac{1}{2}\\sqrt{\\frac{\\mu}{\\epsilon}}H_0^2$$ 四、波的干涉波的叠加 波的叠加问题实际上是振动的合成问题； Example：有波源S1，S2距P点距离分别为r1，r2，则两波在P点引起的振动分别为 $$y_1=A_1cos[\\omega_1(t-\\frac{r_1}{u})+\\phi_1]\\y_2=A_2cos[\\omega_2(t-\\frac{r_2}{u})+\\phi_2]$$ 式中，u为介质中的波速 P点在时刻t合振动振幅的二次方为 $$A^2=A_1^2+A_2^2+2A_1A_2cos\\Delta\\phi\\\\Delta\\phi=(\\omega_2-\\omega_1)t-\\frac{\\omega_2r_2-\\omega_1r_1}{u}+\\phi_2-\\phi_1$$ P点合成波的强度为I$$I=I_1+I_2+2\\sqrt{I_1I_2}\\overline{cos\\Delta\\phi}\\在当前所学情况下，有\\overline{cos\\Delta\\phi}\\equiv0\\于是，P点的合成波强度为I=I1+I2$$综上所述，当两列波的振动方向相互垂直，或两列波的角频率不相等，或两列波的初相位差不恒定(即随时间变化)时，合成波的强度等于每个波的强度之和。这种波的叠加称为非相干叠加。 波的干涉 当两列波的振动方向相同，并且角频率也相同，以及两波源相位差恒定(也就是两列波的初相位差恒定)时，这两列简谐波称为相干波。这是两列波的叠加称为相干叠加。无论在理论上，还是在实践中相干叠加都具有非常重要的意义。相干叠加的结果可以产生干涉现象。 干涉情况下，有 $$\\Delta\\phi=(\\phi_2-\\phi_1)-\\frac{\\omega}{u}(r_2-r_1)=(\\phi_2-\\phi_1)-\\frac{2\\pi}{\\lambda}(r_2-r_1)\\A=\\sqrt{A_1^2+A_2^2+2A_1A_2cos\\Delta\\phi}\\I=I_1+I_2+2\\sqrt{I_1I_2}cos\\Delta\\phi$$ $$\\Delta\\phi=\\begin{cases}\\pm2k\\pi &amp; k=0,1,2,… \\Rightarrow振幅和强度最大，干涉相长或相长干涉A=A_1+A_2,I=I_1+I_2+2\\sqrt{I_1I_2}\\\\pm(2k+1)\\pi &amp; k=0,1,2,… \\Rightarrow振幅和强度最小，干涉相消或相消干涉A=|A_1-A_2|,I=I_1+I_2-2\\sqrt{I_1I_2}\\others &amp; 在相位差为其他值的地方，其振幅和强度都介于上述两种极端情况之间\\end{cases}$$ 如果两波源的初相位相同，即Φ1=Φ2，则相干波的相位差ΔΦ只取决于波程差δ=r2-r1，上述结论简化为$$\\delta=r_2-r_1=\\begin{cases}\\pm k\\lambda &amp; k=0,1,2,… \\Rightarrow干涉相长\\\\pm(2k+1)\\frac{\\lambda}{2} &amp; k=0,1,2,… \\Rightarrow干涉相消\\end{cases}$$ 由以上分析可知，只有相干波，即满足振动方向相同，频率相同，相位差恒定的简谐波，叠加才能产生干涉现象。因而把振动方向相同，频率相同，相位差恒定称为简谐波的相干条件。 驻波 驻波是波的干涉的特例。两列传播方向相反的相干波相干叠加的结果就形成驻波； 设有两列相干波，分别沿x轴正方向和负方向传播，为简单起见，进一步假设这两列波的振幅相同 他们的表达式分别为$$y_1=Acos(\\omega t-\\frac{2\\pi}{\\lambda}x)\\y_2=Acos(\\omega t+\\frac{2\\pi}{\\lambda}x)\\其合成波为y=y_1+y_2=2Acos\\frac{2\\pi}{\\lambda}xcos\\omega t\\此式就是驻波的表达式\\式中,cos\\omega t表示简谐振动,而|2Acos\\frac{2\\pi}{\\lambda}x|就是该简谐振动的振幅\\各点都以相同的频率,不同的振幅做简谐振动\\振幅最大的各点称为驻波的波腹,振幅最小的各点称为波节\\相邻两个波腹或相邻两个波节之间的距离为\\Delta x=\\frac{\\lambda}{2}\\相邻波节之间各点的振动都是同相位的\\而波节两侧的振动都是反相位的\\$$ Chapter3：波动光学一、光的干涉简介 定义光程L=nr，两类相干波的相位差可以转换为光程差。通过几何关系找到光程差，进而得到相位差； 波动最显著的特征之一，就是能产生干涉现象。光波也是如此，当空间中相遇的两个或两个以上的波彼此之间满足相干条件时，就会产生干涉现象； 光的干涉表现为，光强在空间出现具有一定规律的突变分布，且这种分布不随时间变化。然而，普通光源所发出的光，是不满足相干条件的； 为了实现光的干涉，就必须制备相干光源。总体上分为两种方法： 分波阵面发； 分振幅法。 分波阵面法制备相干光1.杨氏双缝干涉实验 $$光程差\\delta=dsin\\theta\\由于\\theta角很小，所以有sin\\theta\\approx tan\\theta\\所以得到\\delta=dtan\\theta=d\\frac{x}{D}=\\frac{xd}{D}\\设实验所用的是波长为\\lambda的单色光\\则有\\begin{cases}干涉加强|明条纹 &amp;\\delta=\\frac{xd}{D}=\\pm k\\lambda,k=0,1,2,…\\Rightarrow x_k=\\pm k\\frac{D\\lambda}{d}\\干涉减弱|暗条纹 &amp;\\delta=\\frac{xd}{D}=\\pm (k+\\frac{1}{2})\\lambda,k=0,1,2,…\\Rightarrow x_k=\\pm (2k+1)\\frac{D\\lambda}{2d}\\end{cases}\\名暗条纹都是等间距分布的，即无论是两条相邻的明条纹或是两条相邻的暗条纹\\条纹中心间距都为\\Delta x=\\frac{D\\lambda}{d}$$ 2.多光束干涉3.劳埃德镜4.菲涅尔双棱镜分振幅法制备相干光源——薄膜干涉1.等倾条纹$$相应的薄膜干涉的光程差方程式为\\delta=2ne+\\frac{\\lambda}{2},n为折射率,e为厚度$$ 2.等厚干涉1.劈尖形薄膜的干涉$$由于薄膜各处的厚度e不同，光程差也不同，因而会产生明暗相间的干涉条纹\\光程差\\delta=2ne+\\frac{\\lambda}{2}\\当劈尖上下表面的反射光间的光程差等于入射光波长的整数倍时，干涉会产生明条纹\\即\\delta=2ne_k+\\frac{\\lambda}{2}=k\\lambda,k=1,2,3,…第k级明条纹所在处的厚度为e_k\\当劈尖上下表面的反射光间的光程差等于入射光半个波长的奇数倍时，干涉会产生暗条纹\\即\\delta=2ne_k+\\frac{\\lambda}{2}=(k+\\frac{1}{2})\\lambda=(2k+1)\\lambda,k=0,1,2,3,…第k级暗纹所在处的厚度为e_k\\由图中的几何关系可知，第k级条纹到棱边的距离l_k=\\frac{e_k}{\\theta}，式中，\\theta为劈尖夹角\\相邻明条纹或暗条纹中心之间的厚度差相等，值为\\Delta e=\\frac{\\lambda}{2n}\\通过几何关系可以得到相邻明条纹或暗条纹中心之间的距离也是相等的，值为\\Delta l=\\frac{\\Delta e}{\\theta}=\\frac{\\lambda}{2n\\theta}$$ 2.牛顿环干涉$$e_k=\\frac{r^2}{2R}\\中间是暗纹\\第k级明条纹的半径为r_k=\\sqrt{\\frac{(2k-1)R\\lambda}{2n}}=\\sqrt{\\frac{2k-1}{2}}\\sqrt{\\frac{R\\lambda}{n}},k=1,2,3,…\\第k级暗条纹的半径为r_k=\\sqrt{\\frac{kR\\lambda}{n}}=\\sqrt{k}\\sqrt{\\frac{R\\lambda}{n}},k=0,1,2,3,…\\可以看出r_k=c\\sqrt{k},所以离中心越远条纹越密\\对于空气薄膜，保持玻璃片不动\\透镜向上平移，则可观察到牛顿环逐渐缩小并在中心处消失\\若透镜向下平移，牛顿环将自中心处冒出并变大\\只要数出从中心处冒出或消失的条纹数N，就可以计算出透镜移动的距离d=N\\frac{\\lambda}{2}$$ 3.迈克尔孙干涉仪 光程差为两倍 二、光的衍射 用激光照射障碍物，很容易演示光的衍射现象； 根据观察方式的不同，通常把衍射分为两类 一类如图a所示，光源和(或)观察屏离开衍射缝或衍射孔的距离有限，这种衍射称为菲涅尔衍射，或进场衍射； 一类如图b所示，光源和观察屏都距离衍射缝或衍射孔无限远处，这种衍射称为父琅禾费衍射，或远场衍射； 夫琅禾费衍射实际上时菲涅尔衍射的极限情形。 单缝夫琅禾费衍射$$光程差\\delta=asin\\phi\\光强分布I=I_0(\\frac{sinu}{u})^2\\所以当u=\\frac{\\pi asin\\phi}{\\lambda}=\\pm k\\pi,k=1,2,3,…,有I=0\\所以暗条纹出现的条件是asin\\phi=\\pm k\\lambda,k=1,2,3,…\\在相邻两个暗条纹之间，有一次级大的条件为tanu=u\\次级大的光强比中央明条纹的光强小得多，并且随着级数增加而急剧减小\\综上所述\\\\begin{cases}中央明条纹中心 &amp; \\phi=0\\暗条纹中心 &amp; asin\\phi=\\pm k\\lambda,k=1,2,3,…\\次级大明条纹中心 &amp; asin\\phi=\\pm (k+\\frac{1}{2})\\lambda,k=1,2,3,…\\end{cases}\\其中a为缝的宽度\\中心区非常亮\\对于非中心区域,\\phi\\neq0\\半波带数=光线条数 N=\\frac{\\delta}{\\lambda/2}\\$$ 光栅衍射 所谓光栅，实际上是在空间具有周期性分布的透射光或反射光的光学元件； $$亮纹条件:(a+b)sin\\phi=k\\lambda k=0,\\pm1,\\pm2,…\\最小宽度a=(a+b)/第一次缺级级数\\最大衍射级=(a+b)/\\lambda\\$$ 三、光的偏振自然光与偏振光起偏和检偏 光第一次通过偏振片时，光强会减少一半，此时该偏振片称为起偏器，即用于产生偏振光； 当偏振片用来检验光的偏振状态时，叫做检偏器； $$光透过偏振器后的光强为I=I_0cos^2\\theta$$ Chapter4：狭义相对论一、洛伦兹变换与侠义相对论的时空观狭义相对论的两个基本假设 相对性原理：在任何一个惯性参考系中，物理规律的形式相同，简单地说就是所有的惯性系等价； 光速不变原理：真空中的光速在所有的惯性参考系中都相同，与观察者和光源的运动无关； 这一原理的一个直接结果是物体的运动速度不可能达到真空中的光速； 洛伦兹变换(狭义相对论的坐标变换)Example $$两个观察者同时观察参考系K的坐标原点，坐标分别为x=0，x’=-vt’\\变换因子\\gamma=\\frac{1}{\\sqrt{1-\\frac{v^2}{c^2}}}&gt;1\\可以得到以下关系\\x’=\\gamma(x-vt)\\y’=y\\z’=z\\t’=\\gamma(t-\\frac{v}{c^2}x)\\当v\\ll c时,变换因子\\gamma=1\\用洛伦兹变换可以直接验证关系x^2+y^2+z^2-c^2t^2=x’^2+y’^2+z’^2-c^2t’^2$$ 二、相对论力学$$牛顿力学的核心规律\\牛顿第二定律 F=\\frac{dp}{dt},p=mv$$ 相对论质量与动量$$相对论质量m=\\frac{m_0}{\\sqrt{1-\\frac{v^2}{c^2}}}\\式中m_0是与物体保持相对静止的观察者测得的物体质量，简称静止质量\\利用相对论质量，物体的相对论动量是p=mv=\\frac{m_0v}{\\sqrt{1-\\frac{v^2}{c^2}}}$$ 相对论动能$$E_k=mc^2-m_0c^2$$ 相对论的总能量和质能关系$$一个质点的相对论总能量为E=E_k+m_0c^2=mc^2\\静止能量为E_0=m_0c^2$$ Chapter5：物质的波粒二象性一、黑体辐射与能量子 为了描述物体发射电磁波的本领，定义**辐出度e(T)**； 其物理意义是单位时间内从辐射源表面单位面积发出的辐射能量，单位是W/m²； 对应某一特定波长的辐出度称为单色辐出度，用e(λ,T)表示； 其物理意义是单位时间内从辐射源表面单位面积发出的单位波长间隔的辐射能量； 总辐出度与单色辐出度有一下关系$$e(T)=\\int_0^\\infty e(\\lambda,T)d\\lambda$$ 黑体与黑体辐射 物体的吸收系数与物体的温度和入射波的波长都有关系，波长在λ~λ+dλ范围内的吸收数叫做单色吸收系数，用符号a(λ,T)表示； 通常，我们把能够完全反射所有波长光波的物体叫做白体，白体的吸收系数a(λ,T)=0； 能够完全吸收所有波长光波的物体叫做黑体，黑体的吸收系数a(λ,T)=1； 介于二者之间的物体叫灰体，灰体的吸收系数满足0＜a(λ,T)＜1； 有一些物体只对某些波长或者某段的光有明显的吸收，对其他波长吸收很少或者不吸收，这样的物体称为选择性吸收体； 实际中，那些有色反光物就属于选择性吸收体。 黑体是一个理想的物理模型，它并不等同于黑色的物体，因为黑色的物体也会有少量地反射电磁波，吸收系数不是绝对等于1； 现实生活中，绝对的白体或黑体并不存在； $$研究表明，吸收能力越强的物体，辐射本领也越强\\相同温度条件下，任何物体的单色辐出度与吸收系数的比值都相同，且都等于黑体的单色辐出度\\即\\frac{e_1(\\lambda,T)}{a_1{(\\lambda,T)}}=\\frac{e_2(\\lambda,T)}{a_2{(\\lambda,T)}}=…=e_0(\\lambda,T)\\e_0(\\lambda,T)代表黑体的单色辐出度，只是波长和温度的函数\\$$ 黑体辐出度与温度关系式$$e(T)=\\sigma T^4\\式中,\\sigma=5.670373\\ast10^{-8}W\\cdot m^{-2}\\cdot K^{-4},称为斯特藩常量\\$$ 黑体辐射能谱峰值对应的波长λm与黑体温度的关系$$\\lambda_mT=b\\式中,常量b=2.8977721\\times10^{-3}m\\cdot K\\该结果成为维恩位移定律，常量b称为维恩位移常量\\不难发现，温度升高，能谱峰值对应的波长变短\\$$ $$维恩辐射公式e(\\lambda,T)=c_1\\lambda^{-5}e^{-c_2/(\\lambda T)}\\式中,c_1和c_2是两个常量\\$$ $$空腔辐射的辐出度按波长分布的瑞利—金斯公式\\e(\\lambda,T)=\\frac{2\\pi c}{\\lambda^4}kT\\式中,k是玻尔兹曼常量,c是真空中光速\\$$ $$维恩公式在短波波段与实验符合较好，而瑞丽-金斯公式在长波波段与实验曲线相吻合\\德国物理学家普朗克得到了一个经验公式,现称为普朗克公式\\e(\\lambda,T)=\\frac{2\\pi hc^2}{\\lambda^5}\\frac{1}{e^{\\frac{hc}{\\lambda kT}-1}}\\式中,h=6.626070040(81)\\times10^{-34}J\\cdot s是一个常量，与黑体的材料，性质和温度都无关，叫做普朗克常量\\在波长很小的时候，普朗克公式成为维恩公式；波长很大时，普朗克公式可以得到瑞丽-金斯公式\\普朗克公式与实验完全符合\\$$ 二、光电效应与光子 光电效应的实验规律可以归纳为以下四条 光电子出现与否与照射金属所用光的强度没有直接关系。仅当照射物体的光频率不小于某个确定值时，物体才能发出光电子，这个频率叫做红限频率(或截止频率)，相应的波长叫做红限波长。不同物质的红限波长是不同的； 光电子脱出物体时的初速度或者出动能和照射光的频率有关而和光强无关，并且光电子的初始动能与入射光的频率有线性关系； $$从实验知道,产生光电流的过程非常快,一般不超过10^{-9}s;\\光照停止,光电流也随之停止。这表明,光电效应是瞬时的。$$ 饱和电流与入射光的强度成正比，也就是说单位时间内从金属表面逸出的光电子数目与入射光的强度成正比。 爱因斯坦的光量子(光子)理论 爱因斯坦把量子性从辐射的机制引申到光本身上，认为光本身也不是连续的，光不仅在吸收和发射时是量子化的，而且光本身也是量子化的； $$具体来说，爱因斯坦认为，一束频率为\\nu的光，是一束光子流\\每个光子具有\\epsilon=h\\nu的能量\\光电效应就是光子与电子碰撞的结果\\根据能量守恒，可以写出以下等式\\h\\nu=W+\\frac{1}{2}mv^2\\左边是入射光子的能量\\右边第一项W是将束缚在金属中的电子打出所需要的最小能量,成为逸出功\\右边第二项是出射光电子的初始动能E_k=\\frac{1}{2}mv^2,也是最大动能\\方程的物理意义为:入射光子的能量,一部分用来克服束缚电子的势场做功,余下的就变成了电子的动能\\该式也成为爱因斯坦方程\\根据遏止电压的定义,遏止电压满足eU_a=E_k\\爱因斯坦方程本身就是光子频率与光电子初动能或者遏止电压的线性关系\\由于碰撞是瞬时的,只要光子的能量足够大,光电子就会马上出现,不需要时间的积累\\光强较强时,光子较多,光电子相应的也会增多,光电流也随之增大\\$$ 光的波粒二象性概念 爱因斯坦认为光是波动性和粒子性的复合体，光具有波粒二象性； 光子的波动性与粒子性是光子本性在不同条件下的表现； 波动性突出表现在其传播过程中，粒子性则突出表现在物体的电磁辐射与吸收，光子与物质的相互作用中； 需要指出的是，在同一条件下，光子或者表现出粒子性，或者表现出波动性，两者不可能同时都表现出来； $$光子的粒子性:\\epsilon=h\\nu\\光子的波动性:p=\\frac{mc^2}{c}=\\frac{h\\nu}{c}=\\frac{h}{\\lambda}\\这两个关系也被称为爱因斯坦关系\\这里，起着桥梁作用的是普朗克常量h\\$$ 三、康普顿散射利用光子的概念，爱因斯坦成功解释了光电效应的各项试验结果。但是，光电效应涉及的只是光子的能量，而没有涉及光子的动量。作为一个粒子，光子具有动量，应该能够得到实验的直接证实，而康普顿散射实验直接证实了光子动量的存在。 康普顿散射实验 光子与电子的碰撞$$散射射线波长的改变量\\\\Delta\\lambda=\\lambda-\\lambda_0=2\\frac{h}{m_0c}sin^2\\frac{\\theta}{2}=\\frac{h}{m_0c}(1-cos\\theta)\\式中,常量\\frac{h}{m_0c}是一个具有长度量纲的量,称为电子的康普顿波长\\用符号\\lambda_c表示,\\lambda_c=0.00243nm\\$$ 四、物质波与德布罗意关系德布罗意设想，具有波动性的光可以具有粒子性，那么对于实物粒子很可能也具有波动性。德布罗意进一步猜测，关于光子的亮哥哥爱因斯坦关系式，是否适用于实物粒子？通过电子在晶体上的衍射实验，直接证证实了电子的波动特性。此后，人们相继证实了原子，分子，中子等都具有波动性。德布罗意的设想最终都得到了完全的证实。这样，所有的物质都具有波粒二象性，这些波被称为德布罗意波，也叫做物质波。 德布罗意关系$$德布罗意将爱因斯坦关系推广到一般情况，对于所有物质有如下关系:\\E=h\\nu=\\overline{h}\\omega\\p=\\frac{h}{\\lambda}=\\overline{h}k\\式中,\\overline{h}=\\frac{h}{2\\pi},园频率\\omega=2\\pi\\nu,波数k=\\frac{2\\pi}{\\lambda}\\此为德布罗意关系\\式子左边的动量和能量描述粒子特征,而式子右边的波长和频率描述波动特征\\$$ 五、氢原子和玻尔的量子论 α粒子的散射实验：原子的有核结构模型； 氢原子的光谱特性$$任何原子的光谱都是线状的,而且每种原子都具有自己的特征光谱\\氢原子光谱是最简单的一种原子光谱\\\\sigma=\\frac{1}{\\lambda}=R(\\frac{1}{2^2}-\\frac{1}{n^2}),n=3,4,5,…\\式中,\\sigma称为波数,即波长的倒数\\R称为氢原子的里德伯常量,等于1.0973731568508(65)\\times10^7m^{-1}\\这一公式所表达的一组光谱线称为巴尔末系\\$$ $$之后发现分布在氢可见光区右侧的紫外及红外光谱区的若干谱线系\\他们可以用综合公式表示为\\\\sigma=\\frac{1}{\\lambda}=R(\\frac{1}{m^2}-\\frac{1}{n^2})\\式中,m是正整数且m&lt;n\\$$ 玻尔的量子论 首先利用爱因斯坦的光子概念，得到了氢原子能量量子化的结果式$$E_n=-\\frac{Rhc}{n^2}\\E_1=-13.6ev,这是氢原子的最低能量,对应的状态称为基态\\n≥2时的状态叫做激发态,例如n=2,3的状态分被称为第一激发态和第二激发态\\氢原子的能量是分离的,也称之为量子化的\\$$ 然后假设电子绕原子核的运动仍然遵从牛顿运动定律,就得到了电子轨道半径和角动量的量子化结果式$$电子圆周运动半径的量子化结果:r_n=\\frac{e^2}{8\\pi\\epsilon_0Rhc}n^2\\与能量的下脚标一样,半径的下脚标表示半径与整数n有关\\这些半径统称为玻尔半径\\角动量为L=r\\times p=rmv=n\\frac{h}{2\\pi}\\$$ 这些就是波尔理论的基本内容 综上所述，波尔理论包含以下三条假设 原子中电子运动轨道量子化假设：电子只能在一些特定的轨道上运行而不辐射电磁波。这时原子处于稳定状态，简称定态； 原子能级的跃迁假设：原子从一个定态跃迁到另一个定态时，原子辐射一定频率的光子，光子的能量由这两种定态的能量差决定； 角动量的量子化假设。 Chapter6：量子力学基础一、物质波波函数的特性自由粒子的波函数形式$$在经典物理中,介质中沿某个方向传播的简谐波(平面波)的形式为\\y(x,t)=Acos[2\\pi(\\nu t-\\frac{x}{\\lambda})]\\也可以将其写成复数形式\\y(x,t)=Ae^{-i2\\pi(\\nu t-\\frac{x}{\\lambda})}\\实际存在的波是复数形式的实部\\$$ $$物质波的波函数用符号\\psi(x,t)表示\\\\psi(x,t)=Ae^{\\frac{i(px-E_kt)}{\\overline{h}}}\\物质波的强度代表粒子在空间出现的概率,所以波函数也因此称为概率幅\\将波函数推广到三维情况,有\\psi(r,t)=Ae^{\\frac{i(p\\cdot r-E_kt)}{\\overline{h}}}\\$$ 不确定原理$$\\Delta x\\Delta p_x=h\\值得注意的是,该乘积是一个绝对常量\\如果考虑到其他亮纹,电子动量不确定度会大于上式中给出的数值\\变为,\\Delta x\\Delta p_x≥h\\该关系称为海森伯不确定关系\\此外还有\\Delta p=\\frac{h}{\\lambda^2}\\Delta\\lambda\\$$ 二、薛定谔方程波函数的标准条件 物质波的波函数为复数，因此在某一时刻在空间某处发现例子的概率正比于波函数ψ(r,t)与其共轭ψ*的乘积； 在体积dV=dxdydz内发现粒子的概率正比于|ψ|²dV=ψψ*dV； 对于某个粒子，要么出现在空间的这个区域，要么出现在另一个区域。换句话说，在整个空间找到这个自理的概率是100%$$所以有\\int|\\psi|^2dV=1\\此式称为波函数的归一化条件\\满足此式的波函数成为归一波函数\\归一化后,波函数的绝对值的平方是概率密度\\经典波的振幅具有实际意义,例如机械波的振幅代表位移等,因此不存在归一化问题\\$$ 在给定的时刻，粒子在空间某处出现的概率必须是一个确定的数值，因此波函数ψ(r,t)应该是单值和有限的； 此外，概率不会在某处发生突变，因此波函数也要求是连续的； 总之，物质波的波函数应该是单值，有限和连续的，这就是波函数要满足的标准条件。 量子力学的基本方程——薛定谔方程 对于做非相对论运动的粒子，动能与动量的关系为$$E=\\frac{p^2}{2m}\\对于自由粒子,动能就是其总能量,所以去掉了动能中的下脚标k\\下面主要讨论的是非相对论情况,习惯上我们\\pmb{\\underline{仍然用E表示非相对论粒子的机械能,或者非相对论的总能量}}\\$$ 一维定态薛定谔方程的求解三、一维定态系统一维无限深方势阱四、氢原子薛定谔方程描述氢原子状态的三个量子数 我们关注氢原子的三个物理量：能量，角动量和角动量的分量。在量子力学中，它们的取值都是分离的，或者说是量子化的； 氢原子的能级为$$E_n=-\\frac{m_ee^4}{2\\overline{h}(4\\pi\\epsilon_0)^2n^2},n=1,2,3,…\\量子数n称为\\underline{\\pmb{主量子数}}\\基态能量E_1=-13.6ev\\上式也可以写成E_n=\\frac{-13.6}{n^2}\\$$ 角动量的二次方取值为$$L^2=l(l+1)\\overline{h}\\量子数l叫做\\underline{\\pmb{角量子数}}的取值为l=0,1,2,3,…,n-1\\将角动量的二次方开方,在量子数l很大的情况下得到于玻尔理论相同的结果\\在光谱学中,用符号s,p,d,f,g,h表示量子数l=0,1,2,3,4,5的状态\\角动量的z分量或者第三分量的取值为L_z=m_l\\overline{h}\\对于给定的l,量子数m_l也叫磁量子数,其取值为:0,\\pm1,\\pm2,…,\\pm l\\$$ $$磁量子数m_s=\\pm\\frac{1}{2},自旋量子数s=\\frac{1}{2}\\$$ 电子的概率分布 电子云五、电子的自旋 原子的壳层结构电子的自旋泡利不相容原理 1925年，泡利提出 在一个原子中，不可能有两个或两个以上地电子具有完全相同的量子态，即原子中的任何两个电子不可能有完全相同的一组量子数; 壳层结构 原子的电子组态 早在1916年，W.Kossel提出多电子原子中核外电子按壳层分布的形象化模型。他认为主量子数n相同的电子组成一个主壳层，对应于n=1,2,3,4,5,6,…的各个主壳层分别用大写字母K,l,M,N,O,P,…表示； 在每一主壳层内，又按角量子数l分为若干支壳层，l=0,1,2,3,4,5,…的支壳层分别用小写字母s,p,d,f,g,h,…表示； 对于确定的n和l，用nl表示，如1s,2s,2p,…； 泡利原理指出，每一支壳层和每一主壳层上可以占据的电子数是有限的，一些支壳层和主壳层可以容纳的电子数如下表所示 n\\l 0 s 1 p 2 d 3 f 4 g 5 h 6 i Zn 1 K 2 2 2 L 2 6 8 3 M 2 6 10 18 4 N 2 6 10 14 32 5 O 2 6 10 14 18 50 6 P 2 6 10 14 16 22 72 7 Q 2 6 10 14 16 22 26 98 电子在原子中的分布还符合能量最小原理：当原子处于正常状态时，原子中的电子尽可能地占据未被填充地最低能级。可见，能量较低的壳层首先被电子填充，只有当低能级地壳层被填充满后，电子才依次向高能级地壳层填充； 当一个原子中的每个电子状态n和l均被指定后，则称该原子具有一定的电子组态。","categories":[{"name":"Physics","slug":"Physics","permalink":"https://cheeseburgerim.github.io/categories/Physics/"}],"tags":[{"name":"Physics","slug":"Physics","permalink":"https://cheeseburgerim.github.io/tags/Physics/"}]},{"title":"文件管理","slug":"OSChapter3","date":"2020-12-31T08:04:00.000Z","updated":"2021-04-11T04:26:34.099Z","comments":false,"path":"2020/12/31/OSChapter3/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/31/OSChapter3/","excerpt":"","text":"文件管理Points RAID 独立磁盘冗余阵列； 把硬盘组合在一起，组成一个磁盘阵列；实现对数据的可靠性，读写快速性，冗余性廉价性的存储； 功能： 提高I/O能力——磁盘并行读写； 提高耐用性——磁盘冗余来实现； 磁盘镜像，奇偶校验可提高RAID可靠性；","categories":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/categories/OS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"}]},{"title":"内存管理","slug":"OSChapter2","date":"2020-12-29T11:04:51.000Z","updated":"2021-04-11T04:26:34.098Z","comments":false,"path":"2020/12/29/OSChapter2/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/29/OSChapter2/","excerpt":"","text":"一、内存管理1.内存的基础知识逻辑地址与物理地址Eg：编译时只需确定变量x存放的相对地址是100(也就是说相对于进程在内存中的起始地址的地址)。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可； 相对地址又称逻辑地址，绝对地址又称物理地址。 装入内存的三种方式 绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。 绝对装入由于逻辑与实际内存地址相同，故不需要对程序的数据的地址进行修改。 绝对装入只适用于弹道程序环境，绝对地址可由程序员在编译或者汇编时赋予。 可重定位装入：在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的，此时采用可重定位装入方式，根据内存的目前情况，将装入模块装入到内存的适当位置。装入时对目标程序中指令和数据的修改称为重定位，地址变换通常是在装入时一次完成的，所以又称静态重定位。 动态运行时装入：也称为动态重定位。程序在内存中如果发生移动，就素要采用动态的装入方式。编译，链接后的装入模块的地址都是从0开始的。装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换成绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持。动态重定位的特点是可以将程序分配到不连续的存储区中，在程序运行之前可以只装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配的内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。用于现代操作系统。 2.内存管理的概念操作系统作为系统资源的管理者，当然也需要对内存进行管理 操作系统负责内存空间的分配与回收； 操作系统需要提供某种技术从逻辑上对内存空间进行扩充； 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换； 操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰。 内存空间的扩展内存空间的扩充：利用虚拟存储技术或者自动覆盖技术，从逻辑上扩充内存。 Eg：游戏GTA5的大小约100G，按理来说运行这个游戏需要把100G的数据全部放入内存。然而，我的电脑实际内存只有8G(虚拟技术-操作系统的虚拟性)。 内存保护保证各道作业在各自的存储空间内运行，互不干扰，有以下两种方式： CPU中设置一对上，下限寄存器，存放用户作业在主存中的上限和下限，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断是否越界； 通过采用重定位寄存器(或基址寄存器)和界地址寄存器(又称限长寄存器)来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值，每个逻辑地址值必须小于界地址寄存器，内存管理结构动态得将逻辑地址与界地址寄存器进行比较，如果未发生地址越界。则加上重定位寄存器的值后映射成物理地址，再送交内存单元。 内存的覆盖与交换覆盖技术 由于程序运行时并非任何时候都要访问程序及数据的各个部分(尤其是大程序)，因此可以把用户空间分成一个固定区和若干个覆盖区。将经尝活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段； 特点：打破了必将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而需要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻保存。 交换技术 交换技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间的动态调度)； 换入：把准备好竞争CPU运行的程序从辅存移到内存； 换出：把处于等待状态(或CPU调度原则下被剥夺运行权力)的程序从内存移到辅存，把内存空间腾出来； 暂时换出外存等待的进程状态为挂起状态(suspend)，挂起态又可以进一步细分为就绪挂起，阻塞挂起两种状态； 3.连续分配管理方式内部碎片：分配给某进程的内存区域中，没有用上的部分； 外部碎片：内存中的某些空闲分区由于太小而难以利用。 单一连续分配 内存在此方式下分为系统区和用户区； 系统区仅提供给操作系统使用，通常在低地址部分； 用户区是为用户提供的，除系统区外的内存空间，我们平常运行的软件都在用户区里分配空间； 优点：无外部碎片，可以采用覆盖技术，不需要额外技术支持； 缺点：只能用于单用户，单任务操作系统中，有内部碎片，存储器利用率极低。 固定分区分配 固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后背作业队列中，选择适当大小的作业装入该分区，如此循环； 优点：实现简单，无外部碎片； 缺点：程序可能太大而放不进任何一个分区中，这是用户不得不使用覆盖技术来使用内存空间。 动态分区分配 又称可变分区分配，是一种动态划分内存的分区方法； 这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态建立分区，并使分区的大小正好适合进程的需要； 因此系统分区的大小和数目是可变的； 缺点：外部碎片很多(通过紧凑消除，就是操作系统不时地对进程进行移动和整理。但是这是要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于Windows系统中的磁盘整理程序，只不过后者是对外存空间的紧凑)。 4.动态分区分配算法首次适应算法 算法思想：每次都从低地址开始查找，找到一个能满足大小的空闲分区； 实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 最佳适应算法 算法思想：由于动态分区是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片地空闲区，即优先使用更小的空闲区； 实现：空闲区按容量递增地次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 最坏适应算法 又称最大适应算法 算法思想：为了解决最佳适应算法问题——留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用； 实现：空闲区按容量递减地次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 邻近适应算法 算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束地位置开始检索，就能解决上述问题； 实现：空闲分区以地址递增地顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束地位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 5.存储管理分页式存储管理 如果允许将一个进程直接分散地装入到许多不相邻的分区中，则无须再进行“紧凑”。基于这一思想而产生了离散分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式。在分页存储管理方式中，如果不具备页面对换功能，则称为基本分页存储管理方式，或称为纯分页存储管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。 逻辑地址结构：页号+页内偏移量； 一个进程对应一张页表； 进程的每一页对应一个页表项； 每个页表项由页号和块号组成； 页表记录进程页面和实际存放的内块之间的对应关系； 每个页表项的长度是相同的，页号是隐含的。 分段式存储管理 引入分段存储管理方式，主要是为了满足用户和程序员地一系列需要 方便编程，信息共享，信息保护，动态增长，动态链接 原理：在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等，如图4-17所示。每个段都有自己的名字。为了实现简单起见，通常可用一个段号来代替段名，每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，亦即，其逻辑地址由段号(段名)和段内地址所组成。 逻辑地址结构：段号+段内地址； 段页式存储管理 段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。 在段页式系统中，一作业地址结构由段号、段内页号及页内地址三部分所组成。 段页式存储的实现结合了页式和段式管理的基本思想，即用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间。 逻辑地址结构：段号+页号+页内偏移量。 分段，分页管理对比 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理.上的需要，完全是系统行为，对用户是不可见的。段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。-一个段通常包含着一-组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。 在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。 分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的。 6.多级页表根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面也可以正常运行了，因此没有必要让整个页表都常驻内存。 单级页表问题 页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框； 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需访问某几个特定的页面； 减少页表所占的内存空间。 7.快表 又称联想寄存器(TLB)，是一种访问速度比内存快很多的高速缓冲寄存器，用来存放当前访问的若干页表项，以加速地址变换的过程； 与此对应，内存中的页表称为慢表。 8.倒排页表 优点：减少占用的内存空间； 缺点：更长的查询时间；进程间共享内存实现更困难。 存储的时有关每个物理页框的信息，所以倒排页表项与物理内存页框有一一对应关系，它所包含的页表项数量较少。 Eample：物理地址空间4GB，页面长4KB，页表项大小为4B。故倒排页表共有4GB/4KB=1M个页表项，倒排页表大小为1M×4B=4MB。 系统维护一张倒排页表； 使用Hash散列，可以解决倒排页表不便于逻辑地址向物理地址转换的问题。 二、虚拟内存1.虚拟内存的基本概念虚拟内存只能基于非连续分配技术； 传统存储管理方式的特征，缺点 一次性(可用虚拟存储技术解决问题)：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题： 1.作业很大时，不能全部装入内存，导致大作业无法运行； 2.当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的，暂时用不到的数据，浪费了宝贵的内存资源。 局部性原理 时间局部性：如果执行力程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环) 空间局部性：一旦程序访问量某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中是连续存放的，并且程序的指令页式顺序的在内存中存放的) 虚拟地址的定义和特征定义在操作系统的管理下，用户看到似乎有一个比实际内存大得多的内存，就是虚拟内存。 特征 多次性：无需在作业运行时一次性全部装入内存，而是运行被分成多次调入内存； 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行的过程中，将作业换出，换入； 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量。 实现 请求分页存储管理； 请求分段式存储管理； 请求段页式存储管理。 请求分页系统建立在基本分页系统的基础上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种虚拟存储器方法。 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存(操作系统要提供请求调页或请求调段功能)，然后继续执行程序。 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存(操作系统要提供页面置换或段置换的功能)。 2.请求分页管理方式缺页中断定义：缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。 3.页面置换算法最佳置换法(OPT)先进先出置换算法(FIFO)最近最久未使用置换算法(LRU)时钟置换算法(CLOCK)(NRU:最近未使用)改进型的时钟置换算法老化算法 修改：第一是计数器在R位被加进来之前右移一位； 第二是将R位加到计数器的最左端； LRU的近似实现。 工作集置换算法 一个进程当前正在使用的页面集合称为它的工作集； 如果整个工作集都被装入到了内存中，那么进程在运行到下一运行阶段之前，不会产生很多缺页中断； 如果内存太小而无法容纳下整个工作集，那么进程的运行过程会产生大量的缺页中断，导致运行速度变得很缓慢； 原理： 进程设置一个虚拟时钟，执行一个时钟周期就加 1，不执行就不增加。 每个页面被访问时，记录最后访问的虚拟时间，R 位置 1。R 位定期 清除。 如果 R=1,则保留，将当前时间记录下来。 如果 R=0 对 比当前虚拟时间与页面最后访问时间差 age 与阈值 τ，如 age&gt;τ 则淘汰。如果 age &lt;= τ，则记录其访问时间，必要时淘汰其中最旧的。 总结 算法 算法规则 优缺点 OPT 优先淘汰最长时间内不会被访问的页面 缺页率最小，性能最好；但无法实现 FIFO 优先淘汰最先进入内存的页面 实现简单；但性能很差，可能出现Belady现象 LRU 优先淘汰最近最久没访问过的页面 性能很好；但需要硬件支持，算法开销大 CLOCK 循环扫描各页面，第一轮淘汰访问位=0的，并将扫描过的访问位改为1；若第一轮没选中，则进行第二轮扫描 实现简单，算法开销小；但未考虑页面是否被修改过 Improved CLOCK 若用(访问位，修改位)的形式表述，则第一轮淘汰(0,0)；第二轮淘汰(0,1)，并将扫描过的页面的访问位都置为0；第三轮淘汰(0,0)；第四轮淘汰(0,1) 算法开销较小，性能也不错 老化算法 4.页面分配页面分配，置换策略Points 增大块表(TLB)，让页表常驻内存能够加快虚实地址转换； TLB：转译后备缓冲区 段页式存储的实现结合了页式和段式管理的基本思想，即用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间； 交换区：存在于数据服务器上的一个共享文件夹。它的作用是为前台与后台数据交换提供一个场所； 当系统内存不足，特殊应用程序(如oracle，lotus notes等)有需求时，将挂载交换区空间； 主存==内存； Belady现象：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象； 系统抖动： - 解释为在请求分页存储管理中，从主存(DRAM)中刚刚患处某一页面后，根据请求马上又换入该页，这种反复换出换入的现象；- 主存与辅存间频繁的页面置换现象；- 产生该现象的主要原因是置换算法选择不当； 虚拟存储器只能基于非连续分配技术； 物理地址至少是：页表大小×物理存储区块数 Example：设有8页的逻辑空间，每页有1024B，它们被映射到32块的物理存储区中。 逻辑地址有效位：1024×8=2^3×2^10=2^13，即13位； 物理地址至少位数：1024×32=2^10×2^5=2^15，即15位； 无论用什么算法，缺页次数不会少于页面引用串中不同的页号的个数； 有些程序并不适合于按需调页，例如：二分法搜索； 可以被多个进程在任意时刻共享的代码必须是不能自身修改的代码； 若用户进程访问内存时产生缺页，则操作系统可能执行的操作是置换页或分配内存； 变址寄存器：至寄存器ESI,EDI,SI和DI的寄存器，它们主要用于存放存储单元在段内的偏移量； 变址寻址：把变址寄存器中的内容(通常是位移量)与指令地址码部分给出的地址(通常是首地址)之和作业操作数的地址来获得所需要的操作数； Example：假设变址寄存器 R 的内容为 1000H，指令中的形式地址为 2000 H；地址 1000H 中的内容为2000H，地址2000H中的内容为3000H，地址3000 H中的内容为4000H， 则变址寻址方式下访问到的操作数是： 4000H 解析：变址寻址方式下有效地址EA=R+A=1000H+2000H=3000H，操作数S=地址3000H中的内容，即4000H； 在请求分页系统中，页表中的辅存始地址是供页面调入参考的； 页表项中最多可以保存的标志位位数=页表项最大位数-页框号位数； Example：页表项大小为4B，页面大小为1KB，逻辑地址空间为32位，物理地址空间为4GB。 解：页表项共有4×8=32位；物理地址空间共32位；页内偏移量10位；页框号22位； ∴标志位位数=32-22=10位； 逻辑地址访问时间：设对主存的一次存取需要100ns，对TLB表查找的时间为10ns，缺页中断处理时间为10^8ns 逻辑地址对应的页号在内存中且在TLB表中：100+10=110ns； 逻辑地址对应的页号在内存中但不在TLB表中：10+100+100=210ns； 逻辑地址页号不在内存中：10^8+220ns。 页表项中有效位为0时，即不在内存中，缺页； 分段式内存管理解决了分页式内存管理中划分页时仅根据大小划分，这样可能将无关的内容分到一页中，此页不便设置权限与保护，也不利于共享。也有可能把密切相关的内容分到不同页中，当页面置换算法不当时，内存紧张时容易形成抖动现象。分段式内存管理带来的问题是段往往过大，多次分配释放后可能形成大量外部碎片，内存利用率不高； Intel IA32 的保护模式下内存管理方法不是段页式内存管理方法。因为段页式内存管理是分段时段内再分页，整个是一件事。而保护模式是通过分段将逻辑地址转换成线性地址，第二步通过分页将线性地址转成物理地址，这是两件事。 LRU 需求记录所有页面长期运行中被使用的时间和次数，需要大量的快速存 储空间，而且比较复杂，不容易实现。替代方案可以采用老化（aging）算法， 每个页面有一个长度有限的记数器，记录每个 tick 内 页面使用情况，记录信 息的权重逐次递减。这种算法与 LRU 相比，不能记录每个 tick 中内存使用情 况，而且记录的位数有限，但是实现方案较易实现。 分页式：逻辑地址空间划分只简单依靠页面大小，缺乏内在逻辑性，导致一方 面相关内容被分散 到多页上，页面置换不当时容易造成内存抖动，另一方面 不同性质的内容被分到同一页中，使得页面 权限保护设置困难。 分段式：段 体积大，在内存中无法不连续存储，易形成内存外碎片，降低内存利用率。 段页式：先分段再分页，以段为单位调入调出，以页为单位在内存中不连续存 储，既保证了相关内容 同时进出内存，便于设置权限保护，又可以充分利用 内存空间。 段页式结构复杂，实现起来效率低，所以没有被广泛采用。 最差适应分配最大空间的分区给进程使用，以期剩余外碎片空间较大，再 次利用的可能性较大。固定分区无外碎片，故不应采用这种算法。 交换技术交换的单位是进程，请求式分段技术交换的单位是段。 请求式分段是操作系统进行段调入调出，此过程对程序员透明，而覆盖技术需 要程序员自己完成调入调出。 页面置换应该在内存空余空间小于一个固定的下限阈值时开始，并在达到 另一个上限阈值时停止。 OPT 最理想但不可能实现。 LRU 要求比较最近最少 使用的页面，条件多，要存储的数据量大，比较的时间长，很难实现。 Belady 异常指的时当增加页框时缺页中断发生的数量反而升高的现象。 FIFO 存在 Belady 异常。 分段比分页更有逻辑性，将同类的或相关的内容放在一个段内，这样不会 由于页面置换算法选择不当而形成“抖动”现象。同类内容划分在一个 段内，可以实现段的保护，如代码段设置为只读，数据段设置为读写。公共代码段可以通过映射共享到多个进程。段页式既按照相关性划分 段，继承了分段的优势，又有分页管理可以不连续存储，能够充分利 用空间的好处。 缓存主要用于解决 CPU 和内存之间存在的速度差。一般来说，CPU 中寄 存器的速度要远快于内存，将 CPU 要用到的数据预先从内存中读到缓存，这 样 CPU 使用时就可以快速得到数据，写回内存的过程也类似。TLB 就是使用 缓存的一个典型例子。 在 64 位系统中，由于虚拟地址太大，普通页表会非常大，无法存储。另一方 面，实际内存 相对较小，所以建立一张从物理地址索引得到相对地址的倒排 页表。 最大的问题的难于从相对地址查找到绝对地址。可以采用 hash 表ᨀ高 查找效率，并使用 TLB 加速查找。 老化算法与 LRU 相比，主要有两点区别：（1）老化算法记录使用情况的 寄存器只有有限位， 比如 8 位，无法记录所有使用情况。（2）同一时间间隔 内只使用 0/1 区分页面使用情况，无法详 细区别间隔内的具体时间 内存分区管理中的交换技术与请求式分段技术的相同点与不同点：相同点都是为了在内存不足的情况下装入更多的进程，都是会产生外碎片。 不同点为交换 技术交换的对象是整个进程而请求式分段交换的进程中的一个段。","categories":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/categories/OS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"}]},{"title":"GTAV","slug":"GTAV","date":"2020-12-27T01:52:24.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2020/12/27/GTAV/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/27/GTAV/","excerpt":"","text":"","categories":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"}],"tags":[{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"GTAV","slug":"GTAV","permalink":"https://cheeseburgerim.github.io/tags/GTAV/"},{"name":"Fun","slug":"Fun","permalink":"https://cheeseburgerim.github.io/tags/Fun/"}]},{"title":"进程管理","slug":"OSChapter1","date":"2020-12-22T09:09:09.000Z","updated":"2021-04-11T04:26:34.099Z","comments":false,"path":"2020/12/22/OSChapter1/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/22/OSChapter1/","excerpt":"","text":"信号量(Semaphore) 一个整型变量； 按取值范围分类： 1.Semaphore∈R$$Semaphore=\\begin{cases}positive 可用资源数量\\Zero 无可用资源，无等待进程\\Negative 等待进程的数量\\\\end{cases}$$2.非负数 3.0/1(mutex，互斥锁)-二进制信号量 PV操作 ：一种实现进程互斥与同步的有效方法，P表示通过，V表示释放； P：s–，if(s&lt;0) add to the semaphore’s queue and sleep； V：s++，if(s&lt;=0) wake up the waiting process in the semaphore’s queue； 进程状态 只有running和ready之间可以相互转换 Example： Ready： 进程正等待进入内存； 进程正等待分给它一个时间片； Running： 进程正等待中央处理机； Blocked： 进程正等待合作进程的一个消息； 进程间关系 同步 进程之间这种相互合作，协同工作的关系称为进程的同步； 直接制约 多个相关进程在执行次序上的协调； 互斥 临界资源：也称独占资源，是指在一段时间内只允许一个进程访问的资源。例如打印机，磁带机，也可以是进程共享的数据，变量等； 间接制约； 当多个进程因为争夺临界资源二互斥执行称为进程的互斥。 进程与线程 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位； 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线； 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间，包括代码段，数据集，堆等，及一些进程及的资源，某进程内的线程在其他进程不可见； 不管系统中是否有线程，进程都是拥有资源的独立单位； 在不支持线程的操作系统中，进程既是资源分配的基本单位，也是调度的基本单位； 在拥有线程的操作系统中，线程是调度的基本单位，而进程是资源分配的基本单位； 对于切换时是否需要内核的支持，系统级线程需要，用户级线程不需要； 同一进程中的线程共享同一物理内存空间。 线程 用户态线程与内核态线程 所谓用户态线程就是把内核态的线程在用户态实现了一遍而已，目的是更轻量化（更少的内存占用、更少的隔离、更快的调度）和更高的可控性（可以自己控制调度器）。用户态所有东西内核态都「看得见」，只是对于内核而言「用户态线程」只是一堆内存数据而已。 死锁定义死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 当系统中供多个进程共享的资源如打印机，公共队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。 条件 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只有一个进程占用。如果此时还有其他进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放； 请求和保持条件：指进程已经保持至少一个资源，但是又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放； 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完成时自己释放； 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0,P1,P2,…,Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源,……,Pn正在等待已被P0占用的资源。 预防 采用按序分配资源策略可以防止死锁，这是因为它能破坏产生死锁的四个必要条件中的环路等待条件； 在操作系统中，常用以下方法应对死锁： 鸵鸟算法：因为处理死锁成本太高，而死锁出现的频率较低，故可以忽略死锁的发生； Spooling技术：假脱机技术。为临界资源增加一个等待队列，使其好像可以被共享使用，如打印机。 当死锁发生时，杀死运行时间较短的进程，损失较小，容易恢复。 用户态和内核态的转换方式 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作； 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常； 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这是CPU会暂停执行吓一跳即将要执行的指令而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的转换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 银行家算法定义银行家算法是一个避免死锁的著名算法，它以银行贷款系统的分配策略为基础，判断并保证系统的安全运行。 银行家算法可避免死锁，但没有破坏死锁发生的四个必要条件中的任何一个。 安全状态如果存在一个由系统中所有进程构成的安全序列P1,P2,…,Pn，则系统处于安全状态。安全状态一定是没有死锁发生。 不安全状态不存在一个安全序列。不安全状态不一定导致死锁。 时间片轮换调度算法定义每次调度时，总是选择就绪队列的队首进程，让其在CPU上运行一个系统预先设置好的时间片。一个时间片内没有完成运行的进程，返回到队列末尾重新排队，等待下一次调度。 进程饥饿定义指当等待时间给进程推进和响应带来明显影响称为进程饥饿。当饥饿到一定程度的进程在等待到即使完成也无实际意义的时候称为饥饿死亡。 预防公平的调度算法可以避免饥饿现象，例如时间片轮换算法，所有进程的地位相同； 例如静态优先级调度，非抢占式作业优先调度，抢占式短作业优先调度算法等可能导致饥饿现象。 非抢占式优先权调度算法 系统一旦把处理机分配给优先权最高的进程后，便一直执行下去至完成； 抢占式优先调度算法 只要系统中出现一个新的就绪进程，就进行优先权比较。若出现优先权更高的进程，则立即停止当前进程的执行，并将处理机分配给新到的优先权最高的进程。 处理机调度处理机调度的层次在多道程序系统中，调度实质是一种资源分配，处理机调度算法是指根据处理机分配策略随规定的处理机分配算法。一个作业从获得处理机执行到作业运行完毕，可能会经历多级处理机调度。 1.高级调度高级调度又称为长程调度或者作业调度，它的调度对象是作业。主要功能是根据某种算法，决定将外村上处于后备队列中哪几个作业调入内存，为它们创建进程，分配必要的资源，并将它们放入就绪队列。高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度。作业调度的频率很低，周期很长，大约几分钟一次。 2.中级调度中级调度又称为内存调度，引入中级调度的主要目的是，提高内存利用率和系统吞吐量。中级调度的作用就是将暂时不能运行的进程，调至外存等待(挂起转台)，和将外村上已满足条件的就绪进程调入内存中。内存调度的频率和周期处于作业调度和进程调度之间。 3.低级调度低级调度又称进程调度或者短程调度，它的调度对象是进程。其主要功能是，根据某种算法，决定就绪队列中的哪个进程获得处理机。并由分派程序将处理机分派给选择的进程。进程调度是一种最基本的调度，在多道批处理，实时和分时三种类型的OS中，都必须配置这级调度。进程调度的频率很高，周期很短，在分时系统中大概仅10-100ms。 先来先服务(FCFS) 短作业优先(SJF) 时间片轮转调度算法(RR) 高响应比优先调度(HRRN)：响应比=周转时间/执行时间=1+等待时间/执行事件 read：参数只包含输入流open：参数应包含文件的名称fork()函数 复刻(英语：fork，又译作派生，分支)是UNIX或类UNIX中的分叉函数，fork函数将运行着的程序分成两个(几乎)完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。这两个进程中的线程继续执行，就像是两个用户同时启动了该应用程序的两个副本。 fork系统调用用于创建一个新进程，称为子进程，它与进程(称为系统调用fork的进程)同时运行，此进程称为父进程。创建新的子进程后，两个进程执行fork()系统调用之后的下一条指令。子进程使用相同的pc(程序计数器)，相同的CPU寄存器，在父进程中使用的相同打开文件。 它不需要参数并返回一个整数值 $$return=\\begin{cases}positive &amp;{返回父进程或调用者。该值包含新创建的子进程的进程ID}\\zero &amp;{返回到新创建的子进程}\\nagetive &amp;{创建子进程失败}\\end{cases}$$ exec系列函数 用exec函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID。 系统调用exec系列函数后，fork函数创建的子进程才拥有自己独立的新代码段。 该系统调用替换进程的正文段，如果成功，没有返回值，如果失败，返回值为-1。 周转时间定义等待时间+程序执行事件，执行完成时间点-进入系统时间 平均周转时间=总周转时间/进程个数 平均带权周转时间(以执行时间为权值)=(Σ周转时间/执行时间)/进程个数 读者写者问题读者优先 写者，读者互斥访问文件资源； 多个读者可以同时访问文件资源 只允许一个写者访问文件资源。 写者优先 写者线程的优先级高于读者线程； 当有写者到来时应该堵塞读者线程的队列； 当有一个写者正在写或在阻塞队列时应当阻塞读者进程的操作，直到所有写者进程完成写操作时开放读者进程； 当没有写者进程时读者进程能够同时读取文件。 公平竞争 优先级相同； 写者，读者互斥访问； 只能有一个写者访问临界区； 可以有多个读者同时访问临界资源。 Points 可以被多个进程在任意时刻共享的代码必须是不能自身修改的代码。 若代码可以被多个进程在任意时刻共享，则要求一个进程在调用此段代码时都以同样的方式运行；而且进程在运行过程中被中断后再继续执行，其执行结果也不受影响。这必然要求代码不能自身更改，否则无法满足共享的要求。这样的代码就是可重入代码，也叫纯代码，即允许多个进程同时访问的代码。 共有n台互斥使用的同类设备，m个并发进程，分别需要x1,x2,…,xm个设备，为确保系统不发生死锁，n最小为x1+x2+…+xm-m+1； 分析：当每个进程都差最后一个设备时，即x1-1,x2-1,…,xm-1，这是申请不到最后一个设备，因此造成死锁，所以再添加一个设备即可； 中断指令：CPU正常运行期间，停止当前操作，执行其他特殊操作的行为就叫做中断，负责跳转的指令就是中断指令。中断指令不能在用户态执行，只能在内核态执行。 系统中进程执行时，I/O时间比决定了进程优先级，I/O时间比越大，进程优先级越高。 中断处理过程与子程序调用压栈时的区别： 都不需要保存通用数据寄存器和通用地址寄存器； 子程序调用时，由于系统硬件限制，只保存程序计数器的内容； 中断处理一定会保存而子程序调用不需要保存的内容时程序状态字寄存器。 CPU与I/O可同时进行 Example：一个多道批处理系统中仅有P1和P2两个作业，P2比P1晚5 ms到达。它们的计算和 I/O操作顺序如下： P1：计算 60 ms，I/O 80 ms，计算 20 ms P2：计算 120 ms，I/O 40 ms，计算 40 ms 若不考虑调度和切换时间，则完成两个作业需要的时间最少是260ms。 I/O操作：指对设备与CPU连接的接口电路的操作。 临界区：指的是一个访问公共资源(例如：共用设备或是共用寄存器)的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待，有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用，例如：信号量semaphore。只能被单一线程访问的设备，例如：打印机。 临界区是一段程序； 在进程处于临界区时可以进行处理机调度； 在系统调用完成并返回用户态时能进行处理机调度。 Example：假设系统中有4个进程和一个可分配资源，当前分配和最大需求如下表所示，已知资源总量为100。系统采用银行家算法避免死锁。 进程 MAX ALLOCATION NEED 1 50 20 30 2 50 15 35 3 50 30 20 4 50 10 40 在当前时刻若进程2请求资源数量为10，是否能实施分配？若能，给出安全序列。 解：资源数量：100，减去已分配的资源75，还剩25；这是进程2请求资源10＜25，但是当分配后资源数量剩余15，不存在一个安全序列。 ∴不能分配，因为分配后不存在安全序列。 当检测到死锁发生时，如果必须杀死一个进程以解除死锁，一般选择运行时间较短的进程，因为这样重新运行的代价较小，另外，程序需要可以多次运行不影响执行结果，还要考虑杀死优先级较低的进程等。 分时操作系统中的进程调度算法对普通进程常常采用的是优先级轮转法，采用动态调整进程优先级的方法，动态降低长时间占用CPU进程的优先级，低优先级进程的优先级则相对提高，最终得到运行。通过此方法，保证不会有进程因为优先级太低而饥饿。","categories":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/categories/OS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"}]},{"title":"LabOfOS1","slug":"LabOfOS1","date":"2020-12-22T03:28:13.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2020/12/22/LabOfOS1/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/22/LabOfOS1/","excerpt":"","text":"","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"}]},{"title":"Exercise","slug":"LabOfAlgorithm1","date":"2020-12-21T06:54:11.000Z","updated":"2021-04-11T04:26:34.100Z","comments":false,"path":"2020/12/21/LabOfAlgorithm1/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/21/LabOfAlgorithm1/","excerpt":"","text":"回溯法解决子集和数问题思路 回溯法可以理解成用深度优先算法遍历状态空间树，所以可以使用深度优先递归算法得到解； 定义MAXN为30，即暂时考虑最多有29个元素的集合； 在DFS函数中传入需要的参数： TotalWeight：当前子集中所选的元素之和； RestWeight：除选出的元素外剩余元素之和； x[ ]：问题的一个解，由0和1组成，0代表xi不取，1代表取，1≤i≤n； i：当前元素位置； n，m，w[ ]：元素个数，和数，和所给集合； 在DFS函数中： 当TotalWeight与m相等时，输出一个解； 加上当前元素时还小于m，考虑下一位置元素，继续递归； 若加上剩余元素时大于m，则不选择当前位置元素，继续递归； 递归结束时，即可得到所有解。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#define MAXN 30using namespace std;void Solution_DFS(int TotalWeight, int RestWeight, int x[], int i, int n, int m, int w[]);//回溯法解决子集和数问题int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; int w[MAXN] = &#123;0&#125;; int RestWeight = 0; for (int i = 1; i &lt;= n; i++) &#123; int temp; cin &gt;&gt; temp; w[i] = temp; RestWeight += temp; &#125; int x[MAXN] = &#123;0&#125;; Solution_DFS(0, RestWeight, x, 1, n, m, w); &#125; system(&quot;pause&quot;); return 0;&#125;void Solution_DFS(int TotalWeight, int RestWeight, int x[], int i, int n, int m, int w[])&#123; if (i &gt; n) &#123; if (TotalWeight == m) &#123; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; x[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; &#125; else &#123; if (TotalWeight + w[i] &lt;= m) &#123; x[i] = 1; Solution_DFS(TotalWeight + w[i], RestWeight - w[i], x, i + 1, n, m, w); &#125; if (TotalWeight + RestWeight &gt; m) &#123; x[i] = 0; Solution_DFS(TotalWeight, RestWeight - w[i], x, i + 1, n, m, w); &#125; &#125;&#125; Examples链接：link num\\ N M 1 8 53 2 10 5482 3 21 2463098 4 10 50 5 9 100 6 6 22 7 10 50 动态规划解决矩阵乘法链问题思路 使用动态规划方法解决矩阵乘法链问题，需在不同大小的子问题的优化值之间建立递归关系，得到最优解； 同时满足优化原理，即优化解包含的子问题的解也是优化解。使用枚举法建立不同长度子问题的优化值之间的递归关系； 求此问题的优化解，即求c(1,n)，c(1,n)=min{c(1,k)+c(k+1,n)+r1×r(k+1)×rn}，利用此式得到问题的解，再根据每次得到的k值回溯找到优化的乘法顺序； 在代码中，可以使用二维数组存放每次递归关系式中大括号中的每个值，最后找到最小值，即可得到问题的优化解。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;//动态规划解决矩阵乘法链问题const int INT_MAX=2147483647;const int MAXN=10;void Solution(int *r,int Length,int m[][MAXN],int s[][MAXN]);void POMCWP(int s[][MAXN],int i,int j);//Acronyms Print Optimal Matrix Chain With Parenthesesint main()&#123; int n; while(cin&gt;&gt;n) &#123; int r[MAXN]=&#123;0&#125;; for(int i=0;i&lt;n+1;i++) &#123; int temp; cin&gt;&gt;temp; r[i]=temp; &#125; int m[MAXN][MAXN],s[MAXN][MAXN]; Solution(r,n+1,m,s); cout&lt;&lt;&quot;Minimum: &quot;; cout&lt;&lt;m[1][n]&lt;&lt;endl; cout&lt;&lt;&quot;Order: &quot;; POMCWP(s,1,n); &#125; system(&quot;pause&quot;); return 0;&#125;void Solution(int *r,int Length,int m[][MAXN],int s[][MAXN])&#123; int q,n=Length-1; for(int i=1;i&lt;=n;i++) m[i][i]=0; for(int l=2;l&lt;=n;l++) &#123; for(int i=1;i&lt;=n-l+1;i++) &#123; int j=i+l-1; m[i][j]=INT_MAX; for(int k=i;k&lt;=j-1;k++) &#123; q=m[i][k]+m[k+1][j]+r[i-1]*r[k]*r[j]; if(q&lt;m[i][j]) &#123; m[i][j]=q; s[i][j]=k; &#125; &#125; &#125; &#125;&#125;void POMCWP(int s[][MAXN],int i,int j)&#123; if(i == j) cout&lt;&lt;&quot;M&quot;&lt;&lt;i; else &#123; cout&lt;&lt;&quot;(&quot;; POMCWP(s,i,s[i][j]); POMCWP(s,s[i][j]+1,j); cout&lt;&lt;&quot;)&quot;; &#125;&#125; ExamplesQ：p[MAXN]={30,35,15,5,10,20,25}； A：程序输出 12Minimum: 15125Order: ((M1(M2M3))((M4M5)M6)) Q：p[MAXN]={10,20,50,1,100}; A：程序输出 12Minimum: 2200Order: ((M1(M2M3))M4)","categories":[{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"}]},{"title":"Branch and Bound","slug":"AlgorithmChapter8","date":"2020-12-17T07:26:29.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2020/12/17/AlgorithmChapter8/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/17/AlgorithmChapter8/","excerpt":"","text":"分枝-限界法分枝(Branching) 分枝：一个节点成为E-节点后，它要展开它的所有子节点；并将这些子节点放在一个称为活节点表的数据结构中；在活节点表中的节点可以展开所有状态空间树的节点，即广度优先遍历状态空间树； 按一定的规则从活节点表中取出一个节点作为E-节点进行展开； 活节点表可以是FIFO,LIFO和优先级队列； 当使用优先级队列时必须对活节点表中的节点赋以一个权值； 下文将结合求解优化为题介绍一种使用优先级队列的分枝-限界法。 最小成本优化问题 设x=(x1,x2,…,xn)为可行解的元组； 对每一个可行解有一个成本值，cost(x)； 求使cost(x)达到最小的可行解x； 使用搜索算法求解最小成本优化问题。 任意节点的成本函数c(x) 定义状态空间树上任一节点x的成本函数c(x)如下； 如x为可行叶节点，则c(x)=cost(x)； 否则，定义c(x)=从x展开状态空间树能得到的最小成本值(状态空间树上以x为根的子树中可行解成本的最小值)； 如其子树中无可行解，则c(x)=∞。 LC-检索 如果活节点表中每个节点以c(x)为权值，每次从活节点表中取出最小权值节点作为E-节点，则算法能很快找到优化解； 但在展开x前不可能知道c(x)的值。但是有可能从历史信息获得c(x)的某一下界c^(x)； 以c(x)的下界估值c^(x)作为活节点表中节点的权值，每次取出有最小c^(x)的节点进行展开； 要求设计的c^(x)满足：c^(x)=cost(x)，当x为可行叶节点时。 限界 令U为当前获得的最优成本值； 设x=(x1,x2,…,xn)，如果c^(x)&gt;=U，则停止展开子节点x，即，不将其放入活节点表； U初始值为∞，其后每一次的到一个新的可行解，用其成本值对U加以修改：U⬅min{U,cost(x)}。 Example：带截止期的作业调度问题 n个作业，1台处理机，每个作业i对应一个三元组(pi,di,ti)； pi：罚款额； di：截止期； ti：需要的处理机时间； 求可行的作业子集J，使得罚款额最小，其中j为不在J中的作业； 定长元组表示可行作业子集：(x1,x2,…,xn)； 设X=(x1,x2,…,xk)为状态空间树的节点； 下界c^(x)可估计为展开到x时已得到的罚款额：Σ(1-xj)pj，求和范围为1&lt;=j&lt;=k。 例题 LC-分枝-限界产生的部分状态空间树 调度问题的另一种状态空间树 可行条件(截止期)作为一种限界方法； c^(x)&gt;=U为另一限界方法； 下图中每个节点标注了2个数，上边的数为c^(x)，下边的数为该节点对应的可行解的罚款额，作为u(x)； 方框节点是非可行节点； 打叉的节点是被限界掉的节点。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Traceback","slug":"AlgorithmChapter7","date":"2020-12-15T10:24:06.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2020/12/15/AlgorithmChapter7/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/15/AlgorithmChapter7/","excerpt":"","text":"回溯Example：8-皇后问题 8皇后问题的解可以表示为一个8-元组(x1,x2,…,x8)，其中xi是放在第i行的皇后所在的列号，则8皇后问题可形式化为pow(8,8)个8-元组中找满足以下约束条件的元组： 对于任意的i≠j，有xi≠xj；|xi-xj|≠|i-j|； 这pow(8,8)个8-元组构成的集合成为8皇后问题的解空间-搜索范围； 如果将约束条件之一，任意两个皇后不在同一列，加入到元组的定义中，这是每个8-元组为(1,2,3,4,5,6,7,8)的一个排列，解空间的大小由pow(8,8)个元组减少到8！个元组； 解空间不是唯一的，取决于算法的设计； 设计解空间时还要考虑生成解空间的算法复杂度；在8皇后问题中，如果加入第二个条件，解空间很难形成。 搜索问题的形式化-解空间 假定问题的解能用n-元组(x1,x2,…,xn)表示，其中xi取自某个有穷集Si； 这些n-元组构成的集合成为问题的解空间；假设|Si|=mi，则解空间的大小为m=m1m2…*mn； 我们考虑两类问题： 存在性问题：求满足某些条件的一个或全部元组，如果存在返回Yes，否则返回No。这些条件称为约束条件； 优化问题：给定一组约束条件，在满足约束条件的元组中求使某目标函数达到最大(小)值的元组。满足约束条件的元组成为问题的可行解。 解决这类问题的最一般方法使使用搜索技术，即系统化地搜索解空间地技术。 Example：子集和数问题 已知n+1个整数：wi，1&lt;=i&lt;=n，和M。要求找出{wi|1&lt;=i&lt;=n}的所有子集，使得子集内元素之和等于M； 例如：n=4，(w1,w2,w3,w4)=(11,13,24,7)，M=31。则满足要求的子集是(11,13,7)和(24,7)； 我们可以用wi的下标i构成的元组表示一个解，则这两个解可表示为(1,2,4)和(3,4)； 元组(1,2,4)和(2,1,4)代表同一子集，此为限制元组分量按升序排列，即不考虑元组(2,1,4)； 还可用其他方式表示一个解，如下： 解空间的状态空间树 任何搜索算法都可以用建立在解空间上的状态空间树加以描述； 状态空间树是我们尝试选择元组的各个分量时产生的树结构； 搜索算法并非事先将状态空间树存在计算机内再进行遍历，而是通过展开状态空间树来找所求的解； 展开过程中通过使用启发式的限界方法(剪去状态空间树上的某些分支)使搜算算法只展开状态空间树的一部分，从而降低搜索算法的时间和空间复杂度。 Example：n-皇后问题 n-皇后问题是8-皇后问题的推广。n个皇后将被放置在n×n的棋盘上且使得没有两个皇后可以互相攻击，其解空间由n-元组(1,2,…,n)的n！个排列组成； 其状态空间树如下图所示(n=4)。树的边由xi的可能的取值标记。由i级到i+1级节点的边给出xi的值，这种树成为排列树； 从根节点到叶节点的一条路径对应解空间的一个元组。 有关状态空间树的术语 状态空间树的每个节点代表问题求解过程中达到的一个状态，根节点到它的路径代表对一些分量已作出的选择。状态空间树的所有节点构成的集合成为求解该问题的状态空间； 根节点到状态空间树的一个节点X的路径可以表示为(x1,x2,…,xk)，其中xi，1&lt;=i&lt;=k，为搜索过程中已经选择的分量。今后我们也用这个元组标识该节点：X=(x1,x2,…,xk)； (x1,x2,…,xk)也对应一个子问题，即在后n-k个元组分量所对应的子空间上找满足要求的解。该子空间是状态空间树中以X为根的子树。所以也称节点X为问题节点； 如果从根节点到节点S的那条路径确定了解空间的一个元组，则称S为状态空间树的一个解节点； 如果一个解节点S(代表的元组)满足所有约束条件，则称其为答案节点。 状态空间树的展开方法 每个搜索算法都是一种系统地展开状态空间树地算法； 活节点：已展开了部分节点，但所有子节点尚未全部展开的节点； 死节点：被限界或已展开了所有子节点地节点； E-节点：当前正在展开子节点的活节点。 深度优先展开方法：一个E-节点展开自己的一个子节点后，就让该子节点成为E-节点的展开方法(相当于对状态空间树做深度优先搜索)。 回溯法：加限界的深度优先展开状态空间树的方法； 分枝-限界法：一个节点一旦成为E-节点，它将展开其全部子节点，之后自己变成死节点； 在分枝-限界法中要维持一个活节点表的结构，存放已展开但还未成为E-节点的那些节点。 限界 用回溯法解4-皇后问题 回溯的一般方法 每个解用数组X(1,n)来表示； 假定X1，X2,…,X(k-1)的值已确定，T(X1,X2,…,X(k-1))代表xk的所有可能的取值； 限界函数B(X1,X2,…,XK)判断那些Xk的取值不能导致问题的解，从而停止展开该子节点。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Dynamic Programming","slug":"AlgorithmChapter6","date":"2020-12-15T09:55:46.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2020/12/15/AlgorithmChapter6/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/15/AlgorithmChapter6/","excerpt":"","text":"动态规划应用 0/1背包问题 矩阵乘法链 最短路径 最长公共子序列 原理 从算法设计的角度看，动态规划是一种在各个不同大小(size)的子问题的优化值之间建立递归关系并求解的过程； 能用动态规划求解的问题必须满足优化原理：优化解包含的子问题的解也是优化的； 利用优化原理，使用枚举法建立不同长度子问题的优化值之间的递归关系——动态规划方程； 动态规划得到的是精确解； 子问题的数目决定算法的复杂性； 实现时要尽可能消去递归。 Example：多段图-最短路径 多段图问题满足优化原理：最短路(1-&gt;3-&gt;5-&gt;7)上的子路径(3-&gt;5-&gt;7)是3到目的节点7在子图上的最短路； 无论最短路的下一跳是{2，3，4}中的那个节点，其后的路径也应是最短路； 节点1到目的的节点的最短路长度c(1)可从2，3，4到目的节点的最短路c(i)+节点1到这些节点的边成本cost(1,i)经枚举得到：c(1)=min{c(i)+cost(1,i)}，i∈{2，3，4}。 但2，3，4到目的节点的最短长度c(2),c(3),c(4)还不知道； 我们需计算c(2),c(3),c(4)；仍使用优化原理； 一般情形：设c(i)为i到目的节点的最短路长度，A(i)为与i相邻的节点集合，有：c(i)=min{c(j)+cost(i,j)}，j∈A(i)； 但c(i)由i到目的节点的子图在决定，和节点1怎样走到i没关系。 多段图的动态规划算法 从c(7)开始向前计算； 初始c(7)=0； 依次计算c(6),c(5),…,c(1)； c(6)=1，c(5)=2； c(4)=8+c(6)； c(3)=min{1+c(5),5+c(6)}； c(2)=min{7+c(5),6+c(6)}； c(1)=min{1+c(2),4+c(3),6+c(4)}； 递归还可以从前向后。 Example：0/1背包问题 0/1背包问题的解指物品1,2,…,n的一种放法(x1,x2,…,xn的0/1赋值)，使得效益值最大； 假定背包容量不足以装入所有物品：面临选择； 因为目标函数是非负数之和； 优化原理：无论优化解是否放物品1，相对剩余背包容量，优化解对物品2,3,…,n的放法也是优化解。 优化值间的递归式 虽然我们不知道优化解是否放物品1，但我们可以利用优化原理，从枚举”放”和”不放”两种情形建立优化值之间的递归式： 设f(i,y)为以背包容量y，放物品i,i+1,…,n，得到优化效益值，一下递归关系成立： f(1,c)=max{f(2,c),f(2,c-w1)+p1}(不放1和放1)； 先求子问题的优化值(递归)，再从2种可能性中选出最优的； 需求解：任意给定容量y，任意i,i+1,…,n种物品的子问题。 动态规划法步骤 在应用动态规划法时，须先验证欲求解的问题是否满足优化原理； 应用优化原理建立子问题优化解的值(优化值)之间的递归式； 解优化值满足的递归式； 回溯从优化值构造优化解； 算法复杂性 直接用递归实现动态规划递归方程往往会引发大量重复计算，算法的计算量变得非常可观；最好使用迭代法实现动态规划算法； 迭代实现需要存贮所有子问题的优化解的值f(i,y)，以便避免重复计算，所以算法往往需要较大的存储空间； 算法的复杂性来自子问题的数目，通常子问题的数目很大。 0/1背包问题DP算法的实现1.递归实现$$f(n,y)=\\begin{cases}Pn &amp; y≥wn\\0 &amp; 0≤y&lt;wn\\end{cases}$$ $$f(i,y)=\\begin{cases}max(f(i+1,y),f(i+1,y-wi)+pi) &amp; y≥wi\\f(i+1,y) &amp; 0≤y&lt;wi\\end{cases}$$​ 说明：f(i,y)中，y≥wi的情况中，前者为不放i，后者为放i Example： 2.权为整数的迭代实现 当物品重量为整数时，可设计一相当简单的算法来求解f(1,c)； 该实现用二维数组 f [i] [y] 来保存每个f(i,y)的值，并且只计算一次； 二维数组需Θ(nc)空间； 函数Traceback从 f [i] [y] 产生优化的xi值； Knapsack的复杂性Θ(nc)，似乎是多项式算法。但因c的二进制输入长度为logc(2为底)，所以nc仍是输入长度的指数函数； Traceback的复杂性为Θ(n)。 Example：n=5，p=[6,3,5,4,6]，w=[2,2,6,5,4]，且c=10，求f(1,10) i\\y 0 1 2 3 4 5 6 7 8 9 10 缺点： 要求物品重量为整数； 当背包容量c很大时，例如c&gt;2^n，需要Ω(n*2^n)。 下述元组法克服了上述缺点。 3.元组法实现 元组法将函数f(i,y)的跳跃点以元组(y,f(i,y))形式存储于一个线性表P(i)中； 表P(i)中的元组(y,f(i,y))按y的增序排列； P(i)中的元组(a,b)表示：存在一种装物品{i,i+1,…,n}的方案，能以容量y，a≤y＜a‘，a’为下一元组的横坐标，得到效益值b； 下面给出从f(i+1,y)的线性表P(i+1)得出f(i,y)的线性表P(i)的算法； 按f(i,y)的定义：f(i,y)=max{f(i+1,y),f(i+1,y-wi)+pi}，首先需要从P(i+1)得到函数f(i+1,y)=f(i+1,y-wi)+pi的元组集合Q； 设(a,b)∈Q，则(a-wi,b-pi)必为P(i+1)的元组，反之亦然。所以，P(i+1)的每个元组(w,p)对应Q的一个元组(w+wi,p+pi)； Q的元组(u,v)代表装物品{i,i+1,…,y}的元组(即P(i)的元组)； 从P(i+1)和Q得到P(i)的元组： 因P(i+1)和Q内元组均按w和p的增序排列，所以可以用以前学过的merge算法进行合并； 合并时使用以下支配(选优)规则： 设(a,b)和(u,v)是来自P(i+1)和Q的元组，若a≥u且b＜v，则称(a,b)受(u,v)支配； 因为(a,b)代表以容量a得到效益值b的方案； 而(u,v)代表以较少的容量u得到较大效益值v的方案； 在合并时舍弃被支配的元组(选优)。 P(i+1)于Q合并，并按支配规则舍弃被支配的元组即可得到P(i)； 在产生P(i)时丢弃w&gt;c的元组(w,v)； 得到P(2)后不再产生P(1)： P(2)的最后一个元组是f(2,c)对应的元组； 设线性表P(2)中满足w+w1≤c的最后一个元组为(w,v)； 将v+p1于P(2)的最后一个元组对应的效益值p做比较，效益值大的即为优化效益值f(1,c)。 Example：n=5，p=[6,3,5,4,6]，w=[2,2,6,5,4]，且c=10，求f(1,10) 方便起见，w=[2,2,6,5,4]，p=[6,3,5,4,6]，(横坐标为W，纵坐标为P) P(5)={(0,0),(4,6)}, Q={(5,4),(9,10)}; P(4)={(0,0),(4,6),(9,10)}, delete(5,4), Q={(6,5),(10,11)}; P(3)={(0,0),(4,6),(9,10),(10,11)}, delete(6,5), Q={(2,3),(8,8),(7,7),(6,9)}; P(2)={(0,0),(2,3),(4,6),(6,9),(9,10),(10,11)}; (w1,p1)=(2,6)，P2中满足w+w1≤c的最后一个元组为(6,9)； ∵ (2,6)+(6,9)&gt;(10,11) ∴15为最大效益值，通过回溯法找到解为[1,1,0,0,1] 矩阵乘法链 m×n矩阵A于n×p矩阵B相乘需要做mnp个元素乘法； 计算三个矩阵A，B和C的乘积ABC有两种方法：(AB)C和A(BC)； 结果相同，但所需元素乘法数不同； 问题：对任意给定长度q的矩阵乘法链M1×M2,…,Mq，求优化的乘法顺序使得计算该乘法链所用的乘法数最少； 长度为q的矩阵乘法链有指数量级Ω(2^q)的可能乘法顺序(有q个叶节点的二叉树的数目)； 动态规划解 用M(i,j)表示Mi×Mi+1×…×Mj(i≤j)的乘积。假设优化的矩阵乘法顺序最后计算乘积M(i,k)×M(k+1,j)； 则计算M(i,j)的优化乘法顺序在计算子链M(i,k)和M(k+1,j)时也是优化的； 设c(i,j)为计算M(i,j)的优化乘法数(优化值)，根据优化原理，优化值之间满足： c(i,j)=min{c(i,k)+c(k+1,j)+ri*r(k+1)*r(j+1)}，i≤k&lt;j； 令kay(i,j)为达到最小值的k； 可用上述递归式计算c(1,q)； 用kay(i,j)回溯找到优化的乘法顺序。 Example：q=5，r=(10,5,1,10,2,10) 递归 c(1,5)=min{c(1,1)+c(2,5)+500, c(1,2)+c(3,5)+100, c(1,3)+c(4,5)+1000, c(1,4)+c(5,5)+200}; c(2,5)=min{c(2,2)+c(3,5)+50, c(2,3)+c(4,5)+500, c(2,4)+c(5,5)+100}; c(3,5)=min{c(3,3)+c(4,5)+100,c(3,4)+c(5,5)+20}; c(4,5)=min{c(4,4)+c(5,5)+200}=200; c(3,5)=c(3,4)+c(5,5)+20=20+0+20=40; c(2,5)=c(2,2)+c(3,5)+50=0+40+50=90; c(1,5)=c(1,2)+c(3,5)+100=50+40+100=190; 解为M(1,2)×M(3,4)×M(5,5); 迭代：可避免大量重复计算，但需要O(q²)的存储空间，时间复杂度为Θ(q³)。 s=2，3，4； s=2，计算c(1,3),c(2,4),c(3,5); s=3，计算c(1,4),c(2,5); s=4，计算c(1,5). All-Pair最短路问题 最短路径：设G为有向图，其中每条边都有一个成本(cost)，图中每条有向路径的长度(或成本)定义为该路径上各边的成本之和； 对于没对顶点(i,j)，定义从i到j的所有路径中，具有最小长度的路径为从i到j的最短路； All-Pair最短路问题：求每对点间的最短路； 假定图上无负成本的环路，这是只需考虑简单路径，加上环路只会增加路径成本。 动态规划解： 将节点按1到n编号； 定义c(i,j,k)=i到j的中间节点编号不超过k的最短路长度，即包含节点i和j即节点1,2,…,k的子图上的最短路； c(i,j,n)是在原来的图上i到j的最短路长度，即我们要求的最短路长度； 因为只考虑简单路径，所以： c(i,k,k)=c(i,k,k-1); c(k,j,k)=c(k,j,k-1); c(i,i,k)=0 for all k; 特别地，c(i,j,0)=cost(i,j)或∞。 Example： 建立c(i,j,k)和c(i,j,k-1)之间的递归关系； 对于任意k＞0，i到j的中间节点编号不超过k的最短路上，或包含节点k或不包含节点k，所以有递归如下： c(i,j,k)=min{c(i,j,k-1),c(i,k,k-1)+c(k,j,k-1)}； 如果直接用递归程序求解上式，则计算c(i,j,n)的复杂度极高。利用迭代方法可将计算c值得时间减少到O(n)³。 迭代算法伪代码： n令C(k)代表矩阵(c(i,j,k))i,j=1,…,n,因c(i,i,k)=0 for all k,所以矩阵C(k)的对角线元素为0. n算法迭代计算C(k) ,k=0,…,n n初始C(0)=(c(i, j)),即图的邻接矩阵,无边相连的i和j 令c(i, j)=∞. n因c(i,k,k)=c(i,k,k-1),c(k,j,k)=c(k,j,k-1),所以,矩阵C(k)的k行、k列上的元素不变: C(k)(i,k)=C(k-1)(i,k), C(k)(k,j)=C(k-1)(k,j). n矩阵C(k)非k行、k列上的元素,按下式计算 C(k)(i,j)←min{C(k-1)(i, j), C(k-1)(i, k)+ ​ C(k-1)(k,j)}, 即C(k)(i,j)←min{C(k-1)(i, j), C(k)(i, k)+ ​ C(k)(k,j)}, n所以算法只需使用一个矩阵,每次迭代时, 用第k列的i行元素和第k行的j列元素之和去更新元素C(k-1)(i, j). n算法迭代至多n次，每次迭代需O(n2)时间，所以算法的时间复杂度为O(n3). Example：最短路径 解： C(3)(1,2)=min{C(2)(1,2), C(2)(1,3)+C(2)(3,2)}=min{4, 6+7}=min{4, 13}=4; C(3)(2,1)=min{C(2)(2,1), C(2)(2,3)+C(2)(3,1)}=min{6, 2+3}=min{6, 5}=5. 最长公共子序列问题 首先需要说明，子序列与字串不同 一个给定的序列的子序列，就是将给定序列中零个或多个元素去掉之后的结果； 字串指给定串中任意个连续的字符组成的子序列； 可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中，可以避免大量的重复计算； 递归方程如下： $$C(i,j)=\\begin{cases}0,&amp;if&amp;i=0orj=0\\C[i-1，j-1],&amp;if&amp;i,j&gt;0andx_i=y_i\\max{C[i,j-1],c[i-1,j]}&amp;if&amp;i,j&gt;0andx_i≠y_i\\end{cases}$$ Example：s1=[1,3,4,5,6,7,7,8]，s2=[3,5,7,4,8,6,7,8,2] 下标j 0 1 2 3 4 5 6 7 8 9 下标i s2 3 5 7 4 8 6 7 8 2 0 s1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 2 3 0 1 1 1 1 1 1 1 1 1 3 4 0 1 1 1 2 2 2 2 2 2 4 5 0 1 2 2 2 2 2 2 2 2 5 6 0 1 2 2 2 2 3 3 3 3 6 7 0 1 2 3 3 3 3 4 4 4 7 7 0 1 2 3 3 3 3 4 4 4 8 8 0 1 2 3 3 4 4 4 5 5 右下角元素即为最长公共子序列长度，得到问题的解。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Divide and Conquer","slug":"AlgorithmChapter5","date":"2020-12-15T02:18:48.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2020/12/15/AlgorithmChapter5/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/15/AlgorithmChapter5/","excerpt":"","text":"分治法分治法思想 分治法设计算法的思想是： 将问题分成(divide)多个子问题； 递归地解决(conquer)每个子问题； 将子问题的解合并(combine)成原问题的解。 分治法常常得到递归算法； Merge-Sort是用分治法设计算法的范例 算法复杂性分析 Master method Substitution method 适用条件 分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定程度就可以容易地解决； 该问题可以分解为若干个规模较小的子问题； 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 最后一条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用动态规划较好。 基本步骤12345678910divide-and-conquer(P)&#123; if(P&lt;=n0) adhoc(P); //解决小规模的问题 divide P into smaller subinstances P1,P2,...,Pk; //分解问题 for(int i=1;i&lt;=k;i++) &#123; yi=divide-and-conquer(Pi); //递归地解决各子问题 return merge(y1,...,yk); //将各子问题地解合并成为原问题的解 &#125;&#125; 人们从大量实践中发现，在用分治法设计算法时，最好使子问题的规模大致相同。即将一个字问题分成大小相等的k个子问题的处理方法是行之有效的。这种使子问题规模大致相等的做法好是出自一种平衡子问题的思想，它几乎总是比子问题规模不等的做法要好。 应用1.Defective Chessboard n=pow(4,k)； 需要(n-1)/3个3-方块填满棋盘； 算法的时间复杂度：t(n)=4t(n/4)+c，a=4，b=4，loga=1。∴t(n)=Θ(n)。 2.归并排序(Merge Sort) 我们采用平衡分割法来分割n个元素，即将n个元素分为A和B两个集合，其中A集合中含有n/k个元素，B中包含其余的元素； 然后递归地使用分治法对A和B进行排序； 当A或B内元素&lt;k时使用插入排序； 然后采用一个成为归并(merge)的过程，将已排好序的A和B合并成一个集合。 123456789101112131415template&lt;class T&gt;void sort(T E,int n)&#123;//对E中的n个元素进行排序，k为全局变量 if(n&gt;=k) &#123; i=n/k; j=n-i; 令A包含E中的前i个元素 令B包含E中余下的j个元素 sort(A,i); sort(B,j); merge(A,B,E,i,j); //把A和B合并到E &#125; else 使用插入排序算法对E进行排序&#125; 算法复杂度： 设t(n)为分治排序算法，则有以下递推公式 当n/k≈n-(n/k)时，t(n)的值最小(balance原理) 因此，当k=2时，分治法通常具有最佳性能：当k&gt;2时递归展开的深度超过 以2为底n的对数。 k=2时，有 3.快速排序(Quick Sort) 分治法还可以用于实现另一种完全不同的排序方法：快速排序； 在这种方法中，n个元素被分成三段，左短left，中段middle，右段right； 中段仅包含一个元素；左段中各元素都小于等于中段元素；右段中各元素都大于等于中段元素。因此left和right中的元素可以独立排序，并且不必对left和right的排序结果进行合并，middle中的元素被成为支点(pivot)。 1234567//伪代码//使用快速排序方法对a[0:n-1]排序//从a[0:n-1]中选择一个元素作为middle，该元素为支点//把余下的元素分割成为两段，left和right，使得left中的元素都小于等于支点，right中的元素都大于等于支点//递归地使用快速排序方法对left进行排序//递归地使用快速排序方法对right进行排序//所得结果为left+middle+right 快速排序的平均复杂性是Θ(nlogn)。 各种排序算法的比较 排序方法 比较次数 移动次数 稳定性 附加存储 最好 最差 最好 最差 最好 最差 直接插入排序 n n² 0 n² √ 1 1 折半插入排序 nlogn nlogn 0 n² √ 1 1 冒泡排序 n n² 0 n² √ 1 1 快速排序 nlogn n² nlogn n² × logn n² 简单选择排序 n² n² 0 n × 1 1 锦标赛排序 nlogn nlogn nlogn nlogn √ n n 堆排序 nlogn nlogn nlogn nlogn × 1 1 归并排序 nlogn nlogn nlogn nlogn √ n n 4.选择(Selection Problem) 定义：对于给定的n个元素的数组a[0:n-1]，要求从中找出第k小的元素； 选择问题可在O(nlogn)时间内解决，方法是首先对这n个元素进行排序(如使用堆排序或归并排序)，然后取出a[k-1]中的元素； 若使用快速排序，可以获得更好的平均性。尽管该算法在最坏情形下有一个比较差的渐进复杂性O(n²)。 123456789101112131415161718192021222324252627282930313233343536template&lt;class T&gt;T Select(T a[],int n,int k)&#123; //返回a[0:n-1]中第k小的元素 //假定a[n]是一个伪最大元素 if(k&lt;1||k&gt;n) throw OutOfBound(); return select(a,0,n-1,k);&#125;template&lt;class T&gt;T select(T a[],int l,int r,int k)&#123; //在a[l:r]中选择第k小的元素 if(l&gt;=r) return a[l]; int i=l;//从左至右的游标 int j=r+1;//从右到左的游标 T pivot=a[l]; //把左侧&gt;=pivot的元素与右侧&lt;=pivot的元素进行交换 while(1) &#123; do&#123;//在左侧寻找&gt;=pivot的元素 i=i+1; &#125;while(a[i]&lt;pivot)； do&#123;//在右侧寻找&lt;=pivot的元素 j=j-1; &#125;while(a[j]&gt;pivot) if(i&gt;=j) break;//未发现交换对象 Swap(a[i],a[j]); &#125; if(j-l+1==k) return pivot; //设置pivot a[l]=a[j]; a[j]=pivot; //对一个段进行调用 if(j-l+1&lt;k) return select(a,j+1,r,k-j+l-1); else return select(a,l,j-1,k);&#125; 上述程序复杂度分析： 最坏情况下复杂性是Θ(n²)； 如果left和right总是同样大小或者相差不超过一个元素，那么可以得到以下递归式： 如果n是2的幂，则通过使用迭代方法，可以得到t(n)=Θ(n)； 提示：选择较好的pivot可得到较好的性能。 中间的中间规则： 若仔细地选择支点元素，则最坏情况下的时间开销也可以变成Θ(n)； 一种选择支点元素的方法是使用“中间的中间(median-of-median)”规则：首相将数组a中的n个元素分成n/r组，r为某一整常数，除了最后一组外，每组都有r个元素。然后通过在每组中对r个元素进行排序来寻找每组中位于中间位置的元素。最后对所得到的n/r个中间元素，递归使用选择算法，求得“中间之中间”作为支点元素。 Example： 距离最近的点对 问题描述：给定平面上n个点，找其中的一对点，使得在n个点所组成的所有点对中，该点对距离最小； 严格来讲，最接近点对可能多于一对，为简便起见，我们只找其中的一对作为问题的解； 一个简单的做法是将每一个点于其他n-1个点的句里算出，找出最小距离的点对即可。该方法的时间复杂性是T(n)=n(n-1)/2 + n = O(n²)，效率较低； 一维空间中的情形 为了使问题易于理解和分析，先来考虑一维的情形。此时，S中的n个点退化为x轴上的n个实数x1，x2，…，xn。最接近的点对即为这n个实数中相差最小的两个实数； 一个简单的办法就是先把x1，x2，…，xn排好序，再进行一次线性扫描就可以找出最接近点对，T(n)=O(nlogn)。然而这种方法无法推广到二维情形； 假设我们用x轴上某个点m将S划分为2个子集S1和S2，基于平衡子问题的思想，用S中各点坐标的中位数来作分割点； 递归地在S1和S2上找出最接近点对{p1，p2}和{q1，q2}，并设d=min{|p1-p2|，|q1-q2|}，S中的最接近点对或者是{p1，p2}，或者是{q1，q2}，或者是某个{p3，q3}，其中p3∈S1且q3∈S2； 可以用线性时间就可以找到问题的解； 分割点m的选取不当，会造成|Si|=1，|Sj|=n-1的情形，使得T(n)=T(n-1)+O(n)=O(n²)。这种情形可以通过“平衡子问题”方法加以解决：选取各坐标的中位数作分割点。 二维空间中的情形 选取一垂直线l：x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1和S2； 递归地在S1和S2上找出其最小距离d1和d2，并设d=min{d1，d2}，S中的最接近点1对或者是d，或者是某个{p，q}，其中p∈S1且q∈S2； 复杂度分析 算法分析 任何求最大最小的算法从起始状态到完成状态所用比较次数不可少于 (3n/2)(上取整)-2； (3n/2)(上取整)-2是所有基于比较的求最大最小算法所需比较次数的下界； 堆排序，归并排序在最坏情况下有较好的性能(针对渐进复杂性而言)； 堆排序，归并排序，快速排序在平均情况下性能较优。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Greedy","slug":"AlgorithmChapter4","date":"2020-12-11T12:10:21.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2020/12/11/AlgorithmChapter4/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/11/AlgorithmChapter4/","excerpt":"","text":"贪心法引言优化问题：贪心法常用于解优化问题 应用： 货箱装船问题 背包问题 拓扑排序问题 哈夫曼编码问题 最短路径问题 最小代价生成树 偶图覆盖问题 优化解即指始目标函数极大化(或极小化)的可行解，对应的目标函数值成为优化值。 很多优化问题时NP-难度问题，迄今找不到他们的多项式算法。所以计算上可行的方法就是求其近似解。贪心法是求近似算法的主要途径。 贪心法：一种多步求解的方法每步按一种局部优化的策略选择解(元组)的一个分量； 算法以第n步结束时构造出的对象(元组)作为问题的解； 这种局部优化的策略又称为“贪心标准”。 贪心法主要特点 不回溯：选定一个分量后，不重试其他可能。 使用局部优化策略的主要原因是减小计算开销。但局部优化策略不保证得到精确优化解，可能得到的是近似解。特别是对NP-难度问题。 不同的“贪心”策略得到不同的算法。 常常采纳使目标函数有最大增量的策略为贪心策略；增量是局部性概念。 遗传算法，神经网络等等都是具有这类贪心性质的启发式算法。 贪心算法性能贪心算法并不总能求得问题的整体最优解。但对于活动安排问题，机器调度问题，上述贪心算法却总能求得整体最优解。 K-优化算法K-优化算法是上述密度贪心算法的改进，改进后误差可控制在1/(k+1)*100%之内 算法得时间复杂度随k的增大而增加： 需要测试的子集数目为O(pow(n,k))； 每一个子集做贪心法需时间O(n)； 因此当k&gt;0时总的时间开销为O(pow(n,k+1))； 内容： 先对物品按密度从大到小排序； 先将一些物品装入背包，然后对其余物品使用贪心法； 预先装入的物品数不超过k； 对所有物品数不超过k的物品子集执行上述过程，并从中找到有最大效益值得解作为k-优化算法得解。 哈夫曼编码问题前缀码：对每一个字符规定一个0，1串作为其代码，并要求任一字符的代码都不是其他字符代码的前缀，这种编码成为前缀码。 使平均码长达到最小的前缀码编码方案成为未定编码字符集C的最优前缀码。 哈夫曼提出构造最优前缀码的贪心算法，由此产生的编码方案成为哈夫曼编码。 具体算法： 根据n个权值{w1, w2, …, wn}构成n棵二叉树的集合F={T1，T2,… Tn}，其中每棵二叉树Ti中只有一个带权值为wi的根节点，其左右子树均为空。 在F中选取两棵根节点权值最小的树作为左右子树来构造一棵新的二叉树，且置新的二叉树的根节点的权值为其左右子树的根节点权值之和。 在F中删除这两棵树，同时将新得到的二叉树加入F中。 重复step2，3，直到F中只含一棵树时为止。称这棵树为最优二叉树或哈夫曼树。 如果约定将每个节点的左分支表示字符‘0’，右分支表示字符‘1’，则可以把从根节点到某叶子节点的路径上分支字符组成的字符串作为该叶子节点的编码。 哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。 算法以|C|个叶节点开始，执行|C|-1次的“合并”运算后产生最终所要求的树T。 关于n个字符的哈夫曼算法的计算时间为O(nlogn)。 拓扑排序邻接矩阵与邻接表 拓扑排序定义：根据任务的有向图建立拓扑序列的过程。 贪心策略：从当前尚不在拓扑排序序列的顶点中选择一项顶点w，其所有先行节点v都在已产生的拓扑序列中(或无先行顶点)并将其加入到拓扑序列中。 使用栈的伪代码： 计算每个顶点的入度 将入度为0的顶点入栈 While(栈不空){ ​ 任取一入度为0的顶点放入拓扑序列中； ​ 将与其相邻的顶点的入度减1； ​ 如有新的入度为0的顶点出现，将其放入栈中； } 如有剩余的顶点则该图有环路 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243bool Network::Topological(int v[])&#123; //计算有向图中顶点的拓扑次序 //如果找到了一个拓扑次序，则返回true，此时，在v[0:n-1]中记录拓扑次序 //如果不存在拓扑次序，则返回false int n=Vertices(); //计算入度 int *InDegree=new int[n+1]; InitializePos();//图遍历器数组 for(int i=1;i&lt;=n;i++)//初始化 InDegree[i]=0; for(int i=1;i&lt;=n;i++)//从i出发的边 &#123; int u=Begin(i); while(u) &#123; InDegree[u]++; u=NextVertex(i); &#125; &#125; //把入度为0的顶点压入堆栈 LinkedStack&lt;int&gt; S; for(int i=1;i&lt;=n;i++) if(!InDegree[i]) S.Add(i); //产生拓扑次序 i=0;//数组v的游标 while(!S.IsEmpty())//从堆栈中选择下一个顶点 &#123; int w; S.Delete(w); v[i++]=w; int u=Begin(w); while(u)//修改入度 &#123; InDegree[u]--; if(!InDegree[u]) S.Add[u]; u=NextVertex(w); &#125; &#125; DeactivatePos(); delete [] InDegree; return (i==n);&#125; 上述算法的时间复杂度： Θ(n²)：使用邻接矩阵；Θ(n+e)：使用邻接表 单源最短路径任给一有向图G，它的每条边都有一个非负的权值，路径的长度定义为路径上边的权值之和。 单源最短路径问题：给定的源节点s，找出从s到图中所有其他节点(成为目的)的最短路径(优化解)及其长度(优化值) Dijkstra‘s最短路算法 如果链路权值非负，则最短路的子路径也是最短路，其长度小于原来路径的长度。所以，长度较小的最短路容易找到。 贪心策略：按最短路长度从小到大依次求解。 Dijkstra’s最短路算法使用上述贪心策略，是图论算法中应用最为广泛的算法，主要原因是其计算复杂度低且容易实现。 基本步骤： 维护一个集合S，该集合中源节点到其他节点的最短路已知，初始时该集合为空； 从V-S结合中找一节点v，满足源节点到该节点距离最小； 更新v的临界点的到源节点的距离值。 Example：1 S：{A,C,E,B,D} 源节点为A，所以S：{A}； 在S中的节点中找到于之有关的最短路径，将另一节点放入S中； 即AC=min，所以S：{A,C}； CE=min，所以S：{A,C,E}； CB=min，所以S：{A,C,E,B}； BD=min，所以S：{A,C,E,B,D} ∴S：{A,C,E,B,D} Example：2 Example of breadth-first search： Bellman-Ford算法介绍：Dijkstra算法无法判断含负权边的图的最短路。如果遇到负权，在没有负权回路（回路的权值和为负，即便有负权的边）存在时，也可以采用Bellman - Ford算法正确求出最短路径。 Bellman-Ford算法能在更普遍的情况下（存在负权边）解决单源点最短路径问题。对于给定的带权（有向或无向）图 G=(V,E), 其源点为s，加权函数 w是 边集 E 的映射。对图G运行Bellman - Ford算法的结果是一个布尔值，表明图中是否存在着一个从源点s可达的负权回路。若不存在这样的回路，算法将给出从源点s到 图G的任意顶点v的最短路径d[v]。 Floyd算法时间复杂度：O(n³)；空间复杂度：O(n²)(矩阵) 最小生成树 具有n个顶点的连通无向图G，图的每条边e有一非负权值c(e)，也称为成本，求有最小成本的生成树。 每个生成树刚好具有n-1条边，所以问题是用某种方法选择n-1条边使它们形成G的最小生成树。 Kruskal’s算法；Prim‘s算法。 Kruskal’s算法贪心策略：每次选择权值c(e)最小且与以前选择的边不构成回路的边。 上述策略要求按权值从小到大对边排序。 算法可在O(n+eloge)找出最小生成树。 Prim‘s算法步骤： 在图中选出权值最小的边，边的两个顶点放入点集V； 在图中找到权值最小且与点集V有关的边； 重复2直至找到最小生成树。 偶图覆盖问题(二分覆盖) 偶图是一个无向图，它的n个顶点分为集合A和集合B，且同一集合中的任意两个顶点无边相连。 A的一个子集A’覆盖集合B iff B中每一个顶点至少和A’中一顶点相连。覆盖A‘的大小指A’中的顶点数目。 在偶图中寻找最小覆盖的问题成为偶图覆盖(bipartite-layout:)问题。 Example： 上图为有17个顶点的二分图； A={1，2，3，16，17}；B={4，5，6，7，8，9，10，11，12，13，14，15}； 子集A’={1，16，17}是B的最小覆盖：1覆盖{4，6，7，8，9，13}；16覆盖{5，6，8，12，14，15}；17覆盖{4，9，10，11} 贪心策略：选择覆盖B中那些尚未被覆盖的顶点数最多的A的系节点。 对上图应用上述贪心法，得到A‘={1，16，17}。 覆盖算法总的算法复杂性为O(Sizeof(A²)+n²)或O(Sizeof(A²)+n+e)。 连续背包问题一种可行的贪心策略：按价值密度非递减的顺序检查物品，若剩余容量能容下正在考察的物品，将其装入；否则往背包中装入此物品的一部分。 证明这种贪心算法总能产生最优解：","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Analysis of Algorithms","slug":"AlgorithmChapter3","date":"2020-12-10T05:20:54.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2020/12/10/AlgorithmChapter3/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/10/AlgorithmChapter3/","excerpt":"","text":"Pseudocode（伪代码）Soving Recurrences（解递归）1.Recursion tree 解T(n)=2T(n/2)+cn，其中c&gt;0为常数。递归展开到T(n0)，会导致推导的麻烦。所以解递归展开到T(1)，然后再从前n0个T(n)的值确定渐进分析的常数。 继续展开得到 Total=Θ(nlgn)。 很多递归式用递归树解不出来，但递归树能提供直觉，帮助我们用归纳法求解(Guess归纳假设) 较一般的递归式：T(n)=aT(n/b)+cn a，b是大于1的整数，递归树方法仍可使用。 2.Substitution methodThe most general method： 1.Guess the form of the solution； 2.Vertify by induction； 3.Solve for constants。 3.Master methodT(n)=aT(n/b)+f(n)。式中a&gt;=1，b&gt;=1，为整数，f(n)&gt;0 以下loga均指以b为底a的对数 Case 1：f(n)&lt;pow(n,loga)f(n)=O(pow(n,loga-ε))，ε&gt;0，为某一常数。f(n)的增长渐进地慢于pow(n,loga)(慢pow(n,ε)倍) ∴Solution：T(n)=Θ(pow(n,loga))。 Case 2：f(n)=Θ(pow(n,loga)*pow(lgn,k)) k&gt;=0为某一常数 f(n)和pow(n,loga)几乎有相同的渐进增长率。 ∴Solution：T(n)=Θ(pow(n,loga)*pow(lgn,k+1))。 Case 3：f(n)&gt;pow(n,loga)f(n)=Ω(pow(n,loga+ε))，ε&gt;0，为某一常数。f(n)的增长渐进地快于pow(n,loga)(快pow(n,ε)倍) 其中，f(n)满足：af(n/b)&lt;=cf(n)，0&lt;c&lt;1为常数 ∴Solution：T(n)=Θ(f(n))。 总结：等式右边，哪项变化得快，T(n)就属于哪项的数量级。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"是非黑白 自在人心","slug":"是非黑白-自在人心","date":"2020-12-10T03:56:15.000Z","updated":"2021-04-11T04:26:34.098Z","comments":false,"path":"2020/12/10/是非黑白-自在人心/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/10/%E6%98%AF%E9%9D%9E%E9%BB%91%E7%99%BD-%E8%87%AA%E5%9C%A8%E4%BA%BA%E5%BF%83/","excerpt":"","text":"是非黑白，自在人心 ​ 世上本没有路，走的人多了，也便成了路；类似地，有的言论说多了，就有人选择相信。在现在的信息化时代中，人们对信息的获取非常便捷，但是人们接受信息的时间和方式非常的碎片化，很可能尝尝因为一张图片，一个视频片段，一段采访，一篇文章，而相信一个所谓的事实。而往往很多人会去选择相信一个错误的事实。人的观点和思想很容易被改变，往往很多时候不是被事实所影响，甚至是被言语所影响。 毕竟这是个打字不用负责任的年代 有时候你看到的不一定是事实，你以为的事实不一定是真相 建议切换白天与夜晚模式浏览","categories":[{"name":"Humanity","slug":"Humanity","permalink":"https://cheeseburgerim.github.io/categories/Humanity/"}],"tags":[{"name":"Humanity","slug":"Humanity","permalink":"https://cheeseburgerim.github.io/tags/Humanity/"}]},{"title":"Chapter 2 程序性能","slug":"AlgorithmChapter2","date":"2020-12-10T02:54:40.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2020/12/10/AlgorithmChapter2/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/10/AlgorithmChapter2/","excerpt":"","text":"空间复杂度Sp(n)1.定义指程序运行时所需的内存空间大小和实例特征的函数关系。 2.程序运行时所需空间包括指令空间：与实例特征无关的常数； 数据空间：常量和简单变量-与实例无关； ​ 复合变量-数组，链表，树和图等； ​ 环境栈空间-函数调用-是否递归； 复合变量所需空间尝尝和问题实例特征有关； 3.计算S(p)=c+Sp(instance characteristics) 其中c为常量(实例无关部分)，Sp为可变部分。在使用解析方法研究程序p的空间复杂度时仅考虑Sp。在分析空间复杂度时我们忽略与实例特征无关的空间需求量。 4.例题12345678910template &lt;class T&gt;int SequentialSearch(T a[], const T&amp; x, int n)&#123; //Search the unordered list a[0:n-1] for x. //Return position if found; Return -1 otherwise. int i; for(i=0;i&lt;n&amp;&amp;a[i]!=x;i++) if(i==n) return -1; return i;&#125; 实例特征：n，S(n)=0; 该程序所占空间均为常量，与实例特征无关，所以S(n)=0。 时间复杂度T(n)1.定义指程序执行时所用的时间。 2.计算在使用解析方法时程序p的时间复杂度表示为输入量的函数T。 在解析地分析时间复杂度时，使用以下两种时间单位并计算： ​ 操作步数(operation count)：算法的基本操作； ​ (程序)步计数(step count)：分析全部程序。 要点：基本操作或程序步执行的时间必须时常数。 3.例题s/e：代表该语句执行后步数(count)的变化(增量)； Frequency：代表该语句执行的次数； Total steps：代表该语句在整个程序执行过程中引发的总步数。 Statement s/e Frequency Total steps T Sum(T a[],int n) 0 0 0 { 0 0 0 T tsum=0; 1 1 1 for(int i=0;i&lt;n;i++) 1 n+1 n+1 tsum+=a[i]; 1 n n return tsum; 1 1 1 } 0 0 0 Total 2n+3 渐进分析（O,Ω,Θ）1.定义计算机科学使用最多的符号-讨论算法时使用的共同语言 O：上界；Ω：下界；Θ：同阶。 2.随n的增加T(n)的增长率 3.渐进分析时用到的一些等式 E8：i form 1 to n. ∑1/i -&gt; Θ(logn) 4.例题 Statement s/e Frequency Total steps T Sum(T a[], int n) 0 0 Θ(0) { 0 0 Θ(0) T tsum=0; 1 1 Θ(1) for(int i=0;i&lt;n;i++) 1 n+1 Θ(n) tsum+=a[i]; 1 n Θ(n) return tsum; 1 1 Θ(1) } 0 0 Θ(0) ∴ t(n)=Θ(max{})=Θ(n)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"Chapter 1 算法概述","slug":"AlgorithmChapter1","date":"2020-12-10T02:28:04.000Z","updated":"2021-04-11T04:26:34.104Z","comments":false,"path":"2020/12/10/AlgorithmChapter1/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/10/AlgorithmChapter1/","excerpt":"","text":"算法1.定义：是对特定问题求解步骤的一种描述，是指令的有限序列。 2.特征： 输入：算法有零个或多个输入量； 输出：算法至少产生一个输出量； 确定性：算法的每一条指令都有确切的定义，没有二义性； 能行性：算法的每一条指令必须足够基本，他们可以通过已经实现的基本运算执行有限次来实现。 有穷性：算法必须总能在执行有限步之后终止。 程序：程序是算法用某种程序语言的具体实现程序可以不满足算法的5条性质。 操作系统，是一个在无限循环中执行的程序，因而不是一个算法。 操作系统的各种任务可看成是单独的问题，每一个问题由操作系统中的一个子程序通过特定的算法来实现。该子程序得到输出结果后便终止。 算法的性能：算法所需的计算时间和占用的内存空间问题和问题求解常见的应用问题类型：1.搜索问题；2.排序问题；3.图论问题；4.组合数学问题；5.几何问题；6.数值计算问题； P问题 P问题能够保证存在多项式时间求解算法； NP问题不确定是否存在多项式时间求解算法，但确定存在多项式时间验证算法； P问题是NP问题的子集，因为存在多项式时间求解算法的问题，一定能够在多项式时间内被验证； NP-hard问题不一定是NP问题，有可能是不可判定问题。这时候说明原问题也是不可判定的； NPC问题既是NP问题的子集，又是NP-hard问题的子集，所以NPC问题是NP问题和NP-hard问题的交集； NP-hard问题和NPC问题都要求能够在多项式时间内规约成另外一个问题。这里规约的意思是将一个特殊问题一般化，即将原问题推广为一个最一般的，最有概括性，也更难得，计算复杂度更高的问题，这个问题具有最高的计算复杂度，如果这个最一般的问题也能有多项式时间求解算法，那么那些特殊的原问题也能有多项式时间求解算法。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"}]},{"title":"IM","slug":"IM","date":"2020-12-08T13:42:52.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2020/12/08/IM/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/08/IM/","excerpt":"","text":"Part of the journey is the end. LoveU3000 Click here to watch a MARVELous video→LoveU3000 Lines TrailerGosh seems like thousand years ago. I fought my way out of the cave, became iron man. Realized I loved you. I know I said no more surprises, but I was really hoping to pull off the one last one. Avengers：Endgame This thing on? Hey, Miss Potts. Pep. If you find this recording, don’t post it on social media. It’s gonna be a real tearjerker. I don’t know if you’re ever gonna see these. I don’t even know if you’re still … Oh, God, I hope so. Today’s day 21. No, 22. You know, if it wasn’t for the existential terror of staring into the literal void of space, I’d say I’m feeling a little better today. Infection’s run its course, thanks to the Blue Meanie back there. You’d love her. Very practical. Only a tiny bit sadistic. So, the fuel cells were cracked during battle and we figured out a way to reverse the ion charge and bought ourselves about 48 hours of flight time. But it’s now dead in the water. Thousand light years from the nearest 7-Eleven. Oxygen will run out tomorrow morning and that’ll be it. Pep, I know I said no more surprises but I gotta say I was really hoping to pull off one last one. But it looks like … Well, you know what it looks like. Don’t feel bad about this. I mean, actually, if you grovel for a couple weeks and then move on with enormous guilt. I should probably lie down for a minute. Go rest my eyes. Please know, when I drift off, it’ll be like every night lately. I’m fine. Totally fine. I dream about you. Because it’s always you. No amount of money ever bought a second of time. Everybody wants a happy ending, right? But it doesn’t always roll that way. Maybe this time. I’m hoping if you play this back, it’s in celebration. I hope families are reunited. I hope we get it back. And something like a normal version of the planet has been restored. If there ever was such a thing. God, what a world. Universe, now. If you told me 10 years ago that we weren’t alone, let alone to this extent, I mean, I wouldn’t have been surprised, but come on, who knew? The epic forces of darkness and light that have come into play. And for better or worse, that’s the reality Morgan’s gonna have to find a way to grow up in. So, I thought I’d probably better record a little greeting in the case of an untimely death. On my part. Not that death at any time isn’t untimely. This time travel thing that we’re gonna try and pull off tomorrow, it’s got me scratching my head about the survivability of it all. That’s the thing. Then again, that’s the hero gig, right? Part of the journey is the end. What am I even tripping for? Everything is gonna work out exactly the way it’s supposed to. I love you 3000.","categories":[{"name":"IM","slug":"IM","permalink":"https://cheeseburgerim.github.io/categories/IM/"}],"tags":[{"name":"IM","slug":"IM","permalink":"https://cheeseburgerim.github.io/tags/IM/"}]},{"title":"New beginning","slug":"New-beginning","date":"2020-12-08T07:58:12.000Z","updated":"2021-04-11T04:26:34.099Z","comments":false,"path":"2020/12/08/New-beginning/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/08/New-beginning/","excerpt":"","text":"​ 2020/12/8, I built up this website to write down my different phases and some details in my life. This is a totally new start. I will improve this blog gradually and share my ideas and feelings.","categories":[{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/categories/New/"}],"tags":[{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/tags/New/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-08T06:56:49.000Z","updated":"2021-04-11T04:26:34.101Z","comments":false,"path":"2020/12/08/hello-world/","link":"","permalink":"https://cheeseburgerim.github.io/2020/12/08/hello-world/","excerpt":"","text":"Original website https://butterfly.js.org/ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new post &quot;Post Name&quot; More info: Writing Run server1$ hexo s More info: Server Generate static files1$ hexo g More info: Generating Deploy to remote sites1$ hexo d More info: Deployment 注意： 1.现安装douban插件，生成网页的命令为hexo douban，由于前缀和hexo deploy相同，所以以后上传时要使用hexo deploy命令。 2.hexo根目录下_config,yml文件中douban中builtin已设置为true，即在hexo g和hexo s时包括了hexo douban命令。 Clean1$ hexo cl More info: Clean Font AwesomeFont Awesomehttp://www.fontawesome.com.cn/ Font Awesome（foreign）https://fontawesome.com/ Font Awesome 4https://fontawesome.dashgame.com/ Font Awesome 5https://fa5.dashgame.com/#/ 聚合图床http://www.superbed.cn/admin Iconfont+https://www.iconfont.cn/ emojipediahttps://emojipedia.org/ Shieldshttps://shields.io/ Tips引用JS/CSS文件Take CSS as an example： 1.新建一个CSS文件，移动到 \\butterfly\\source\\css\\ 目录下。 2.在主题配置文件(\\hexo\\themes\\butterfly_config.yml)中定位搜索 inject。 3.其中head是用来引入 CSS 文件；bottom 是用来引用 JS 文件。 页内跳转Format：[ ] ( ) 中括号内为名称，小括号内为跳转位置 Example：Jump Here小括号中必须和标题格式一摸一样，英文字母全部小写，且不能含有emoji等特殊符号 Hexo文章的密码访问方法一 方法实现，因Hexo中Markdown语言和html是混用的，所以可直接在Markdown中直接插入以下这段script(建议放到&lt;!-- more --&gt;段后面)。这里用到了windows对象的alert()方法和prompt()方法。prompt()方法的作用即是显示一个可提示用户输入的对话框，而其本身的返回值就是你输入的那个字符串。因此只需要将其与你默认的密码比较一下就好，如果不正确，则直接将当前页面的loaction属性设为上一个页面即可。 1234567891011&lt;script&gt; if(&quot;123&quot;==prompt(&quot;请输入文档密码&quot;)) &#123; alert(&quot;密码正确&quot;); &#125; else &#123; alert(&quot;密码错误返回主页&quot;); location=&quot;/&quot;; &#125;&lt;/script&gt; html语言 方法二 安装 1npm install --save hexo-blog-encrypt 在front-matter中添加password password: your password Gitee图床 注册Gitee账号； 新建仓库； 上传图片； 打开图片得到链接形如 https://gitee.com/username/repository/blob/… 修改链接 将blob改为raw即可在markdown中使用","categories":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/categories/Introduction/"}],"tags":[{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/tags/New/"}]}],"categories":[{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/categories/Language/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/categories/Code/"},{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/categories/Study/"},{"name":"Solution","slug":"Solution","permalink":"https://cheeseburgerim.github.io/categories/Solution/"},{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/categories/DataBase/"},{"name":"Notification","slug":"Notification","permalink":"https://cheeseburgerim.github.io/categories/Notification/"},{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/categories/Game/"},{"name":"Guidance","slug":"Guidance","permalink":"https://cheeseburgerim.github.io/categories/Guidance/"},{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/categories/Postgraduate/"},{"name":"Rubik'sCube","slug":"Rubik-sCube","permalink":"https://cheeseburgerim.github.io/categories/Rubik-sCube/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/categories/Introduction/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/categories/Lab/"},{"name":"Physics","slug":"Physics","permalink":"https://cheeseburgerim.github.io/categories/Physics/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/categories/OS/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/categories/Algorithm/"},{"name":"Humanity","slug":"Humanity","permalink":"https://cheeseburgerim.github.io/categories/Humanity/"},{"name":"IM","slug":"IM","permalink":"https://cheeseburgerim.github.io/categories/IM/"},{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/categories/New/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://cheeseburgerim.github.io/tags/Study/"},{"name":"Code","slug":"Code","permalink":"https://cheeseburgerim.github.io/tags/Code/"},{"name":"Programme","slug":"Programme","permalink":"https://cheeseburgerim.github.io/tags/Programme/"},{"name":"Language","slug":"Language","permalink":"https://cheeseburgerim.github.io/tags/Language/"},{"name":"Java","slug":"Java","permalink":"https://cheeseburgerim.github.io/tags/Java/"},{"name":"CodeExercise","slug":"CodeExercise","permalink":"https://cheeseburgerim.github.io/tags/CodeExercise/"},{"name":"Exercise","slug":"Exercise","permalink":"https://cheeseburgerim.github.io/tags/Exercise/"},{"name":"Practice","slug":"Practice","permalink":"https://cheeseburgerim.github.io/tags/Practice/"},{"name":"NCMAM","slug":"NCMAM","permalink":"https://cheeseburgerim.github.io/tags/NCMAM/"},{"name":"Course","slug":"Course","permalink":"https://cheeseburgerim.github.io/tags/Course/"},{"name":"Git","slug":"Git","permalink":"https://cheeseburgerim.github.io/tags/Git/"},{"name":"Solution","slug":"Solution","permalink":"https://cheeseburgerim.github.io/tags/Solution/"},{"name":"Github","slug":"Github","permalink":"https://cheeseburgerim.github.io/tags/Github/"},{"name":"MLAMS","slug":"MLAMS","permalink":"https://cheeseburgerim.github.io/tags/MLAMS/"},{"name":"Introduction","slug":"Introduction","permalink":"https://cheeseburgerim.github.io/tags/Introduction/"},{"name":"ComputerNetwork","slug":"ComputerNetwork","permalink":"https://cheeseburgerim.github.io/tags/ComputerNetwork/"},{"name":"DataBase","slug":"DataBase","permalink":"https://cheeseburgerim.github.io/tags/DataBase/"},{"name":"DataBasePrinciple","slug":"DataBasePrinciple","permalink":"https://cheeseburgerim.github.io/tags/DataBasePrinciple/"},{"name":"ChangeDomainName","slug":"ChangeDomainName","permalink":"https://cheeseburgerim.github.io/tags/ChangeDomainName/"},{"name":"Notification","slug":"Notification","permalink":"https://cheeseburgerim.github.io/tags/Notification/"},{"name":"NOWCODER","slug":"NOWCODER","permalink":"https://cheeseburgerim.github.io/tags/NOWCODER/"},{"name":"Daily","slug":"Daily","permalink":"https://cheeseburgerim.github.io/tags/Daily/"},{"name":"Website","slug":"Website","permalink":"https://cheeseburgerim.github.io/tags/Website/"},{"name":"Design","slug":"Design","permalink":"https://cheeseburgerim.github.io/tags/Design/"},{"name":"js","slug":"js","permalink":"https://cheeseburgerim.github.io/tags/js/"},{"name":"Game","slug":"Game","permalink":"https://cheeseburgerim.github.io/tags/Game/"},{"name":"Recreation","slug":"Recreation","permalink":"https://cheeseburgerim.github.io/tags/Recreation/"},{"name":"Fun","slug":"Fun","permalink":"https://cheeseburgerim.github.io/tags/Fun/"},{"name":"To The Moon","slug":"To-The-Moon","permalink":"https://cheeseburgerim.github.io/tags/To-The-Moon/"},{"name":"css","slug":"css","permalink":"https://cheeseburgerim.github.io/tags/css/"},{"name":"OS","slug":"OS","permalink":"https://cheeseburgerim.github.io/tags/OS/"},{"name":"Postgraduate","slug":"Postgraduate","permalink":"https://cheeseburgerim.github.io/tags/Postgraduate/"},{"name":"html","slug":"html","permalink":"https://cheeseburgerim.github.io/tags/html/"},{"name":"postgraduate","slug":"postgraduate","permalink":"https://cheeseburgerim.github.io/tags/postgraduate/"},{"name":"Hexo","slug":"Hexo","permalink":"https://cheeseburgerim.github.io/tags/Hexo/"},{"name":"Guidance","slug":"Guidance","permalink":"https://cheeseburgerim.github.io/tags/Guidance/"},{"name":"PTA","slug":"PTA","permalink":"https://cheeseburgerim.github.io/tags/PTA/"},{"name":"Marxism","slug":"Marxism","permalink":"https://cheeseburgerim.github.io/tags/Marxism/"},{"name":"Rubik'sCube","slug":"Rubik-sCube","permalink":"https://cheeseburgerim.github.io/tags/Rubik-sCube/"},{"name":"LOL","slug":"LOL","permalink":"https://cheeseburgerim.github.io/tags/LOL/"},{"name":"COC","slug":"COC","permalink":"https://cheeseburgerim.github.io/tags/COC/"},{"name":"fun","slug":"fun","permalink":"https://cheeseburgerim.github.io/tags/fun/"},{"name":"RO","slug":"RO","permalink":"https://cheeseburgerim.github.io/tags/RO/"},{"name":"New","slug":"New","permalink":"https://cheeseburgerim.github.io/tags/New/"},{"name":"Markdown","slug":"Markdown","permalink":"https://cheeseburgerim.github.io/tags/Markdown/"},{"name":"Lab","slug":"Lab","permalink":"https://cheeseburgerim.github.io/tags/Lab/"},{"name":"NEMU","slug":"NEMU","permalink":"https://cheeseburgerim.github.io/tags/NEMU/"},{"name":"Physics","slug":"Physics","permalink":"https://cheeseburgerim.github.io/tags/Physics/"},{"name":"GTAV","slug":"GTAV","permalink":"https://cheeseburgerim.github.io/tags/GTAV/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://cheeseburgerim.github.io/tags/Algorithm/"},{"name":"Humanity","slug":"Humanity","permalink":"https://cheeseburgerim.github.io/tags/Humanity/"},{"name":"IM","slug":"IM","permalink":"https://cheeseburgerim.github.io/tags/IM/"}]}